// Code generated by Kitex v0.8.0. DO NOT EDIT.

package datasinks

import (
	"bytes"
	"fmt"
	"reflect"
	"strings"

	"github.com/apache/thrift/lib/go/thrift"

	"github.com/cloudwego/kitex/pkg/protocol/bthrift"

	"github.com/selectdb/ccr_syncer/pkg/rpc/kitex_gen/descriptors"
	"github.com/selectdb/ccr_syncer/pkg/rpc/kitex_gen/exprs"
	"github.com/selectdb/ccr_syncer/pkg/rpc/kitex_gen/partitions"
	"github.com/selectdb/ccr_syncer/pkg/rpc/kitex_gen/plannodes"
	"github.com/selectdb/ccr_syncer/pkg/rpc/kitex_gen/types"
)

// unused protection
var (
	_ = fmt.Formatter(nil)
	_ = (*bytes.Buffer)(nil)
	_ = (*strings.Builder)(nil)
	_ = reflect.Type(nil)
	_ = thrift.TProtocol(nil)
	_ = bthrift.BinaryWriter(nil)
	_ = descriptors.KitexUnusedProtection
	_ = exprs.KitexUnusedProtection
	_ = partitions.KitexUnusedProtection
	_ = plannodes.KitexUnusedProtection
	_ = types.KitexUnusedProtection
)

func (p *TParquetSchema) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TParquetSchema[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TParquetSchema) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := TParquetRepetitionType(v)
		p.SchemaRepetitionType = &tmp

	}
	return offset, nil
}

func (p *TParquetSchema) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := TParquetDataType(v)
		p.SchemaDataType = &tmp

	}
	return offset, nil
}

func (p *TParquetSchema) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.SchemaColumnName = &v

	}
	return offset, nil
}

func (p *TParquetSchema) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := TParquetDataLogicalType(v)
		p.SchemaDataLogicalType = &tmp

	}
	return offset, nil
}

// for compatibility
func (p *TParquetSchema) FastWrite(buf []byte) int {
	return 0
}

func (p *TParquetSchema) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TParquetSchema")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TParquetSchema) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TParquetSchema")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TParquetSchema) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSchemaRepetitionType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "schema_repetition_type", thrift.I32, 1)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.SchemaRepetitionType))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TParquetSchema) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSchemaDataType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "schema_data_type", thrift.I32, 2)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.SchemaDataType))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TParquetSchema) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSchemaColumnName() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "schema_column_name", thrift.STRING, 3)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.SchemaColumnName)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TParquetSchema) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSchemaDataLogicalType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "schema_data_logical_type", thrift.I32, 4)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.SchemaDataLogicalType))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TParquetSchema) field1Length() int {
	l := 0
	if p.IsSetSchemaRepetitionType() {
		l += bthrift.Binary.FieldBeginLength("schema_repetition_type", thrift.I32, 1)
		l += bthrift.Binary.I32Length(int32(*p.SchemaRepetitionType))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TParquetSchema) field2Length() int {
	l := 0
	if p.IsSetSchemaDataType() {
		l += bthrift.Binary.FieldBeginLength("schema_data_type", thrift.I32, 2)
		l += bthrift.Binary.I32Length(int32(*p.SchemaDataType))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TParquetSchema) field3Length() int {
	l := 0
	if p.IsSetSchemaColumnName() {
		l += bthrift.Binary.FieldBeginLength("schema_column_name", thrift.STRING, 3)
		l += bthrift.Binary.StringLengthNocopy(*p.SchemaColumnName)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TParquetSchema) field4Length() int {
	l := 0
	if p.IsSetSchemaDataLogicalType() {
		l += bthrift.Binary.FieldBeginLength("schema_data_logical_type", thrift.I32, 4)
		l += bthrift.Binary.I32Length(int32(*p.SchemaDataLogicalType))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TResultFileSinkOptions) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetFilePath bool = false
	var issetFileFormat bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetFilePath = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetFileFormat = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField9(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 11:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField11(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 12:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField12(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 13:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField13(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 14:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField14(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 15:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField15(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 16:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField16(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 17:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField17(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 18:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField18(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 19:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField19(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetFilePath {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetFileFormat {
		fieldId = 2
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TResultFileSinkOptions[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TResultFileSinkOptions[fieldId]))
}

func (p *TResultFileSinkOptions) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.FilePath = v

	}
	return offset, nil
}

func (p *TResultFileSinkOptions) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.FileFormat = plannodes.TFileFormatType(v)

	}
	return offset, nil
}

func (p *TResultFileSinkOptions) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.ColumnSeparator = &v

	}
	return offset, nil
}

func (p *TResultFileSinkOptions) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.LineDelimiter = &v

	}
	return offset, nil
}

func (p *TResultFileSinkOptions) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.MaxFileSizeBytes = &v

	}
	return offset, nil
}

func (p *TResultFileSinkOptions) FastReadField6(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.BrokerAddresses = make([]*types.TNetworkAddress, 0, size)
	for i := 0; i < size; i++ {
		_elem := types.NewTNetworkAddress()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.BrokerAddresses = append(p.BrokerAddresses, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TResultFileSinkOptions) FastReadField7(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := bthrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.BrokerProperties = make(map[string]string, size)
	for i := 0; i < size; i++ {
		var _key string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_key = v

		}

		var _val string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_val = v

		}

		p.BrokerProperties[_key] = _val
	}
	if l, err := bthrift.Binary.ReadMapEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TResultFileSinkOptions) FastReadField8(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.SuccessFileName = &v

	}
	return offset, nil
}

func (p *TResultFileSinkOptions) FastReadField9(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Schema = make([][]string, 0, size)
	for i := 0; i < size; i++ {
		_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
		offset += l
		if err != nil {
			return offset, err
		}
		_elem := make([]string, 0, size)
		for i := 0; i < size; i++ {
			var _elem1 string
			if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
				return offset, err
			} else {
				offset += l

				_elem1 = v

			}

			_elem = append(_elem, _elem1)
		}
		if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.Schema = append(p.Schema, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TResultFileSinkOptions) FastReadField10(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := bthrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.FileProperties = make(map[string]string, size)
	for i := 0; i < size; i++ {
		var _key string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_key = v

		}

		var _val string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_val = v

		}

		p.FileProperties[_key] = _val
	}
	if l, err := bthrift.Binary.ReadMapEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TResultFileSinkOptions) FastReadField11(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.ParquetSchemas = make([]*TParquetSchema, 0, size)
	for i := 0; i < size; i++ {
		_elem := NewTParquetSchema()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.ParquetSchemas = append(p.ParquetSchemas, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TResultFileSinkOptions) FastReadField12(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := TParquetCompressionType(v)
		p.ParquetCompressionType = &tmp

	}
	return offset, nil
}

func (p *TResultFileSinkOptions) FastReadField13(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.ParquetDisableDictionary = &v

	}
	return offset, nil
}

func (p *TResultFileSinkOptions) FastReadField14(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := TParquetVersion(v)
		p.ParquetVersion = &tmp

	}
	return offset, nil
}

func (p *TResultFileSinkOptions) FastReadField15(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.OrcSchema = &v

	}
	return offset, nil
}

func (p *TResultFileSinkOptions) FastReadField16(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.DeleteExistingFiles = &v

	}
	return offset, nil
}

func (p *TResultFileSinkOptions) FastReadField17(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.FileSuffix = &v

	}
	return offset, nil
}

func (p *TResultFileSinkOptions) FastReadField18(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.WithBom = &v

	}
	return offset, nil
}

func (p *TResultFileSinkOptions) FastReadField19(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := plannodes.TFileCompressType(v)
		p.OrcCompressionType = &tmp

	}
	return offset, nil
}

// for compatibility
func (p *TResultFileSinkOptions) FastWrite(buf []byte) int {
	return 0
}

func (p *TResultFileSinkOptions) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TResultFileSinkOptions")
	if p != nil {
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField13(buf[offset:], binaryWriter)
		offset += p.fastWriteField16(buf[offset:], binaryWriter)
		offset += p.fastWriteField18(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
		offset += p.fastWriteField9(buf[offset:], binaryWriter)
		offset += p.fastWriteField10(buf[offset:], binaryWriter)
		offset += p.fastWriteField11(buf[offset:], binaryWriter)
		offset += p.fastWriteField12(buf[offset:], binaryWriter)
		offset += p.fastWriteField14(buf[offset:], binaryWriter)
		offset += p.fastWriteField15(buf[offset:], binaryWriter)
		offset += p.fastWriteField17(buf[offset:], binaryWriter)
		offset += p.fastWriteField19(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TResultFileSinkOptions) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TResultFileSinkOptions")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field9Length()
		l += p.field10Length()
		l += p.field11Length()
		l += p.field12Length()
		l += p.field13Length()
		l += p.field14Length()
		l += p.field15Length()
		l += p.field16Length()
		l += p.field17Length()
		l += p.field18Length()
		l += p.field19Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TResultFileSinkOptions) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "file_path", thrift.STRING, 1)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.FilePath)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TResultFileSinkOptions) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "file_format", thrift.I32, 2)
	offset += bthrift.Binary.WriteI32(buf[offset:], int32(p.FileFormat))

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TResultFileSinkOptions) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetColumnSeparator() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "column_separator", thrift.STRING, 3)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.ColumnSeparator)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TResultFileSinkOptions) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetLineDelimiter() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "line_delimiter", thrift.STRING, 4)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.LineDelimiter)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TResultFileSinkOptions) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetMaxFileSizeBytes() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "max_file_size_bytes", thrift.I64, 5)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.MaxFileSizeBytes)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TResultFileSinkOptions) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetBrokerAddresses() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "broker_addresses", thrift.LIST, 6)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.BrokerAddresses {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TResultFileSinkOptions) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetBrokerProperties() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "broker_properties", thrift.MAP, 7)
		mapBeginOffset := offset
		offset += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRING, 0)
		var length int
		for k, v := range p.BrokerProperties {
			length++

			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, k)

			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.STRING, thrift.STRING, length)
		offset += bthrift.Binary.WriteMapEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TResultFileSinkOptions) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSuccessFileName() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "success_file_name", thrift.STRING, 8)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.SuccessFileName)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TResultFileSinkOptions) fastWriteField9(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSchema() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "schema", thrift.LIST, 9)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.LIST, 0)
		var length int
		for _, v := range p.Schema {
			length++
			listBeginOffset := offset
			offset += bthrift.Binary.ListBeginLength(thrift.STRING, 0)
			var length int
			for _, v := range v {
				length++
				offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

			}
			bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRING, length)
			offset += bthrift.Binary.WriteListEnd(buf[offset:])
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.LIST, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TResultFileSinkOptions) fastWriteField10(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFileProperties() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "file_properties", thrift.MAP, 10)
		mapBeginOffset := offset
		offset += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRING, 0)
		var length int
		for k, v := range p.FileProperties {
			length++

			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, k)

			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.STRING, thrift.STRING, length)
		offset += bthrift.Binary.WriteMapEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TResultFileSinkOptions) fastWriteField11(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetParquetSchemas() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "parquet_schemas", thrift.LIST, 11)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.ParquetSchemas {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TResultFileSinkOptions) fastWriteField12(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetParquetCompressionType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "parquet_compression_type", thrift.I32, 12)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.ParquetCompressionType))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TResultFileSinkOptions) fastWriteField13(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetParquetDisableDictionary() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "parquet_disable_dictionary", thrift.BOOL, 13)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.ParquetDisableDictionary)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TResultFileSinkOptions) fastWriteField14(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetParquetVersion() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "parquet_version", thrift.I32, 14)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.ParquetVersion))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TResultFileSinkOptions) fastWriteField15(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetOrcSchema() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "orc_schema", thrift.STRING, 15)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.OrcSchema)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TResultFileSinkOptions) fastWriteField16(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDeleteExistingFiles() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "delete_existing_files", thrift.BOOL, 16)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.DeleteExistingFiles)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TResultFileSinkOptions) fastWriteField17(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFileSuffix() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "file_suffix", thrift.STRING, 17)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.FileSuffix)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TResultFileSinkOptions) fastWriteField18(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetWithBom() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "with_bom", thrift.BOOL, 18)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.WithBom)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TResultFileSinkOptions) fastWriteField19(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetOrcCompressionType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "orc_compression_type", thrift.I32, 19)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.OrcCompressionType))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TResultFileSinkOptions) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("file_path", thrift.STRING, 1)
	l += bthrift.Binary.StringLengthNocopy(p.FilePath)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TResultFileSinkOptions) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("file_format", thrift.I32, 2)
	l += bthrift.Binary.I32Length(int32(p.FileFormat))

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TResultFileSinkOptions) field3Length() int {
	l := 0
	if p.IsSetColumnSeparator() {
		l += bthrift.Binary.FieldBeginLength("column_separator", thrift.STRING, 3)
		l += bthrift.Binary.StringLengthNocopy(*p.ColumnSeparator)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TResultFileSinkOptions) field4Length() int {
	l := 0
	if p.IsSetLineDelimiter() {
		l += bthrift.Binary.FieldBeginLength("line_delimiter", thrift.STRING, 4)
		l += bthrift.Binary.StringLengthNocopy(*p.LineDelimiter)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TResultFileSinkOptions) field5Length() int {
	l := 0
	if p.IsSetMaxFileSizeBytes() {
		l += bthrift.Binary.FieldBeginLength("max_file_size_bytes", thrift.I64, 5)
		l += bthrift.Binary.I64Length(*p.MaxFileSizeBytes)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TResultFileSinkOptions) field6Length() int {
	l := 0
	if p.IsSetBrokerAddresses() {
		l += bthrift.Binary.FieldBeginLength("broker_addresses", thrift.LIST, 6)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.BrokerAddresses))
		for _, v := range p.BrokerAddresses {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TResultFileSinkOptions) field7Length() int {
	l := 0
	if p.IsSetBrokerProperties() {
		l += bthrift.Binary.FieldBeginLength("broker_properties", thrift.MAP, 7)
		l += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRING, len(p.BrokerProperties))
		for k, v := range p.BrokerProperties {

			l += bthrift.Binary.StringLengthNocopy(k)

			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.MapEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TResultFileSinkOptions) field8Length() int {
	l := 0
	if p.IsSetSuccessFileName() {
		l += bthrift.Binary.FieldBeginLength("success_file_name", thrift.STRING, 8)
		l += bthrift.Binary.StringLengthNocopy(*p.SuccessFileName)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TResultFileSinkOptions) field9Length() int {
	l := 0
	if p.IsSetSchema() {
		l += bthrift.Binary.FieldBeginLength("schema", thrift.LIST, 9)
		l += bthrift.Binary.ListBeginLength(thrift.LIST, len(p.Schema))
		for _, v := range p.Schema {
			l += bthrift.Binary.ListBeginLength(thrift.STRING, len(v))
			for _, v := range v {
				l += bthrift.Binary.StringLengthNocopy(v)

			}
			l += bthrift.Binary.ListEndLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TResultFileSinkOptions) field10Length() int {
	l := 0
	if p.IsSetFileProperties() {
		l += bthrift.Binary.FieldBeginLength("file_properties", thrift.MAP, 10)
		l += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRING, len(p.FileProperties))
		for k, v := range p.FileProperties {

			l += bthrift.Binary.StringLengthNocopy(k)

			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.MapEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TResultFileSinkOptions) field11Length() int {
	l := 0
	if p.IsSetParquetSchemas() {
		l += bthrift.Binary.FieldBeginLength("parquet_schemas", thrift.LIST, 11)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.ParquetSchemas))
		for _, v := range p.ParquetSchemas {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TResultFileSinkOptions) field12Length() int {
	l := 0
	if p.IsSetParquetCompressionType() {
		l += bthrift.Binary.FieldBeginLength("parquet_compression_type", thrift.I32, 12)
		l += bthrift.Binary.I32Length(int32(*p.ParquetCompressionType))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TResultFileSinkOptions) field13Length() int {
	l := 0
	if p.IsSetParquetDisableDictionary() {
		l += bthrift.Binary.FieldBeginLength("parquet_disable_dictionary", thrift.BOOL, 13)
		l += bthrift.Binary.BoolLength(*p.ParquetDisableDictionary)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TResultFileSinkOptions) field14Length() int {
	l := 0
	if p.IsSetParquetVersion() {
		l += bthrift.Binary.FieldBeginLength("parquet_version", thrift.I32, 14)
		l += bthrift.Binary.I32Length(int32(*p.ParquetVersion))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TResultFileSinkOptions) field15Length() int {
	l := 0
	if p.IsSetOrcSchema() {
		l += bthrift.Binary.FieldBeginLength("orc_schema", thrift.STRING, 15)
		l += bthrift.Binary.StringLengthNocopy(*p.OrcSchema)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TResultFileSinkOptions) field16Length() int {
	l := 0
	if p.IsSetDeleteExistingFiles() {
		l += bthrift.Binary.FieldBeginLength("delete_existing_files", thrift.BOOL, 16)
		l += bthrift.Binary.BoolLength(*p.DeleteExistingFiles)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TResultFileSinkOptions) field17Length() int {
	l := 0
	if p.IsSetFileSuffix() {
		l += bthrift.Binary.FieldBeginLength("file_suffix", thrift.STRING, 17)
		l += bthrift.Binary.StringLengthNocopy(*p.FileSuffix)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TResultFileSinkOptions) field18Length() int {
	l := 0
	if p.IsSetWithBom() {
		l += bthrift.Binary.FieldBeginLength("with_bom", thrift.BOOL, 18)
		l += bthrift.Binary.BoolLength(*p.WithBom)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TResultFileSinkOptions) field19Length() int {
	l := 0
	if p.IsSetOrcCompressionType() {
		l += bthrift.Binary.FieldBeginLength("orc_compression_type", thrift.I32, 19)
		l += bthrift.Binary.I32Length(int32(*p.OrcCompressionType))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TMemoryScratchSink) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
		offset += l
		if err != nil {
			goto SkipFieldError
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

// for compatibility
func (p *TMemoryScratchSink) FastWrite(buf []byte) int {
	return 0
}

func (p *TMemoryScratchSink) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TMemoryScratchSink")
	if p != nil {
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TMemoryScratchSink) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TMemoryScratchSink")
	if p != nil {
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TPlanFragmentDestination) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetFragmentInstanceId bool = false
	var issetServer bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetFragmentInstanceId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetServer = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetFragmentInstanceId {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetServer {
		fieldId = 2
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TPlanFragmentDestination[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TPlanFragmentDestination[fieldId]))
}

func (p *TPlanFragmentDestination) FastReadField1(buf []byte) (int, error) {
	offset := 0

	tmp := types.NewTUniqueId()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.FragmentInstanceId = tmp
	return offset, nil
}

func (p *TPlanFragmentDestination) FastReadField2(buf []byte) (int, error) {
	offset := 0

	tmp := types.NewTNetworkAddress()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.Server = tmp
	return offset, nil
}

func (p *TPlanFragmentDestination) FastReadField3(buf []byte) (int, error) {
	offset := 0

	tmp := types.NewTNetworkAddress()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.BrpcServer = tmp
	return offset, nil
}

// for compatibility
func (p *TPlanFragmentDestination) FastWrite(buf []byte) int {
	return 0
}

func (p *TPlanFragmentDestination) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TPlanFragmentDestination")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TPlanFragmentDestination) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TPlanFragmentDestination")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TPlanFragmentDestination) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "fragment_instance_id", thrift.STRUCT, 1)
	offset += p.FragmentInstanceId.FastWriteNocopy(buf[offset:], binaryWriter)
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TPlanFragmentDestination) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "server", thrift.STRUCT, 2)
	offset += p.Server.FastWriteNocopy(buf[offset:], binaryWriter)
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TPlanFragmentDestination) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetBrpcServer() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "brpc_server", thrift.STRUCT, 3)
		offset += p.BrpcServer.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanFragmentDestination) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("fragment_instance_id", thrift.STRUCT, 1)
	l += p.FragmentInstanceId.BLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TPlanFragmentDestination) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("server", thrift.STRUCT, 2)
	l += p.Server.BLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TPlanFragmentDestination) field3Length() int {
	l := 0
	if p.IsSetBrpcServer() {
		l += bthrift.Binary.FieldBeginLength("brpc_server", thrift.STRUCT, 3)
		l += p.BrpcServer.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TDataStreamSink) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetDestNodeId bool = false
	var issetOutputPartition bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetDestNodeId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetOutputPartition = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField9(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 11:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField11(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 12:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField12(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetDestNodeId {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetOutputPartition {
		fieldId = 2
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TDataStreamSink[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TDataStreamSink[fieldId]))
}

func (p *TDataStreamSink) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.DestNodeId = v

	}
	return offset, nil
}

func (p *TDataStreamSink) FastReadField2(buf []byte) (int, error) {
	offset := 0

	tmp := partitions.NewTDataPartition()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.OutputPartition = tmp
	return offset, nil
}

func (p *TDataStreamSink) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.IgnoreNotFound = &v

	}
	return offset, nil
}

func (p *TDataStreamSink) FastReadField4(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.OutputExprs = make([]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_elem := exprs.NewTExpr()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.OutputExprs = append(p.OutputExprs, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TDataStreamSink) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.OutputTupleId = &v

	}
	return offset, nil
}

func (p *TDataStreamSink) FastReadField6(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Conjuncts = make([]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_elem := exprs.NewTExpr()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.Conjuncts = append(p.Conjuncts, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TDataStreamSink) FastReadField7(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.RuntimeFilters = make([]*plannodes.TRuntimeFilterDesc, 0, size)
	for i := 0; i < size; i++ {
		_elem := plannodes.NewTRuntimeFilterDesc()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.RuntimeFilters = append(p.RuntimeFilters, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TDataStreamSink) FastReadField8(buf []byte) (int, error) {
	offset := 0

	tmp := descriptors.NewTOlapTableSchemaParam()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.TabletSinkSchema = tmp
	return offset, nil
}

func (p *TDataStreamSink) FastReadField9(buf []byte) (int, error) {
	offset := 0

	tmp := descriptors.NewTOlapTablePartitionParam()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.TabletSinkPartition = tmp
	return offset, nil
}

func (p *TDataStreamSink) FastReadField10(buf []byte) (int, error) {
	offset := 0

	tmp := descriptors.NewTOlapTableLocationParam()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.TabletSinkLocation = tmp
	return offset, nil
}

func (p *TDataStreamSink) FastReadField11(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.TabletSinkTxnId = &v

	}
	return offset, nil
}

func (p *TDataStreamSink) FastReadField12(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.TabletSinkTupleId = &v

	}
	return offset, nil
}

// for compatibility
func (p *TDataStreamSink) FastWrite(buf []byte) int {
	return 0
}

func (p *TDataStreamSink) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TDataStreamSink")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField11(buf[offset:], binaryWriter)
		offset += p.fastWriteField12(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
		offset += p.fastWriteField9(buf[offset:], binaryWriter)
		offset += p.fastWriteField10(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TDataStreamSink) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TDataStreamSink")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field9Length()
		l += p.field10Length()
		l += p.field11Length()
		l += p.field12Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TDataStreamSink) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "dest_node_id", thrift.I32, 1)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.DestNodeId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TDataStreamSink) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "output_partition", thrift.STRUCT, 2)
	offset += p.OutputPartition.FastWriteNocopy(buf[offset:], binaryWriter)
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TDataStreamSink) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIgnoreNotFound() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "ignore_not_found", thrift.BOOL, 3)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.IgnoreNotFound)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TDataStreamSink) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetOutputExprs() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "output_exprs", thrift.LIST, 4)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.OutputExprs {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TDataStreamSink) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetOutputTupleId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "output_tuple_id", thrift.I32, 5)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.OutputTupleId)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TDataStreamSink) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetConjuncts() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "conjuncts", thrift.LIST, 6)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.Conjuncts {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TDataStreamSink) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetRuntimeFilters() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "runtime_filters", thrift.LIST, 7)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.RuntimeFilters {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TDataStreamSink) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTabletSinkSchema() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tablet_sink_schema", thrift.STRUCT, 8)
		offset += p.TabletSinkSchema.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TDataStreamSink) fastWriteField9(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTabletSinkPartition() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tablet_sink_partition", thrift.STRUCT, 9)
		offset += p.TabletSinkPartition.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TDataStreamSink) fastWriteField10(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTabletSinkLocation() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tablet_sink_location", thrift.STRUCT, 10)
		offset += p.TabletSinkLocation.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TDataStreamSink) fastWriteField11(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTabletSinkTxnId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tablet_sink_txn_id", thrift.I64, 11)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.TabletSinkTxnId)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TDataStreamSink) fastWriteField12(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTabletSinkTupleId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tablet_sink_tuple_id", thrift.I32, 12)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.TabletSinkTupleId)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TDataStreamSink) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("dest_node_id", thrift.I32, 1)
	l += bthrift.Binary.I32Length(p.DestNodeId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TDataStreamSink) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("output_partition", thrift.STRUCT, 2)
	l += p.OutputPartition.BLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TDataStreamSink) field3Length() int {
	l := 0
	if p.IsSetIgnoreNotFound() {
		l += bthrift.Binary.FieldBeginLength("ignore_not_found", thrift.BOOL, 3)
		l += bthrift.Binary.BoolLength(*p.IgnoreNotFound)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TDataStreamSink) field4Length() int {
	l := 0
	if p.IsSetOutputExprs() {
		l += bthrift.Binary.FieldBeginLength("output_exprs", thrift.LIST, 4)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.OutputExprs))
		for _, v := range p.OutputExprs {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TDataStreamSink) field5Length() int {
	l := 0
	if p.IsSetOutputTupleId() {
		l += bthrift.Binary.FieldBeginLength("output_tuple_id", thrift.I32, 5)
		l += bthrift.Binary.I32Length(*p.OutputTupleId)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TDataStreamSink) field6Length() int {
	l := 0
	if p.IsSetConjuncts() {
		l += bthrift.Binary.FieldBeginLength("conjuncts", thrift.LIST, 6)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.Conjuncts))
		for _, v := range p.Conjuncts {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TDataStreamSink) field7Length() int {
	l := 0
	if p.IsSetRuntimeFilters() {
		l += bthrift.Binary.FieldBeginLength("runtime_filters", thrift.LIST, 7)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.RuntimeFilters))
		for _, v := range p.RuntimeFilters {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TDataStreamSink) field8Length() int {
	l := 0
	if p.IsSetTabletSinkSchema() {
		l += bthrift.Binary.FieldBeginLength("tablet_sink_schema", thrift.STRUCT, 8)
		l += p.TabletSinkSchema.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TDataStreamSink) field9Length() int {
	l := 0
	if p.IsSetTabletSinkPartition() {
		l += bthrift.Binary.FieldBeginLength("tablet_sink_partition", thrift.STRUCT, 9)
		l += p.TabletSinkPartition.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TDataStreamSink) field10Length() int {
	l := 0
	if p.IsSetTabletSinkLocation() {
		l += bthrift.Binary.FieldBeginLength("tablet_sink_location", thrift.STRUCT, 10)
		l += p.TabletSinkLocation.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TDataStreamSink) field11Length() int {
	l := 0
	if p.IsSetTabletSinkTxnId() {
		l += bthrift.Binary.FieldBeginLength("tablet_sink_txn_id", thrift.I64, 11)
		l += bthrift.Binary.I64Length(*p.TabletSinkTxnId)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TDataStreamSink) field12Length() int {
	l := 0
	if p.IsSetTabletSinkTupleId() {
		l += bthrift.Binary.FieldBeginLength("tablet_sink_tuple_id", thrift.I32, 12)
		l += bthrift.Binary.I32Length(*p.TabletSinkTupleId)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TMultiCastDataStreamSink) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TMultiCastDataStreamSink[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TMultiCastDataStreamSink) FastReadField1(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Sinks = make([]*TDataStreamSink, 0, size)
	for i := 0; i < size; i++ {
		_elem := NewTDataStreamSink()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.Sinks = append(p.Sinks, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TMultiCastDataStreamSink) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Destinations = make([][]*TPlanFragmentDestination, 0, size)
	for i := 0; i < size; i++ {
		_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
		offset += l
		if err != nil {
			return offset, err
		}
		_elem := make([]*TPlanFragmentDestination, 0, size)
		for i := 0; i < size; i++ {
			_elem1 := NewTPlanFragmentDestination()
			if l, err := _elem1.FastRead(buf[offset:]); err != nil {
				return offset, err
			} else {
				offset += l
			}

			_elem = append(_elem, _elem1)
		}
		if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.Destinations = append(p.Destinations, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

// for compatibility
func (p *TMultiCastDataStreamSink) FastWrite(buf []byte) int {
	return 0
}

func (p *TMultiCastDataStreamSink) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TMultiCastDataStreamSink")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TMultiCastDataStreamSink) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TMultiCastDataStreamSink")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TMultiCastDataStreamSink) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSinks() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "sinks", thrift.LIST, 1)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.Sinks {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TMultiCastDataStreamSink) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDestinations() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "destinations", thrift.LIST, 2)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.LIST, 0)
		var length int
		for _, v := range p.Destinations {
			length++
			listBeginOffset := offset
			offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
			var length int
			for _, v := range v {
				length++
				offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
			}
			bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
			offset += bthrift.Binary.WriteListEnd(buf[offset:])
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.LIST, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TMultiCastDataStreamSink) field1Length() int {
	l := 0
	if p.IsSetSinks() {
		l += bthrift.Binary.FieldBeginLength("sinks", thrift.LIST, 1)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.Sinks))
		for _, v := range p.Sinks {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TMultiCastDataStreamSink) field2Length() int {
	l := 0
	if p.IsSetDestinations() {
		l += bthrift.Binary.FieldBeginLength("destinations", thrift.LIST, 2)
		l += bthrift.Binary.ListBeginLength(thrift.LIST, len(p.Destinations))
		for _, v := range p.Destinations {
			l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(v))
			for _, v := range v {
				l += v.BLength()
			}
			l += bthrift.Binary.ListEndLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFetchOption) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TFetchOption[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TFetchOption) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.UseTwoPhaseFetch = &v

	}
	return offset, nil
}

func (p *TFetchOption) FastReadField2(buf []byte) (int, error) {
	offset := 0

	tmp := descriptors.NewTPaloNodesInfo()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.NodesInfo = tmp
	return offset, nil
}

func (p *TFetchOption) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.FetchRowStore = &v

	}
	return offset, nil
}

func (p *TFetchOption) FastReadField4(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.ColumnDesc = make([]*descriptors.TColumn, 0, size)
	for i := 0; i < size; i++ {
		_elem := descriptors.NewTColumn()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.ColumnDesc = append(p.ColumnDesc, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

// for compatibility
func (p *TFetchOption) FastWrite(buf []byte) int {
	return 0
}

func (p *TFetchOption) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TFetchOption")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TFetchOption) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TFetchOption")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TFetchOption) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetUseTwoPhaseFetch() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "use_two_phase_fetch", thrift.BOOL, 1)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.UseTwoPhaseFetch)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFetchOption) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetNodesInfo() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "nodes_info", thrift.STRUCT, 2)
		offset += p.NodesInfo.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFetchOption) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFetchRowStore() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "fetch_row_store", thrift.BOOL, 3)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.FetchRowStore)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFetchOption) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetColumnDesc() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "column_desc", thrift.LIST, 4)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.ColumnDesc {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFetchOption) field1Length() int {
	l := 0
	if p.IsSetUseTwoPhaseFetch() {
		l += bthrift.Binary.FieldBeginLength("use_two_phase_fetch", thrift.BOOL, 1)
		l += bthrift.Binary.BoolLength(*p.UseTwoPhaseFetch)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFetchOption) field2Length() int {
	l := 0
	if p.IsSetNodesInfo() {
		l += bthrift.Binary.FieldBeginLength("nodes_info", thrift.STRUCT, 2)
		l += p.NodesInfo.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFetchOption) field3Length() int {
	l := 0
	if p.IsSetFetchRowStore() {
		l += bthrift.Binary.FieldBeginLength("fetch_row_store", thrift.BOOL, 3)
		l += bthrift.Binary.BoolLength(*p.FetchRowStore)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFetchOption) field4Length() int {
	l := 0
	if p.IsSetColumnDesc() {
		l += bthrift.Binary.FieldBeginLength("column_desc", thrift.LIST, 4)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.ColumnDesc))
		for _, v := range p.ColumnDesc {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TResultSink) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TResultSink[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TResultSink) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := TResultSinkType(v)
		p.Type = &tmp

	}
	return offset, nil
}

func (p *TResultSink) FastReadField2(buf []byte) (int, error) {
	offset := 0

	tmp := NewTResultFileSinkOptions()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.FileOptions = tmp
	return offset, nil
}

func (p *TResultSink) FastReadField3(buf []byte) (int, error) {
	offset := 0

	tmp := NewTFetchOption()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.FetchOption = tmp
	return offset, nil
}

// for compatibility
func (p *TResultSink) FastWrite(buf []byte) int {
	return 0
}

func (p *TResultSink) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TResultSink")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TResultSink) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TResultSink")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TResultSink) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "type", thrift.I32, 1)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.Type))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TResultSink) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFileOptions() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "file_options", thrift.STRUCT, 2)
		offset += p.FileOptions.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TResultSink) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFetchOption() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "fetch_option", thrift.STRUCT, 3)
		offset += p.FetchOption.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TResultSink) field1Length() int {
	l := 0
	if p.IsSetType() {
		l += bthrift.Binary.FieldBeginLength("type", thrift.I32, 1)
		l += bthrift.Binary.I32Length(int32(*p.Type))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TResultSink) field2Length() int {
	l := 0
	if p.IsSetFileOptions() {
		l += bthrift.Binary.FieldBeginLength("file_options", thrift.STRUCT, 2)
		l += p.FileOptions.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TResultSink) field3Length() int {
	l := 0
	if p.IsSetFetchOption() {
		l += bthrift.Binary.FieldBeginLength("fetch_option", thrift.STRUCT, 3)
		l += p.FetchOption.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TResultFileSink) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TResultFileSink[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TResultFileSink) FastReadField1(buf []byte) (int, error) {
	offset := 0

	tmp := NewTResultFileSinkOptions()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.FileOptions = tmp
	return offset, nil
}

func (p *TResultFileSink) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := types.TStorageBackendType(v)
		p.StorageBackendType = &tmp

	}
	return offset, nil
}

func (p *TResultFileSink) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.DestNodeId = &v

	}
	return offset, nil
}

func (p *TResultFileSink) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.OutputTupleId = &v

	}
	return offset, nil
}

func (p *TResultFileSink) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Header = &v

	}
	return offset, nil
}

func (p *TResultFileSink) FastReadField6(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.HeaderType = &v

	}
	return offset, nil
}

// for compatibility
func (p *TResultFileSink) FastWrite(buf []byte) int {
	return 0
}

func (p *TResultFileSink) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TResultFileSink")
	if p != nil {
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TResultFileSink) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TResultFileSink")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TResultFileSink) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFileOptions() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "file_options", thrift.STRUCT, 1)
		offset += p.FileOptions.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TResultFileSink) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetStorageBackendType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "storage_backend_type", thrift.I32, 2)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.StorageBackendType))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TResultFileSink) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDestNodeId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "dest_node_id", thrift.I32, 3)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.DestNodeId)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TResultFileSink) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetOutputTupleId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "output_tuple_id", thrift.I32, 4)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.OutputTupleId)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TResultFileSink) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetHeader() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "header", thrift.STRING, 5)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Header)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TResultFileSink) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetHeaderType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "header_type", thrift.STRING, 6)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.HeaderType)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TResultFileSink) field1Length() int {
	l := 0
	if p.IsSetFileOptions() {
		l += bthrift.Binary.FieldBeginLength("file_options", thrift.STRUCT, 1)
		l += p.FileOptions.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TResultFileSink) field2Length() int {
	l := 0
	if p.IsSetStorageBackendType() {
		l += bthrift.Binary.FieldBeginLength("storage_backend_type", thrift.I32, 2)
		l += bthrift.Binary.I32Length(int32(*p.StorageBackendType))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TResultFileSink) field3Length() int {
	l := 0
	if p.IsSetDestNodeId() {
		l += bthrift.Binary.FieldBeginLength("dest_node_id", thrift.I32, 3)
		l += bthrift.Binary.I32Length(*p.DestNodeId)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TResultFileSink) field4Length() int {
	l := 0
	if p.IsSetOutputTupleId() {
		l += bthrift.Binary.FieldBeginLength("output_tuple_id", thrift.I32, 4)
		l += bthrift.Binary.I32Length(*p.OutputTupleId)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TResultFileSink) field5Length() int {
	l := 0
	if p.IsSetHeader() {
		l += bthrift.Binary.FieldBeginLength("header", thrift.STRING, 5)
		l += bthrift.Binary.StringLengthNocopy(*p.Header)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TResultFileSink) field6Length() int {
	l := 0
	if p.IsSetHeaderType() {
		l += bthrift.Binary.FieldBeginLength("header_type", thrift.STRING, 6)
		l += bthrift.Binary.StringLengthNocopy(*p.HeaderType)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TMysqlTableSink) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetHost bool = false
	var issetPort bool = false
	var issetUser bool = false
	var issetPasswd bool = false
	var issetDb bool = false
	var issetTable bool = false
	var issetCharset bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetHost = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetPort = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetUser = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetPasswd = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetDb = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetTable = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetCharset = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetHost {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetPort {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetUser {
		fieldId = 3
		goto RequiredFieldNotSetError
	}

	if !issetPasswd {
		fieldId = 4
		goto RequiredFieldNotSetError
	}

	if !issetDb {
		fieldId = 5
		goto RequiredFieldNotSetError
	}

	if !issetTable {
		fieldId = 6
		goto RequiredFieldNotSetError
	}

	if !issetCharset {
		fieldId = 7
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TMysqlTableSink[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TMysqlTableSink[fieldId]))
}

func (p *TMysqlTableSink) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Host = v

	}
	return offset, nil
}

func (p *TMysqlTableSink) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Port = v

	}
	return offset, nil
}

func (p *TMysqlTableSink) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.User = v

	}
	return offset, nil
}

func (p *TMysqlTableSink) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Passwd = v

	}
	return offset, nil
}

func (p *TMysqlTableSink) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Db = v

	}
	return offset, nil
}

func (p *TMysqlTableSink) FastReadField6(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Table = v

	}
	return offset, nil
}

func (p *TMysqlTableSink) FastReadField7(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Charset = v

	}
	return offset, nil
}

// for compatibility
func (p *TMysqlTableSink) FastWrite(buf []byte) int {
	return 0
}

func (p *TMysqlTableSink) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TMysqlTableSink")
	if p != nil {
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TMysqlTableSink) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TMysqlTableSink")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TMysqlTableSink) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "host", thrift.STRING, 1)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.Host)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TMysqlTableSink) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "port", thrift.I32, 2)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.Port)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TMysqlTableSink) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "user", thrift.STRING, 3)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.User)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TMysqlTableSink) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "passwd", thrift.STRING, 4)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.Passwd)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TMysqlTableSink) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "db", thrift.STRING, 5)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.Db)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TMysqlTableSink) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "table", thrift.STRING, 6)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.Table)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TMysqlTableSink) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "charset", thrift.STRING, 7)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.Charset)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TMysqlTableSink) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("host", thrift.STRING, 1)
	l += bthrift.Binary.StringLengthNocopy(p.Host)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TMysqlTableSink) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("port", thrift.I32, 2)
	l += bthrift.Binary.I32Length(p.Port)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TMysqlTableSink) field3Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("user", thrift.STRING, 3)
	l += bthrift.Binary.StringLengthNocopy(p.User)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TMysqlTableSink) field4Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("passwd", thrift.STRING, 4)
	l += bthrift.Binary.StringLengthNocopy(p.Passwd)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TMysqlTableSink) field5Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("db", thrift.STRING, 5)
	l += bthrift.Binary.StringLengthNocopy(p.Db)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TMysqlTableSink) field6Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("table", thrift.STRING, 6)
	l += bthrift.Binary.StringLengthNocopy(p.Table)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TMysqlTableSink) field7Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("charset", thrift.STRING, 7)
	l += bthrift.Binary.StringLengthNocopy(p.Charset)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOdbcTableSink) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TOdbcTableSink[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TOdbcTableSink) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.ConnectString = &v

	}
	return offset, nil
}

func (p *TOdbcTableSink) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Table = &v

	}
	return offset, nil
}

func (p *TOdbcTableSink) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.UseTransaction = &v

	}
	return offset, nil
}

// for compatibility
func (p *TOdbcTableSink) FastWrite(buf []byte) int {
	return 0
}

func (p *TOdbcTableSink) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TOdbcTableSink")
	if p != nil {
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TOdbcTableSink) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TOdbcTableSink")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TOdbcTableSink) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetConnectString() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "connect_string", thrift.STRING, 1)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.ConnectString)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOdbcTableSink) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTable() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "table", thrift.STRING, 2)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Table)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOdbcTableSink) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetUseTransaction() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "use_transaction", thrift.BOOL, 3)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.UseTransaction)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOdbcTableSink) field1Length() int {
	l := 0
	if p.IsSetConnectString() {
		l += bthrift.Binary.FieldBeginLength("connect_string", thrift.STRING, 1)
		l += bthrift.Binary.StringLengthNocopy(*p.ConnectString)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOdbcTableSink) field2Length() int {
	l := 0
	if p.IsSetTable() {
		l += bthrift.Binary.FieldBeginLength("table", thrift.STRING, 2)
		l += bthrift.Binary.StringLengthNocopy(*p.Table)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOdbcTableSink) field3Length() int {
	l := 0
	if p.IsSetUseTransaction() {
		l += bthrift.Binary.FieldBeginLength("use_transaction", thrift.BOOL, 3)
		l += bthrift.Binary.BoolLength(*p.UseTransaction)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TJdbcTableSink) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TJdbcTableSink[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TJdbcTableSink) FastReadField1(buf []byte) (int, error) {
	offset := 0

	tmp := descriptors.NewTJdbcTable()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.JdbcTable = tmp
	return offset, nil
}

func (p *TJdbcTableSink) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.UseTransaction = &v

	}
	return offset, nil
}

func (p *TJdbcTableSink) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := types.TOdbcTableType(v)
		p.TableType = &tmp

	}
	return offset, nil
}

func (p *TJdbcTableSink) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.InsertSql = &v

	}
	return offset, nil
}

// for compatibility
func (p *TJdbcTableSink) FastWrite(buf []byte) int {
	return 0
}

func (p *TJdbcTableSink) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TJdbcTableSink")
	if p != nil {
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TJdbcTableSink) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TJdbcTableSink")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TJdbcTableSink) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetJdbcTable() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "jdbc_table", thrift.STRUCT, 1)
		offset += p.JdbcTable.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TJdbcTableSink) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetUseTransaction() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "use_transaction", thrift.BOOL, 2)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.UseTransaction)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TJdbcTableSink) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTableType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "table_type", thrift.I32, 3)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.TableType))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TJdbcTableSink) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetInsertSql() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "insert_sql", thrift.STRING, 4)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.InsertSql)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TJdbcTableSink) field1Length() int {
	l := 0
	if p.IsSetJdbcTable() {
		l += bthrift.Binary.FieldBeginLength("jdbc_table", thrift.STRUCT, 1)
		l += p.JdbcTable.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TJdbcTableSink) field2Length() int {
	l := 0
	if p.IsSetUseTransaction() {
		l += bthrift.Binary.FieldBeginLength("use_transaction", thrift.BOOL, 2)
		l += bthrift.Binary.BoolLength(*p.UseTransaction)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TJdbcTableSink) field3Length() int {
	l := 0
	if p.IsSetTableType() {
		l += bthrift.Binary.FieldBeginLength("table_type", thrift.I32, 3)
		l += bthrift.Binary.I32Length(int32(*p.TableType))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TJdbcTableSink) field4Length() int {
	l := 0
	if p.IsSetInsertSql() {
		l += bthrift.Binary.FieldBeginLength("insert_sql", thrift.STRING, 4)
		l += bthrift.Binary.StringLengthNocopy(*p.InsertSql)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TExportSink) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetFileType bool = false
	var issetExportPath bool = false
	var issetColumnSeparator bool = false
	var issetLineDelimiter bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetFileType = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetExportPath = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetColumnSeparator = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetLineDelimiter = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetFileType {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetExportPath {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetColumnSeparator {
		fieldId = 3
		goto RequiredFieldNotSetError
	}

	if !issetLineDelimiter {
		fieldId = 4
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TExportSink[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TExportSink[fieldId]))
}

func (p *TExportSink) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.FileType = types.TFileType(v)

	}
	return offset, nil
}

func (p *TExportSink) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.ExportPath = v

	}
	return offset, nil
}

func (p *TExportSink) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.ColumnSeparator = v

	}
	return offset, nil
}

func (p *TExportSink) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.LineDelimiter = v

	}
	return offset, nil
}

func (p *TExportSink) FastReadField5(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.BrokerAddresses = make([]*types.TNetworkAddress, 0, size)
	for i := 0; i < size; i++ {
		_elem := types.NewTNetworkAddress()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.BrokerAddresses = append(p.BrokerAddresses, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TExportSink) FastReadField6(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := bthrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Properties = make(map[string]string, size)
	for i := 0; i < size; i++ {
		var _key string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_key = v

		}

		var _val string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_val = v

		}

		p.Properties[_key] = _val
	}
	if l, err := bthrift.Binary.ReadMapEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TExportSink) FastReadField7(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Header = &v

	}
	return offset, nil
}

// for compatibility
func (p *TExportSink) FastWrite(buf []byte) int {
	return 0
}

func (p *TExportSink) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TExportSink")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TExportSink) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TExportSink")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TExportSink) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "file_type", thrift.I32, 1)
	offset += bthrift.Binary.WriteI32(buf[offset:], int32(p.FileType))

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TExportSink) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "export_path", thrift.STRING, 2)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.ExportPath)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TExportSink) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "column_separator", thrift.STRING, 3)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.ColumnSeparator)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TExportSink) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "line_delimiter", thrift.STRING, 4)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.LineDelimiter)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TExportSink) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetBrokerAddresses() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "broker_addresses", thrift.LIST, 5)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.BrokerAddresses {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TExportSink) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetProperties() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "properties", thrift.MAP, 6)
		mapBeginOffset := offset
		offset += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRING, 0)
		var length int
		for k, v := range p.Properties {
			length++

			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, k)

			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.STRING, thrift.STRING, length)
		offset += bthrift.Binary.WriteMapEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TExportSink) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetHeader() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "header", thrift.STRING, 7)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Header)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TExportSink) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("file_type", thrift.I32, 1)
	l += bthrift.Binary.I32Length(int32(p.FileType))

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TExportSink) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("export_path", thrift.STRING, 2)
	l += bthrift.Binary.StringLengthNocopy(p.ExportPath)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TExportSink) field3Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("column_separator", thrift.STRING, 3)
	l += bthrift.Binary.StringLengthNocopy(p.ColumnSeparator)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TExportSink) field4Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("line_delimiter", thrift.STRING, 4)
	l += bthrift.Binary.StringLengthNocopy(p.LineDelimiter)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TExportSink) field5Length() int {
	l := 0
	if p.IsSetBrokerAddresses() {
		l += bthrift.Binary.FieldBeginLength("broker_addresses", thrift.LIST, 5)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.BrokerAddresses))
		for _, v := range p.BrokerAddresses {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TExportSink) field6Length() int {
	l := 0
	if p.IsSetProperties() {
		l += bthrift.Binary.FieldBeginLength("properties", thrift.MAP, 6)
		l += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRING, len(p.Properties))
		for k, v := range p.Properties {

			l += bthrift.Binary.StringLengthNocopy(k)

			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.MapEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TExportSink) field7Length() int {
	l := 0
	if p.IsSetHeader() {
		l += bthrift.Binary.FieldBeginLength("header", thrift.STRING, 7)
		l += bthrift.Binary.StringLengthNocopy(*p.Header)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTableSink) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetLoadId bool = false
	var issetTxnId bool = false
	var issetDbId bool = false
	var issetTableId bool = false
	var issetTupleId bool = false
	var issetNumReplicas bool = false
	var issetNeedGenRollup bool = false
	var issetSchema bool = false
	var issetPartition bool = false
	var issetLocation bool = false
	var issetNodesInfo bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetLoadId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetTxnId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetDbId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetTableId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetTupleId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetNumReplicas = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetNeedGenRollup = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField9(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetSchema = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 11:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField11(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetPartition = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 12:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField12(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetLocation = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 13:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField13(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetNodesInfo = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 14:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField14(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 15:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField15(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 16:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField16(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 17:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField17(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 18:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField18(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 19:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField19(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 20:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField20(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 21:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField21(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 22:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField22(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 23:
			if fieldTypeId == thrift.DOUBLE {
				l, err = p.FastReadField23(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 24:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField24(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetLoadId {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetTxnId {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetDbId {
		fieldId = 3
		goto RequiredFieldNotSetError
	}

	if !issetTableId {
		fieldId = 4
		goto RequiredFieldNotSetError
	}

	if !issetTupleId {
		fieldId = 5
		goto RequiredFieldNotSetError
	}

	if !issetNumReplicas {
		fieldId = 6
		goto RequiredFieldNotSetError
	}

	if !issetNeedGenRollup {
		fieldId = 7
		goto RequiredFieldNotSetError
	}

	if !issetSchema {
		fieldId = 10
		goto RequiredFieldNotSetError
	}

	if !issetPartition {
		fieldId = 11
		goto RequiredFieldNotSetError
	}

	if !issetLocation {
		fieldId = 12
		goto RequiredFieldNotSetError
	}

	if !issetNodesInfo {
		fieldId = 13
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TOlapTableSink[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TOlapTableSink[fieldId]))
}

func (p *TOlapTableSink) FastReadField1(buf []byte) (int, error) {
	offset := 0

	tmp := types.NewTUniqueId()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.LoadId = tmp
	return offset, nil
}

func (p *TOlapTableSink) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.TxnId = v

	}
	return offset, nil
}

func (p *TOlapTableSink) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.DbId = v

	}
	return offset, nil
}

func (p *TOlapTableSink) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.TableId = v

	}
	return offset, nil
}

func (p *TOlapTableSink) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.TupleId = v

	}
	return offset, nil
}

func (p *TOlapTableSink) FastReadField6(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.NumReplicas = v

	}
	return offset, nil
}

func (p *TOlapTableSink) FastReadField7(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.NeedGenRollup = v

	}
	return offset, nil
}

func (p *TOlapTableSink) FastReadField8(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.DbName = &v

	}
	return offset, nil
}

func (p *TOlapTableSink) FastReadField9(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.TableName = &v

	}
	return offset, nil
}

func (p *TOlapTableSink) FastReadField10(buf []byte) (int, error) {
	offset := 0

	tmp := descriptors.NewTOlapTableSchemaParam()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.Schema = tmp
	return offset, nil
}

func (p *TOlapTableSink) FastReadField11(buf []byte) (int, error) {
	offset := 0

	tmp := descriptors.NewTOlapTablePartitionParam()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.Partition = tmp
	return offset, nil
}

func (p *TOlapTableSink) FastReadField12(buf []byte) (int, error) {
	offset := 0

	tmp := descriptors.NewTOlapTableLocationParam()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.Location = tmp
	return offset, nil
}

func (p *TOlapTableSink) FastReadField13(buf []byte) (int, error) {
	offset := 0

	tmp := descriptors.NewTPaloNodesInfo()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.NodesInfo = tmp
	return offset, nil
}

func (p *TOlapTableSink) FastReadField14(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.LoadChannelTimeoutS = &v

	}
	return offset, nil
}

func (p *TOlapTableSink) FastReadField15(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.SendBatchParallelism = &v

	}
	return offset, nil
}

func (p *TOlapTableSink) FastReadField16(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.LoadToSingleTablet = &v

	}
	return offset, nil
}

func (p *TOlapTableSink) FastReadField17(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.WriteSingleReplica = &v

	}
	return offset, nil
}

func (p *TOlapTableSink) FastReadField18(buf []byte) (int, error) {
	offset := 0

	tmp := descriptors.NewTOlapTableLocationParam()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.SlaveLocation = tmp
	return offset, nil
}

func (p *TOlapTableSink) FastReadField19(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.TxnTimeoutS = &v

	}
	return offset, nil
}

func (p *TOlapTableSink) FastReadField20(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.WriteFileCache = &v

	}
	return offset, nil
}

func (p *TOlapTableSink) FastReadField21(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.BaseSchemaVersion = &v

	}
	return offset, nil
}

func (p *TOlapTableSink) FastReadField22(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := TGroupCommitMode(v)
		p.GroupCommitMode = &tmp

	}
	return offset, nil
}

func (p *TOlapTableSink) FastReadField23(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadDouble(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.MaxFilterRatio = &v

	}
	return offset, nil
}

func (p *TOlapTableSink) FastReadField24(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.StorageVaultId = &v

	}
	return offset, nil
}

// for compatibility
func (p *TOlapTableSink) FastWrite(buf []byte) int {
	return 0
}

func (p *TOlapTableSink) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TOlapTableSink")
	if p != nil {
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField14(buf[offset:], binaryWriter)
		offset += p.fastWriteField15(buf[offset:], binaryWriter)
		offset += p.fastWriteField16(buf[offset:], binaryWriter)
		offset += p.fastWriteField17(buf[offset:], binaryWriter)
		offset += p.fastWriteField19(buf[offset:], binaryWriter)
		offset += p.fastWriteField20(buf[offset:], binaryWriter)
		offset += p.fastWriteField21(buf[offset:], binaryWriter)
		offset += p.fastWriteField23(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
		offset += p.fastWriteField9(buf[offset:], binaryWriter)
		offset += p.fastWriteField10(buf[offset:], binaryWriter)
		offset += p.fastWriteField11(buf[offset:], binaryWriter)
		offset += p.fastWriteField12(buf[offset:], binaryWriter)
		offset += p.fastWriteField13(buf[offset:], binaryWriter)
		offset += p.fastWriteField18(buf[offset:], binaryWriter)
		offset += p.fastWriteField22(buf[offset:], binaryWriter)
		offset += p.fastWriteField24(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TOlapTableSink) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TOlapTableSink")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field9Length()
		l += p.field10Length()
		l += p.field11Length()
		l += p.field12Length()
		l += p.field13Length()
		l += p.field14Length()
		l += p.field15Length()
		l += p.field16Length()
		l += p.field17Length()
		l += p.field18Length()
		l += p.field19Length()
		l += p.field20Length()
		l += p.field21Length()
		l += p.field22Length()
		l += p.field23Length()
		l += p.field24Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TOlapTableSink) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "load_id", thrift.STRUCT, 1)
	offset += p.LoadId.FastWriteNocopy(buf[offset:], binaryWriter)
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapTableSink) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "txn_id", thrift.I64, 2)
	offset += bthrift.Binary.WriteI64(buf[offset:], p.TxnId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapTableSink) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "db_id", thrift.I64, 3)
	offset += bthrift.Binary.WriteI64(buf[offset:], p.DbId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapTableSink) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "table_id", thrift.I64, 4)
	offset += bthrift.Binary.WriteI64(buf[offset:], p.TableId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapTableSink) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tuple_id", thrift.I32, 5)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.TupleId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapTableSink) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "num_replicas", thrift.I32, 6)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.NumReplicas)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapTableSink) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "need_gen_rollup", thrift.BOOL, 7)
	offset += bthrift.Binary.WriteBool(buf[offset:], p.NeedGenRollup)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapTableSink) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDbName() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "db_name", thrift.STRING, 8)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.DbName)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTableSink) fastWriteField9(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTableName() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "table_name", thrift.STRING, 9)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.TableName)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTableSink) fastWriteField10(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "schema", thrift.STRUCT, 10)
	offset += p.Schema.FastWriteNocopy(buf[offset:], binaryWriter)
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapTableSink) fastWriteField11(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "partition", thrift.STRUCT, 11)
	offset += p.Partition.FastWriteNocopy(buf[offset:], binaryWriter)
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapTableSink) fastWriteField12(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "location", thrift.STRUCT, 12)
	offset += p.Location.FastWriteNocopy(buf[offset:], binaryWriter)
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapTableSink) fastWriteField13(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "nodes_info", thrift.STRUCT, 13)
	offset += p.NodesInfo.FastWriteNocopy(buf[offset:], binaryWriter)
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapTableSink) fastWriteField14(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetLoadChannelTimeoutS() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "load_channel_timeout_s", thrift.I64, 14)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.LoadChannelTimeoutS)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTableSink) fastWriteField15(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSendBatchParallelism() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "send_batch_parallelism", thrift.I32, 15)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.SendBatchParallelism)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTableSink) fastWriteField16(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetLoadToSingleTablet() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "load_to_single_tablet", thrift.BOOL, 16)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.LoadToSingleTablet)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTableSink) fastWriteField17(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetWriteSingleReplica() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "write_single_replica", thrift.BOOL, 17)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.WriteSingleReplica)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTableSink) fastWriteField18(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSlaveLocation() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "slave_location", thrift.STRUCT, 18)
		offset += p.SlaveLocation.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTableSink) fastWriteField19(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTxnTimeoutS() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "txn_timeout_s", thrift.I64, 19)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.TxnTimeoutS)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTableSink) fastWriteField20(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetWriteFileCache() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "write_file_cache", thrift.BOOL, 20)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.WriteFileCache)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTableSink) fastWriteField21(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetBaseSchemaVersion() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "base_schema_version", thrift.I64, 21)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.BaseSchemaVersion)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTableSink) fastWriteField22(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetGroupCommitMode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "group_commit_mode", thrift.I32, 22)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.GroupCommitMode))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTableSink) fastWriteField23(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetMaxFilterRatio() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "max_filter_ratio", thrift.DOUBLE, 23)
		offset += bthrift.Binary.WriteDouble(buf[offset:], *p.MaxFilterRatio)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTableSink) fastWriteField24(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetStorageVaultId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "storage_vault_id", thrift.STRING, 24)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.StorageVaultId)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTableSink) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("load_id", thrift.STRUCT, 1)
	l += p.LoadId.BLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapTableSink) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("txn_id", thrift.I64, 2)
	l += bthrift.Binary.I64Length(p.TxnId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapTableSink) field3Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("db_id", thrift.I64, 3)
	l += bthrift.Binary.I64Length(p.DbId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapTableSink) field4Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("table_id", thrift.I64, 4)
	l += bthrift.Binary.I64Length(p.TableId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapTableSink) field5Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("tuple_id", thrift.I32, 5)
	l += bthrift.Binary.I32Length(p.TupleId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapTableSink) field6Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("num_replicas", thrift.I32, 6)
	l += bthrift.Binary.I32Length(p.NumReplicas)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapTableSink) field7Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("need_gen_rollup", thrift.BOOL, 7)
	l += bthrift.Binary.BoolLength(p.NeedGenRollup)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapTableSink) field8Length() int {
	l := 0
	if p.IsSetDbName() {
		l += bthrift.Binary.FieldBeginLength("db_name", thrift.STRING, 8)
		l += bthrift.Binary.StringLengthNocopy(*p.DbName)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTableSink) field9Length() int {
	l := 0
	if p.IsSetTableName() {
		l += bthrift.Binary.FieldBeginLength("table_name", thrift.STRING, 9)
		l += bthrift.Binary.StringLengthNocopy(*p.TableName)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTableSink) field10Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("schema", thrift.STRUCT, 10)
	l += p.Schema.BLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapTableSink) field11Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("partition", thrift.STRUCT, 11)
	l += p.Partition.BLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapTableSink) field12Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("location", thrift.STRUCT, 12)
	l += p.Location.BLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapTableSink) field13Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("nodes_info", thrift.STRUCT, 13)
	l += p.NodesInfo.BLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapTableSink) field14Length() int {
	l := 0
	if p.IsSetLoadChannelTimeoutS() {
		l += bthrift.Binary.FieldBeginLength("load_channel_timeout_s", thrift.I64, 14)
		l += bthrift.Binary.I64Length(*p.LoadChannelTimeoutS)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTableSink) field15Length() int {
	l := 0
	if p.IsSetSendBatchParallelism() {
		l += bthrift.Binary.FieldBeginLength("send_batch_parallelism", thrift.I32, 15)
		l += bthrift.Binary.I32Length(*p.SendBatchParallelism)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTableSink) field16Length() int {
	l := 0
	if p.IsSetLoadToSingleTablet() {
		l += bthrift.Binary.FieldBeginLength("load_to_single_tablet", thrift.BOOL, 16)
		l += bthrift.Binary.BoolLength(*p.LoadToSingleTablet)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTableSink) field17Length() int {
	l := 0
	if p.IsSetWriteSingleReplica() {
		l += bthrift.Binary.FieldBeginLength("write_single_replica", thrift.BOOL, 17)
		l += bthrift.Binary.BoolLength(*p.WriteSingleReplica)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTableSink) field18Length() int {
	l := 0
	if p.IsSetSlaveLocation() {
		l += bthrift.Binary.FieldBeginLength("slave_location", thrift.STRUCT, 18)
		l += p.SlaveLocation.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTableSink) field19Length() int {
	l := 0
	if p.IsSetTxnTimeoutS() {
		l += bthrift.Binary.FieldBeginLength("txn_timeout_s", thrift.I64, 19)
		l += bthrift.Binary.I64Length(*p.TxnTimeoutS)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTableSink) field20Length() int {
	l := 0
	if p.IsSetWriteFileCache() {
		l += bthrift.Binary.FieldBeginLength("write_file_cache", thrift.BOOL, 20)
		l += bthrift.Binary.BoolLength(*p.WriteFileCache)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTableSink) field21Length() int {
	l := 0
	if p.IsSetBaseSchemaVersion() {
		l += bthrift.Binary.FieldBeginLength("base_schema_version", thrift.I64, 21)
		l += bthrift.Binary.I64Length(*p.BaseSchemaVersion)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTableSink) field22Length() int {
	l := 0
	if p.IsSetGroupCommitMode() {
		l += bthrift.Binary.FieldBeginLength("group_commit_mode", thrift.I32, 22)
		l += bthrift.Binary.I32Length(int32(*p.GroupCommitMode))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTableSink) field23Length() int {
	l := 0
	if p.IsSetMaxFilterRatio() {
		l += bthrift.Binary.FieldBeginLength("max_filter_ratio", thrift.DOUBLE, 23)
		l += bthrift.Binary.DoubleLength(*p.MaxFilterRatio)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTableSink) field24Length() int {
	l := 0
	if p.IsSetStorageVaultId() {
		l += bthrift.Binary.FieldBeginLength("storage_vault_id", thrift.STRING, 24)
		l += bthrift.Binary.StringLengthNocopy(*p.StorageVaultId)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THiveLocationParams) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_THiveLocationParams[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *THiveLocationParams) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.WritePath = &v

	}
	return offset, nil
}

func (p *THiveLocationParams) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.TargetPath = &v

	}
	return offset, nil
}

func (p *THiveLocationParams) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := types.TFileType(v)
		p.FileType = &tmp

	}
	return offset, nil
}

func (p *THiveLocationParams) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.OriginalWritePath = &v

	}
	return offset, nil
}

// for compatibility
func (p *THiveLocationParams) FastWrite(buf []byte) int {
	return 0
}

func (p *THiveLocationParams) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "THiveLocationParams")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *THiveLocationParams) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("THiveLocationParams")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *THiveLocationParams) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetWritePath() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "write_path", thrift.STRING, 1)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.WritePath)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THiveLocationParams) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTargetPath() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "target_path", thrift.STRING, 2)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.TargetPath)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THiveLocationParams) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFileType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "file_type", thrift.I32, 3)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.FileType))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THiveLocationParams) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetOriginalWritePath() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "original_write_path", thrift.STRING, 4)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.OriginalWritePath)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THiveLocationParams) field1Length() int {
	l := 0
	if p.IsSetWritePath() {
		l += bthrift.Binary.FieldBeginLength("write_path", thrift.STRING, 1)
		l += bthrift.Binary.StringLengthNocopy(*p.WritePath)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THiveLocationParams) field2Length() int {
	l := 0
	if p.IsSetTargetPath() {
		l += bthrift.Binary.FieldBeginLength("target_path", thrift.STRING, 2)
		l += bthrift.Binary.StringLengthNocopy(*p.TargetPath)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THiveLocationParams) field3Length() int {
	l := 0
	if p.IsSetFileType() {
		l += bthrift.Binary.FieldBeginLength("file_type", thrift.I32, 3)
		l += bthrift.Binary.I32Length(int32(*p.FileType))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THiveLocationParams) field4Length() int {
	l := 0
	if p.IsSetOriginalWritePath() {
		l += bthrift.Binary.FieldBeginLength("original_write_path", thrift.STRING, 4)
		l += bthrift.Binary.StringLengthNocopy(*p.OriginalWritePath)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TSortedColumn) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TSortedColumn[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TSortedColumn) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.SortColumnName = &v

	}
	return offset, nil
}

func (p *TSortedColumn) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Order = &v

	}
	return offset, nil
}

// for compatibility
func (p *TSortedColumn) FastWrite(buf []byte) int {
	return 0
}

func (p *TSortedColumn) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TSortedColumn")
	if p != nil {
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TSortedColumn) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TSortedColumn")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TSortedColumn) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSortColumnName() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "sort_column_name", thrift.STRING, 1)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.SortColumnName)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TSortedColumn) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetOrder() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "order", thrift.I32, 2)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.Order)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TSortedColumn) field1Length() int {
	l := 0
	if p.IsSetSortColumnName() {
		l += bthrift.Binary.FieldBeginLength("sort_column_name", thrift.STRING, 1)
		l += bthrift.Binary.StringLengthNocopy(*p.SortColumnName)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TSortedColumn) field2Length() int {
	l := 0
	if p.IsSetOrder() {
		l += bthrift.Binary.FieldBeginLength("order", thrift.I32, 2)
		l += bthrift.Binary.I32Length(*p.Order)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TBucketingMode) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TBucketingMode[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TBucketingMode) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.BucketVersion = &v

	}
	return offset, nil
}

// for compatibility
func (p *TBucketingMode) FastWrite(buf []byte) int {
	return 0
}

func (p *TBucketingMode) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TBucketingMode")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TBucketingMode) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TBucketingMode")
	if p != nil {
		l += p.field1Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TBucketingMode) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetBucketVersion() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "bucket_version", thrift.I32, 1)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.BucketVersion)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TBucketingMode) field1Length() int {
	l := 0
	if p.IsSetBucketVersion() {
		l += bthrift.Binary.FieldBeginLength("bucket_version", thrift.I32, 1)
		l += bthrift.Binary.I32Length(*p.BucketVersion)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THiveBucket) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_THiveBucket[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *THiveBucket) FastReadField1(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.BucketedBy = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.BucketedBy = append(p.BucketedBy, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *THiveBucket) FastReadField2(buf []byte) (int, error) {
	offset := 0

	tmp := NewTBucketingMode()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.BucketMode = tmp
	return offset, nil
}

func (p *THiveBucket) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.BucketCount = &v

	}
	return offset, nil
}

func (p *THiveBucket) FastReadField4(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.SortedBy = make([]*TSortedColumn, 0, size)
	for i := 0; i < size; i++ {
		_elem := NewTSortedColumn()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.SortedBy = append(p.SortedBy, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

// for compatibility
func (p *THiveBucket) FastWrite(buf []byte) int {
	return 0
}

func (p *THiveBucket) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "THiveBucket")
	if p != nil {
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *THiveBucket) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("THiveBucket")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *THiveBucket) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetBucketedBy() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "bucketed_by", thrift.LIST, 1)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRING, 0)
		var length int
		for _, v := range p.BucketedBy {
			length++
			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRING, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THiveBucket) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetBucketMode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "bucket_mode", thrift.STRUCT, 2)
		offset += p.BucketMode.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THiveBucket) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetBucketCount() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "bucket_count", thrift.I32, 3)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.BucketCount)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THiveBucket) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSortedBy() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "sorted_by", thrift.LIST, 4)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.SortedBy {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THiveBucket) field1Length() int {
	l := 0
	if p.IsSetBucketedBy() {
		l += bthrift.Binary.FieldBeginLength("bucketed_by", thrift.LIST, 1)
		l += bthrift.Binary.ListBeginLength(thrift.STRING, len(p.BucketedBy))
		for _, v := range p.BucketedBy {
			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THiveBucket) field2Length() int {
	l := 0
	if p.IsSetBucketMode() {
		l += bthrift.Binary.FieldBeginLength("bucket_mode", thrift.STRUCT, 2)
		l += p.BucketMode.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THiveBucket) field3Length() int {
	l := 0
	if p.IsSetBucketCount() {
		l += bthrift.Binary.FieldBeginLength("bucket_count", thrift.I32, 3)
		l += bthrift.Binary.I32Length(*p.BucketCount)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THiveBucket) field4Length() int {
	l := 0
	if p.IsSetSortedBy() {
		l += bthrift.Binary.FieldBeginLength("sorted_by", thrift.LIST, 4)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.SortedBy))
		for _, v := range p.SortedBy {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THiveColumn) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_THiveColumn[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *THiveColumn) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Name = &v

	}
	return offset, nil
}

func (p *THiveColumn) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := THiveColumnType(v)
		p.ColumnType = &tmp

	}
	return offset, nil
}

// for compatibility
func (p *THiveColumn) FastWrite(buf []byte) int {
	return 0
}

func (p *THiveColumn) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "THiveColumn")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *THiveColumn) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("THiveColumn")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *THiveColumn) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetName() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "name", thrift.STRING, 1)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Name)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THiveColumn) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetColumnType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "column_type", thrift.I32, 2)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.ColumnType))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THiveColumn) field1Length() int {
	l := 0
	if p.IsSetName() {
		l += bthrift.Binary.FieldBeginLength("name", thrift.STRING, 1)
		l += bthrift.Binary.StringLengthNocopy(*p.Name)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THiveColumn) field2Length() int {
	l := 0
	if p.IsSetColumnType() {
		l += bthrift.Binary.FieldBeginLength("column_type", thrift.I32, 2)
		l += bthrift.Binary.I32Length(int32(*p.ColumnType))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THivePartition) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_THivePartition[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *THivePartition) FastReadField1(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Values = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.Values = append(p.Values, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *THivePartition) FastReadField2(buf []byte) (int, error) {
	offset := 0

	tmp := NewTHiveLocationParams()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.Location = tmp
	return offset, nil
}

func (p *THivePartition) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := plannodes.TFileFormatType(v)
		p.FileFormat = &tmp

	}
	return offset, nil
}

// for compatibility
func (p *THivePartition) FastWrite(buf []byte) int {
	return 0
}

func (p *THivePartition) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "THivePartition")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *THivePartition) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("THivePartition")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *THivePartition) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetValues() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "values", thrift.LIST, 1)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRING, 0)
		var length int
		for _, v := range p.Values {
			length++
			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRING, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THivePartition) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetLocation() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "location", thrift.STRUCT, 2)
		offset += p.Location.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THivePartition) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFileFormat() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "file_format", thrift.I32, 3)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.FileFormat))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THivePartition) field1Length() int {
	l := 0
	if p.IsSetValues() {
		l += bthrift.Binary.FieldBeginLength("values", thrift.LIST, 1)
		l += bthrift.Binary.ListBeginLength(thrift.STRING, len(p.Values))
		for _, v := range p.Values {
			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THivePartition) field2Length() int {
	l := 0
	if p.IsSetLocation() {
		l += bthrift.Binary.FieldBeginLength("location", thrift.STRUCT, 2)
		l += p.Location.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THivePartition) field3Length() int {
	l := 0
	if p.IsSetFileFormat() {
		l += bthrift.Binary.FieldBeginLength("file_format", thrift.I32, 3)
		l += bthrift.Binary.I32Length(int32(*p.FileFormat))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THiveTableSink) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField9(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_THiveTableSink[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *THiveTableSink) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.DbName = &v

	}
	return offset, nil
}

func (p *THiveTableSink) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.TableName = &v

	}
	return offset, nil
}

func (p *THiveTableSink) FastReadField3(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Columns = make([]*THiveColumn, 0, size)
	for i := 0; i < size; i++ {
		_elem := NewTHiveColumn()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.Columns = append(p.Columns, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *THiveTableSink) FastReadField4(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Partitions = make([]*THivePartition, 0, size)
	for i := 0; i < size; i++ {
		_elem := NewTHivePartition()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.Partitions = append(p.Partitions, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *THiveTableSink) FastReadField5(buf []byte) (int, error) {
	offset := 0

	tmp := NewTHiveBucket()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.BucketInfo = tmp
	return offset, nil
}

func (p *THiveTableSink) FastReadField6(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := plannodes.TFileFormatType(v)
		p.FileFormat = &tmp

	}
	return offset, nil
}

func (p *THiveTableSink) FastReadField7(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := plannodes.TFileCompressType(v)
		p.CompressionType = &tmp

	}
	return offset, nil
}

func (p *THiveTableSink) FastReadField8(buf []byte) (int, error) {
	offset := 0

	tmp := NewTHiveLocationParams()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.Location = tmp
	return offset, nil
}

func (p *THiveTableSink) FastReadField9(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := bthrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.HadoopConfig = make(map[string]string, size)
	for i := 0; i < size; i++ {
		var _key string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_key = v

		}

		var _val string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_val = v

		}

		p.HadoopConfig[_key] = _val
	}
	if l, err := bthrift.Binary.ReadMapEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *THiveTableSink) FastReadField10(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Overwrite = &v

	}
	return offset, nil
}

// for compatibility
func (p *THiveTableSink) FastWrite(buf []byte) int {
	return 0
}

func (p *THiveTableSink) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "THiveTableSink")
	if p != nil {
		offset += p.fastWriteField10(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
		offset += p.fastWriteField9(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *THiveTableSink) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("THiveTableSink")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field9Length()
		l += p.field10Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *THiveTableSink) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDbName() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "db_name", thrift.STRING, 1)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.DbName)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THiveTableSink) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTableName() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "table_name", thrift.STRING, 2)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.TableName)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THiveTableSink) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetColumns() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "columns", thrift.LIST, 3)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.Columns {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THiveTableSink) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPartitions() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "partitions", thrift.LIST, 4)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.Partitions {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THiveTableSink) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetBucketInfo() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "bucket_info", thrift.STRUCT, 5)
		offset += p.BucketInfo.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THiveTableSink) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFileFormat() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "file_format", thrift.I32, 6)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.FileFormat))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THiveTableSink) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetCompressionType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "compression_type", thrift.I32, 7)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.CompressionType))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THiveTableSink) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetLocation() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "location", thrift.STRUCT, 8)
		offset += p.Location.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THiveTableSink) fastWriteField9(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetHadoopConfig() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "hadoop_config", thrift.MAP, 9)
		mapBeginOffset := offset
		offset += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRING, 0)
		var length int
		for k, v := range p.HadoopConfig {
			length++

			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, k)

			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.STRING, thrift.STRING, length)
		offset += bthrift.Binary.WriteMapEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THiveTableSink) fastWriteField10(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetOverwrite() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "overwrite", thrift.BOOL, 10)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.Overwrite)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THiveTableSink) field1Length() int {
	l := 0
	if p.IsSetDbName() {
		l += bthrift.Binary.FieldBeginLength("db_name", thrift.STRING, 1)
		l += bthrift.Binary.StringLengthNocopy(*p.DbName)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THiveTableSink) field2Length() int {
	l := 0
	if p.IsSetTableName() {
		l += bthrift.Binary.FieldBeginLength("table_name", thrift.STRING, 2)
		l += bthrift.Binary.StringLengthNocopy(*p.TableName)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THiveTableSink) field3Length() int {
	l := 0
	if p.IsSetColumns() {
		l += bthrift.Binary.FieldBeginLength("columns", thrift.LIST, 3)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.Columns))
		for _, v := range p.Columns {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THiveTableSink) field4Length() int {
	l := 0
	if p.IsSetPartitions() {
		l += bthrift.Binary.FieldBeginLength("partitions", thrift.LIST, 4)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.Partitions))
		for _, v := range p.Partitions {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THiveTableSink) field5Length() int {
	l := 0
	if p.IsSetBucketInfo() {
		l += bthrift.Binary.FieldBeginLength("bucket_info", thrift.STRUCT, 5)
		l += p.BucketInfo.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THiveTableSink) field6Length() int {
	l := 0
	if p.IsSetFileFormat() {
		l += bthrift.Binary.FieldBeginLength("file_format", thrift.I32, 6)
		l += bthrift.Binary.I32Length(int32(*p.FileFormat))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THiveTableSink) field7Length() int {
	l := 0
	if p.IsSetCompressionType() {
		l += bthrift.Binary.FieldBeginLength("compression_type", thrift.I32, 7)
		l += bthrift.Binary.I32Length(int32(*p.CompressionType))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THiveTableSink) field8Length() int {
	l := 0
	if p.IsSetLocation() {
		l += bthrift.Binary.FieldBeginLength("location", thrift.STRUCT, 8)
		l += p.Location.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THiveTableSink) field9Length() int {
	l := 0
	if p.IsSetHadoopConfig() {
		l += bthrift.Binary.FieldBeginLength("hadoop_config", thrift.MAP, 9)
		l += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRING, len(p.HadoopConfig))
		for k, v := range p.HadoopConfig {

			l += bthrift.Binary.StringLengthNocopy(k)

			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.MapEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THiveTableSink) field10Length() int {
	l := 0
	if p.IsSetOverwrite() {
		l += bthrift.Binary.FieldBeginLength("overwrite", thrift.BOOL, 10)
		l += bthrift.Binary.BoolLength(*p.Overwrite)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TS3MPUPendingUpload) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TS3MPUPendingUpload[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TS3MPUPendingUpload) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Bucket = &v

	}
	return offset, nil
}

func (p *TS3MPUPendingUpload) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Key = &v

	}
	return offset, nil
}

func (p *TS3MPUPendingUpload) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.UploadId = &v

	}
	return offset, nil
}

func (p *TS3MPUPendingUpload) FastReadField4(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := bthrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Etags = make(map[int32]string, size)
	for i := 0; i < size; i++ {
		var _key int32
		if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_key = v

		}

		var _val string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_val = v

		}

		p.Etags[_key] = _val
	}
	if l, err := bthrift.Binary.ReadMapEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

// for compatibility
func (p *TS3MPUPendingUpload) FastWrite(buf []byte) int {
	return 0
}

func (p *TS3MPUPendingUpload) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TS3MPUPendingUpload")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TS3MPUPendingUpload) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TS3MPUPendingUpload")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TS3MPUPendingUpload) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetBucket() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "bucket", thrift.STRING, 1)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Bucket)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TS3MPUPendingUpload) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetKey() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "key", thrift.STRING, 2)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Key)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TS3MPUPendingUpload) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetUploadId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "upload_id", thrift.STRING, 3)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.UploadId)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TS3MPUPendingUpload) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetEtags() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "etags", thrift.MAP, 4)
		mapBeginOffset := offset
		offset += bthrift.Binary.MapBeginLength(thrift.I32, thrift.STRING, 0)
		var length int
		for k, v := range p.Etags {
			length++

			offset += bthrift.Binary.WriteI32(buf[offset:], k)

			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.I32, thrift.STRING, length)
		offset += bthrift.Binary.WriteMapEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TS3MPUPendingUpload) field1Length() int {
	l := 0
	if p.IsSetBucket() {
		l += bthrift.Binary.FieldBeginLength("bucket", thrift.STRING, 1)
		l += bthrift.Binary.StringLengthNocopy(*p.Bucket)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TS3MPUPendingUpload) field2Length() int {
	l := 0
	if p.IsSetKey() {
		l += bthrift.Binary.FieldBeginLength("key", thrift.STRING, 2)
		l += bthrift.Binary.StringLengthNocopy(*p.Key)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TS3MPUPendingUpload) field3Length() int {
	l := 0
	if p.IsSetUploadId() {
		l += bthrift.Binary.FieldBeginLength("upload_id", thrift.STRING, 3)
		l += bthrift.Binary.StringLengthNocopy(*p.UploadId)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TS3MPUPendingUpload) field4Length() int {
	l := 0
	if p.IsSetEtags() {
		l += bthrift.Binary.FieldBeginLength("etags", thrift.MAP, 4)
		l += bthrift.Binary.MapBeginLength(thrift.I32, thrift.STRING, len(p.Etags))
		for k, v := range p.Etags {

			l += bthrift.Binary.I32Length(k)

			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.MapEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THivePartitionUpdate) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_THivePartitionUpdate[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *THivePartitionUpdate) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Name = &v

	}
	return offset, nil
}

func (p *THivePartitionUpdate) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := TUpdateMode(v)
		p.UpdateMode = &tmp

	}
	return offset, nil
}

func (p *THivePartitionUpdate) FastReadField3(buf []byte) (int, error) {
	offset := 0

	tmp := NewTHiveLocationParams()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.Location = tmp
	return offset, nil
}

func (p *THivePartitionUpdate) FastReadField4(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.FileNames = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.FileNames = append(p.FileNames, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *THivePartitionUpdate) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.RowCount = &v

	}
	return offset, nil
}

func (p *THivePartitionUpdate) FastReadField6(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.FileSize = &v

	}
	return offset, nil
}

func (p *THivePartitionUpdate) FastReadField7(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.S3MpuPendingUploads = make([]*TS3MPUPendingUpload, 0, size)
	for i := 0; i < size; i++ {
		_elem := NewTS3MPUPendingUpload()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.S3MpuPendingUploads = append(p.S3MpuPendingUploads, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

// for compatibility
func (p *THivePartitionUpdate) FastWrite(buf []byte) int {
	return 0
}

func (p *THivePartitionUpdate) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "THivePartitionUpdate")
	if p != nil {
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *THivePartitionUpdate) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("THivePartitionUpdate")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *THivePartitionUpdate) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetName() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "name", thrift.STRING, 1)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Name)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THivePartitionUpdate) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetUpdateMode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "update_mode", thrift.I32, 2)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.UpdateMode))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THivePartitionUpdate) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetLocation() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "location", thrift.STRUCT, 3)
		offset += p.Location.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THivePartitionUpdate) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFileNames() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "file_names", thrift.LIST, 4)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRING, 0)
		var length int
		for _, v := range p.FileNames {
			length++
			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRING, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THivePartitionUpdate) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetRowCount() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "row_count", thrift.I64, 5)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.RowCount)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THivePartitionUpdate) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFileSize() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "file_size", thrift.I64, 6)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.FileSize)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THivePartitionUpdate) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetS3MpuPendingUploads() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "s3_mpu_pending_uploads", thrift.LIST, 7)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.S3MpuPendingUploads {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THivePartitionUpdate) field1Length() int {
	l := 0
	if p.IsSetName() {
		l += bthrift.Binary.FieldBeginLength("name", thrift.STRING, 1)
		l += bthrift.Binary.StringLengthNocopy(*p.Name)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THivePartitionUpdate) field2Length() int {
	l := 0
	if p.IsSetUpdateMode() {
		l += bthrift.Binary.FieldBeginLength("update_mode", thrift.I32, 2)
		l += bthrift.Binary.I32Length(int32(*p.UpdateMode))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THivePartitionUpdate) field3Length() int {
	l := 0
	if p.IsSetLocation() {
		l += bthrift.Binary.FieldBeginLength("location", thrift.STRUCT, 3)
		l += p.Location.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THivePartitionUpdate) field4Length() int {
	l := 0
	if p.IsSetFileNames() {
		l += bthrift.Binary.FieldBeginLength("file_names", thrift.LIST, 4)
		l += bthrift.Binary.ListBeginLength(thrift.STRING, len(p.FileNames))
		for _, v := range p.FileNames {
			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THivePartitionUpdate) field5Length() int {
	l := 0
	if p.IsSetRowCount() {
		l += bthrift.Binary.FieldBeginLength("row_count", thrift.I64, 5)
		l += bthrift.Binary.I64Length(*p.RowCount)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THivePartitionUpdate) field6Length() int {
	l := 0
	if p.IsSetFileSize() {
		l += bthrift.Binary.FieldBeginLength("file_size", thrift.I64, 6)
		l += bthrift.Binary.I64Length(*p.FileSize)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THivePartitionUpdate) field7Length() int {
	l := 0
	if p.IsSetS3MpuPendingUploads() {
		l += bthrift.Binary.FieldBeginLength("s3_mpu_pending_uploads", thrift.LIST, 7)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.S3MpuPendingUploads))
		for _, v := range p.S3MpuPendingUploads {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TIcebergCommitData) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TIcebergCommitData[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TIcebergCommitData) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.FilePath = &v

	}
	return offset, nil
}

func (p *TIcebergCommitData) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.RowCount = &v

	}
	return offset, nil
}

func (p *TIcebergCommitData) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.FileSize = &v

	}
	return offset, nil
}

func (p *TIcebergCommitData) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := TFileContent(v)
		p.FileContent = &tmp

	}
	return offset, nil
}

func (p *TIcebergCommitData) FastReadField5(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.PartitionValues = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.PartitionValues = append(p.PartitionValues, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TIcebergCommitData) FastReadField6(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.ReferencedDataFiles = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.ReferencedDataFiles = append(p.ReferencedDataFiles, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

// for compatibility
func (p *TIcebergCommitData) FastWrite(buf []byte) int {
	return 0
}

func (p *TIcebergCommitData) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TIcebergCommitData")
	if p != nil {
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TIcebergCommitData) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TIcebergCommitData")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TIcebergCommitData) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFilePath() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "file_path", thrift.STRING, 1)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.FilePath)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TIcebergCommitData) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetRowCount() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "row_count", thrift.I64, 2)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.RowCount)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TIcebergCommitData) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFileSize() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "file_size", thrift.I64, 3)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.FileSize)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TIcebergCommitData) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFileContent() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "file_content", thrift.I32, 4)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.FileContent))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TIcebergCommitData) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPartitionValues() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "partition_values", thrift.LIST, 5)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRING, 0)
		var length int
		for _, v := range p.PartitionValues {
			length++
			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRING, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TIcebergCommitData) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetReferencedDataFiles() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "referenced_data_files", thrift.LIST, 6)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRING, 0)
		var length int
		for _, v := range p.ReferencedDataFiles {
			length++
			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRING, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TIcebergCommitData) field1Length() int {
	l := 0
	if p.IsSetFilePath() {
		l += bthrift.Binary.FieldBeginLength("file_path", thrift.STRING, 1)
		l += bthrift.Binary.StringLengthNocopy(*p.FilePath)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TIcebergCommitData) field2Length() int {
	l := 0
	if p.IsSetRowCount() {
		l += bthrift.Binary.FieldBeginLength("row_count", thrift.I64, 2)
		l += bthrift.Binary.I64Length(*p.RowCount)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TIcebergCommitData) field3Length() int {
	l := 0
	if p.IsSetFileSize() {
		l += bthrift.Binary.FieldBeginLength("file_size", thrift.I64, 3)
		l += bthrift.Binary.I64Length(*p.FileSize)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TIcebergCommitData) field4Length() int {
	l := 0
	if p.IsSetFileContent() {
		l += bthrift.Binary.FieldBeginLength("file_content", thrift.I32, 4)
		l += bthrift.Binary.I32Length(int32(*p.FileContent))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TIcebergCommitData) field5Length() int {
	l := 0
	if p.IsSetPartitionValues() {
		l += bthrift.Binary.FieldBeginLength("partition_values", thrift.LIST, 5)
		l += bthrift.Binary.ListBeginLength(thrift.STRING, len(p.PartitionValues))
		for _, v := range p.PartitionValues {
			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TIcebergCommitData) field6Length() int {
	l := 0
	if p.IsSetReferencedDataFiles() {
		l += bthrift.Binary.FieldBeginLength("referenced_data_files", thrift.LIST, 6)
		l += bthrift.Binary.ListBeginLength(thrift.STRING, len(p.ReferencedDataFiles))
		for _, v := range p.ReferencedDataFiles {
			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TSortField) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TSortField[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TSortField) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.SourceColumnId = &v

	}
	return offset, nil
}

func (p *TSortField) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Ascending = &v

	}
	return offset, nil
}

func (p *TSortField) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.NullFirst = &v

	}
	return offset, nil
}

// for compatibility
func (p *TSortField) FastWrite(buf []byte) int {
	return 0
}

func (p *TSortField) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TSortField")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TSortField) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TSortField")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TSortField) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSourceColumnId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "source_column_id", thrift.I32, 1)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.SourceColumnId)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TSortField) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetAscending() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "ascending", thrift.BOOL, 2)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.Ascending)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TSortField) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetNullFirst() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "null_first", thrift.BOOL, 3)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.NullFirst)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TSortField) field1Length() int {
	l := 0
	if p.IsSetSourceColumnId() {
		l += bthrift.Binary.FieldBeginLength("source_column_id", thrift.I32, 1)
		l += bthrift.Binary.I32Length(*p.SourceColumnId)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TSortField) field2Length() int {
	l := 0
	if p.IsSetAscending() {
		l += bthrift.Binary.FieldBeginLength("ascending", thrift.BOOL, 2)
		l += bthrift.Binary.BoolLength(*p.Ascending)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TSortField) field3Length() int {
	l := 0
	if p.IsSetNullFirst() {
		l += bthrift.Binary.FieldBeginLength("null_first", thrift.BOOL, 3)
		l += bthrift.Binary.BoolLength(*p.NullFirst)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TIcebergTableSink) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField9(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 11:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField11(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 12:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField12(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 13:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField13(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TIcebergTableSink[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TIcebergTableSink) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.DbName = &v

	}
	return offset, nil
}

func (p *TIcebergTableSink) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.TbName = &v

	}
	return offset, nil
}

func (p *TIcebergTableSink) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.SchemaJson = &v

	}
	return offset, nil
}

func (p *TIcebergTableSink) FastReadField4(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := bthrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.PartitionSpecsJson = make(map[int32]string, size)
	for i := 0; i < size; i++ {
		var _key int32
		if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_key = v

		}

		var _val string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_val = v

		}

		p.PartitionSpecsJson[_key] = _val
	}
	if l, err := bthrift.Binary.ReadMapEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TIcebergTableSink) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.PartitionSpecId = &v

	}
	return offset, nil
}

func (p *TIcebergTableSink) FastReadField6(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.SortFields = make([]*TSortField, 0, size)
	for i := 0; i < size; i++ {
		_elem := NewTSortField()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.SortFields = append(p.SortFields, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TIcebergTableSink) FastReadField7(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := plannodes.TFileFormatType(v)
		p.FileFormat = &tmp

	}
	return offset, nil
}

func (p *TIcebergTableSink) FastReadField8(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.OutputPath = &v

	}
	return offset, nil
}

func (p *TIcebergTableSink) FastReadField9(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := bthrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.HadoopConfig = make(map[string]string, size)
	for i := 0; i < size; i++ {
		var _key string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_key = v

		}

		var _val string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_val = v

		}

		p.HadoopConfig[_key] = _val
	}
	if l, err := bthrift.Binary.ReadMapEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TIcebergTableSink) FastReadField10(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Overwrite = &v

	}
	return offset, nil
}

func (p *TIcebergTableSink) FastReadField11(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := types.TFileType(v)
		p.FileType = &tmp

	}
	return offset, nil
}

func (p *TIcebergTableSink) FastReadField12(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.OriginalOutputPath = &v

	}
	return offset, nil
}

func (p *TIcebergTableSink) FastReadField13(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := plannodes.TFileCompressType(v)
		p.CompressionType = &tmp

	}
	return offset, nil
}

// for compatibility
func (p *TIcebergTableSink) FastWrite(buf []byte) int {
	return 0
}

func (p *TIcebergTableSink) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TIcebergTableSink")
	if p != nil {
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField10(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
		offset += p.fastWriteField9(buf[offset:], binaryWriter)
		offset += p.fastWriteField11(buf[offset:], binaryWriter)
		offset += p.fastWriteField12(buf[offset:], binaryWriter)
		offset += p.fastWriteField13(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TIcebergTableSink) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TIcebergTableSink")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field9Length()
		l += p.field10Length()
		l += p.field11Length()
		l += p.field12Length()
		l += p.field13Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TIcebergTableSink) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDbName() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "db_name", thrift.STRING, 1)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.DbName)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TIcebergTableSink) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTbName() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tb_name", thrift.STRING, 2)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.TbName)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TIcebergTableSink) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSchemaJson() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "schema_json", thrift.STRING, 3)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.SchemaJson)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TIcebergTableSink) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPartitionSpecsJson() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "partition_specs_json", thrift.MAP, 4)
		mapBeginOffset := offset
		offset += bthrift.Binary.MapBeginLength(thrift.I32, thrift.STRING, 0)
		var length int
		for k, v := range p.PartitionSpecsJson {
			length++

			offset += bthrift.Binary.WriteI32(buf[offset:], k)

			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.I32, thrift.STRING, length)
		offset += bthrift.Binary.WriteMapEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TIcebergTableSink) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPartitionSpecId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "partition_spec_id", thrift.I32, 5)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.PartitionSpecId)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TIcebergTableSink) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSortFields() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "sort_fields", thrift.LIST, 6)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.SortFields {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TIcebergTableSink) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFileFormat() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "file_format", thrift.I32, 7)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.FileFormat))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TIcebergTableSink) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetOutputPath() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "output_path", thrift.STRING, 8)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.OutputPath)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TIcebergTableSink) fastWriteField9(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetHadoopConfig() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "hadoop_config", thrift.MAP, 9)
		mapBeginOffset := offset
		offset += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRING, 0)
		var length int
		for k, v := range p.HadoopConfig {
			length++

			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, k)

			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.STRING, thrift.STRING, length)
		offset += bthrift.Binary.WriteMapEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TIcebergTableSink) fastWriteField10(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetOverwrite() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "overwrite", thrift.BOOL, 10)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.Overwrite)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TIcebergTableSink) fastWriteField11(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFileType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "file_type", thrift.I32, 11)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.FileType))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TIcebergTableSink) fastWriteField12(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetOriginalOutputPath() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "original_output_path", thrift.STRING, 12)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.OriginalOutputPath)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TIcebergTableSink) fastWriteField13(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetCompressionType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "compression_type", thrift.I32, 13)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.CompressionType))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TIcebergTableSink) field1Length() int {
	l := 0
	if p.IsSetDbName() {
		l += bthrift.Binary.FieldBeginLength("db_name", thrift.STRING, 1)
		l += bthrift.Binary.StringLengthNocopy(*p.DbName)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TIcebergTableSink) field2Length() int {
	l := 0
	if p.IsSetTbName() {
		l += bthrift.Binary.FieldBeginLength("tb_name", thrift.STRING, 2)
		l += bthrift.Binary.StringLengthNocopy(*p.TbName)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TIcebergTableSink) field3Length() int {
	l := 0
	if p.IsSetSchemaJson() {
		l += bthrift.Binary.FieldBeginLength("schema_json", thrift.STRING, 3)
		l += bthrift.Binary.StringLengthNocopy(*p.SchemaJson)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TIcebergTableSink) field4Length() int {
	l := 0
	if p.IsSetPartitionSpecsJson() {
		l += bthrift.Binary.FieldBeginLength("partition_specs_json", thrift.MAP, 4)
		l += bthrift.Binary.MapBeginLength(thrift.I32, thrift.STRING, len(p.PartitionSpecsJson))
		for k, v := range p.PartitionSpecsJson {

			l += bthrift.Binary.I32Length(k)

			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.MapEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TIcebergTableSink) field5Length() int {
	l := 0
	if p.IsSetPartitionSpecId() {
		l += bthrift.Binary.FieldBeginLength("partition_spec_id", thrift.I32, 5)
		l += bthrift.Binary.I32Length(*p.PartitionSpecId)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TIcebergTableSink) field6Length() int {
	l := 0
	if p.IsSetSortFields() {
		l += bthrift.Binary.FieldBeginLength("sort_fields", thrift.LIST, 6)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.SortFields))
		for _, v := range p.SortFields {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TIcebergTableSink) field7Length() int {
	l := 0
	if p.IsSetFileFormat() {
		l += bthrift.Binary.FieldBeginLength("file_format", thrift.I32, 7)
		l += bthrift.Binary.I32Length(int32(*p.FileFormat))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TIcebergTableSink) field8Length() int {
	l := 0
	if p.IsSetOutputPath() {
		l += bthrift.Binary.FieldBeginLength("output_path", thrift.STRING, 8)
		l += bthrift.Binary.StringLengthNocopy(*p.OutputPath)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TIcebergTableSink) field9Length() int {
	l := 0
	if p.IsSetHadoopConfig() {
		l += bthrift.Binary.FieldBeginLength("hadoop_config", thrift.MAP, 9)
		l += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRING, len(p.HadoopConfig))
		for k, v := range p.HadoopConfig {

			l += bthrift.Binary.StringLengthNocopy(k)

			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.MapEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TIcebergTableSink) field10Length() int {
	l := 0
	if p.IsSetOverwrite() {
		l += bthrift.Binary.FieldBeginLength("overwrite", thrift.BOOL, 10)
		l += bthrift.Binary.BoolLength(*p.Overwrite)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TIcebergTableSink) field11Length() int {
	l := 0
	if p.IsSetFileType() {
		l += bthrift.Binary.FieldBeginLength("file_type", thrift.I32, 11)
		l += bthrift.Binary.I32Length(int32(*p.FileType))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TIcebergTableSink) field12Length() int {
	l := 0
	if p.IsSetOriginalOutputPath() {
		l += bthrift.Binary.FieldBeginLength("original_output_path", thrift.STRING, 12)
		l += bthrift.Binary.StringLengthNocopy(*p.OriginalOutputPath)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TIcebergTableSink) field13Length() int {
	l := 0
	if p.IsSetCompressionType() {
		l += bthrift.Binary.FieldBeginLength("compression_type", thrift.I32, 13)
		l += bthrift.Binary.I32Length(int32(*p.CompressionType))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TDataSink) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetType bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetType = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField9(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 11:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField11(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 12:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField12(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 13:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField13(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 14:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField14(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetType {
		fieldId = 1
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TDataSink[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TDataSink[fieldId]))
}

func (p *TDataSink) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Type = TDataSinkType(v)

	}
	return offset, nil
}

func (p *TDataSink) FastReadField2(buf []byte) (int, error) {
	offset := 0

	tmp := NewTDataStreamSink()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.StreamSink = tmp
	return offset, nil
}

func (p *TDataSink) FastReadField3(buf []byte) (int, error) {
	offset := 0

	tmp := NewTResultSink()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.ResultSink = tmp
	return offset, nil
}

func (p *TDataSink) FastReadField5(buf []byte) (int, error) {
	offset := 0

	tmp := NewTMysqlTableSink()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.MysqlTableSink = tmp
	return offset, nil
}

func (p *TDataSink) FastReadField6(buf []byte) (int, error) {
	offset := 0

	tmp := NewTExportSink()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.ExportSink = tmp
	return offset, nil
}

func (p *TDataSink) FastReadField7(buf []byte) (int, error) {
	offset := 0

	tmp := NewTOlapTableSink()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.OlapTableSink = tmp
	return offset, nil
}

func (p *TDataSink) FastReadField8(buf []byte) (int, error) {
	offset := 0

	tmp := NewTMemoryScratchSink()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.MemoryScratchSink = tmp
	return offset, nil
}

func (p *TDataSink) FastReadField9(buf []byte) (int, error) {
	offset := 0

	tmp := NewTOdbcTableSink()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.OdbcTableSink = tmp
	return offset, nil
}

func (p *TDataSink) FastReadField10(buf []byte) (int, error) {
	offset := 0

	tmp := NewTResultFileSink()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.ResultFileSink = tmp
	return offset, nil
}

func (p *TDataSink) FastReadField11(buf []byte) (int, error) {
	offset := 0

	tmp := NewTJdbcTableSink()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.JdbcTableSink = tmp
	return offset, nil
}

func (p *TDataSink) FastReadField12(buf []byte) (int, error) {
	offset := 0

	tmp := NewTMultiCastDataStreamSink()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.MultiCastStreamSink = tmp
	return offset, nil
}

func (p *TDataSink) FastReadField13(buf []byte) (int, error) {
	offset := 0

	tmp := NewTHiveTableSink()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.HiveTableSink = tmp
	return offset, nil
}

func (p *TDataSink) FastReadField14(buf []byte) (int, error) {
	offset := 0

	tmp := NewTIcebergTableSink()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.IcebergTableSink = tmp
	return offset, nil
}

// for compatibility
func (p *TDataSink) FastWrite(buf []byte) int {
	return 0
}

func (p *TDataSink) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TDataSink")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
		offset += p.fastWriteField9(buf[offset:], binaryWriter)
		offset += p.fastWriteField10(buf[offset:], binaryWriter)
		offset += p.fastWriteField11(buf[offset:], binaryWriter)
		offset += p.fastWriteField12(buf[offset:], binaryWriter)
		offset += p.fastWriteField13(buf[offset:], binaryWriter)
		offset += p.fastWriteField14(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TDataSink) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TDataSink")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field9Length()
		l += p.field10Length()
		l += p.field11Length()
		l += p.field12Length()
		l += p.field13Length()
		l += p.field14Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TDataSink) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "type", thrift.I32, 1)
	offset += bthrift.Binary.WriteI32(buf[offset:], int32(p.Type))

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TDataSink) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetStreamSink() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "stream_sink", thrift.STRUCT, 2)
		offset += p.StreamSink.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TDataSink) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetResultSink() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "result_sink", thrift.STRUCT, 3)
		offset += p.ResultSink.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TDataSink) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetMysqlTableSink() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "mysql_table_sink", thrift.STRUCT, 5)
		offset += p.MysqlTableSink.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TDataSink) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetExportSink() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "export_sink", thrift.STRUCT, 6)
		offset += p.ExportSink.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TDataSink) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetOlapTableSink() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "olap_table_sink", thrift.STRUCT, 7)
		offset += p.OlapTableSink.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TDataSink) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetMemoryScratchSink() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "memory_scratch_sink", thrift.STRUCT, 8)
		offset += p.MemoryScratchSink.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TDataSink) fastWriteField9(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetOdbcTableSink() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "odbc_table_sink", thrift.STRUCT, 9)
		offset += p.OdbcTableSink.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TDataSink) fastWriteField10(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetResultFileSink() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "result_file_sink", thrift.STRUCT, 10)
		offset += p.ResultFileSink.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TDataSink) fastWriteField11(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetJdbcTableSink() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "jdbc_table_sink", thrift.STRUCT, 11)
		offset += p.JdbcTableSink.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TDataSink) fastWriteField12(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetMultiCastStreamSink() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "multi_cast_stream_sink", thrift.STRUCT, 12)
		offset += p.MultiCastStreamSink.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TDataSink) fastWriteField13(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetHiveTableSink() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "hive_table_sink", thrift.STRUCT, 13)
		offset += p.HiveTableSink.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TDataSink) fastWriteField14(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIcebergTableSink() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "iceberg_table_sink", thrift.STRUCT, 14)
		offset += p.IcebergTableSink.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TDataSink) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("type", thrift.I32, 1)
	l += bthrift.Binary.I32Length(int32(p.Type))

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TDataSink) field2Length() int {
	l := 0
	if p.IsSetStreamSink() {
		l += bthrift.Binary.FieldBeginLength("stream_sink", thrift.STRUCT, 2)
		l += p.StreamSink.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TDataSink) field3Length() int {
	l := 0
	if p.IsSetResultSink() {
		l += bthrift.Binary.FieldBeginLength("result_sink", thrift.STRUCT, 3)
		l += p.ResultSink.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TDataSink) field5Length() int {
	l := 0
	if p.IsSetMysqlTableSink() {
		l += bthrift.Binary.FieldBeginLength("mysql_table_sink", thrift.STRUCT, 5)
		l += p.MysqlTableSink.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TDataSink) field6Length() int {
	l := 0
	if p.IsSetExportSink() {
		l += bthrift.Binary.FieldBeginLength("export_sink", thrift.STRUCT, 6)
		l += p.ExportSink.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TDataSink) field7Length() int {
	l := 0
	if p.IsSetOlapTableSink() {
		l += bthrift.Binary.FieldBeginLength("olap_table_sink", thrift.STRUCT, 7)
		l += p.OlapTableSink.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TDataSink) field8Length() int {
	l := 0
	if p.IsSetMemoryScratchSink() {
		l += bthrift.Binary.FieldBeginLength("memory_scratch_sink", thrift.STRUCT, 8)
		l += p.MemoryScratchSink.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TDataSink) field9Length() int {
	l := 0
	if p.IsSetOdbcTableSink() {
		l += bthrift.Binary.FieldBeginLength("odbc_table_sink", thrift.STRUCT, 9)
		l += p.OdbcTableSink.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TDataSink) field10Length() int {
	l := 0
	if p.IsSetResultFileSink() {
		l += bthrift.Binary.FieldBeginLength("result_file_sink", thrift.STRUCT, 10)
		l += p.ResultFileSink.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TDataSink) field11Length() int {
	l := 0
	if p.IsSetJdbcTableSink() {
		l += bthrift.Binary.FieldBeginLength("jdbc_table_sink", thrift.STRUCT, 11)
		l += p.JdbcTableSink.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TDataSink) field12Length() int {
	l := 0
	if p.IsSetMultiCastStreamSink() {
		l += bthrift.Binary.FieldBeginLength("multi_cast_stream_sink", thrift.STRUCT, 12)
		l += p.MultiCastStreamSink.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TDataSink) field13Length() int {
	l := 0
	if p.IsSetHiveTableSink() {
		l += bthrift.Binary.FieldBeginLength("hive_table_sink", thrift.STRUCT, 13)
		l += p.HiveTableSink.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TDataSink) field14Length() int {
	l := 0
	if p.IsSetIcebergTableSink() {
		l += bthrift.Binary.FieldBeginLength("iceberg_table_sink", thrift.STRUCT, 14)
		l += p.IcebergTableSink.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}
