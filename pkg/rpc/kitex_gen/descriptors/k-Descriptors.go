// Code generated by Kitex v0.4.4. DO NOT EDIT.

package descriptors

import (
	"bytes"
	"fmt"
	"reflect"
	"strings"

	"github.com/apache/thrift/lib/go/thrift"

	"github.com/cloudwego/kitex/pkg/protocol/bthrift"
	"github.com/selectdb/ccr_syncer/pkg/rpc/kitex_gen/exprs"
	"github.com/selectdb/ccr_syncer/pkg/rpc/kitex_gen/partitions"
	"github.com/selectdb/ccr_syncer/pkg/rpc/kitex_gen/types"
)

// unused protection
var (
	_ = fmt.Formatter(nil)
	_ = (*bytes.Buffer)(nil)
	_ = (*strings.Builder)(nil)
	_ = reflect.Type(nil)
	_ = thrift.TProtocol(nil)
	_ = bthrift.BinaryWriter(nil)
	_ = exprs.KitexUnusedProtection
	_ = partitions.KitexUnusedProtection
	_ = types.KitexUnusedProtection
)

func (p *TColumn) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetColumnName bool = false
	var issetColumnType bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetColumnName = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetColumnType = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField9(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 11:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField11(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 12:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField12(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 13:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField13(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 14:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField14(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 15:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField15(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 16:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField16(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 17:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField17(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 18:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField18(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 19:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField19(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetColumnName {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetColumnType {
		fieldId = 2
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TColumn[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TColumn[fieldId]))
}

func (p *TColumn) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.ColumnName = v

	}
	return offset, nil
}

func (p *TColumn) FastReadField2(buf []byte) (int, error) {
	offset := 0

	tmp := types.NewTColumnType()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.ColumnType = tmp
	return offset, nil
}

func (p *TColumn) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := types.TAggregationType(v)
		p.AggregationType = &tmp

	}
	return offset, nil
}

func (p *TColumn) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.IsKey = &v

	}
	return offset, nil
}

func (p *TColumn) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.IsAllowNull = &v

	}
	return offset, nil
}

func (p *TColumn) FastReadField6(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.DefaultValue = &v

	}
	return offset, nil
}

func (p *TColumn) FastReadField7(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.IsBloomFilterColumn = &v

	}
	return offset, nil
}

func (p *TColumn) FastReadField8(buf []byte) (int, error) {
	offset := 0

	tmp := exprs.NewTExpr()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.DefineExpr = tmp
	return offset, nil
}

func (p *TColumn) FastReadField9(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Visible = v

	}
	return offset, nil
}

func (p *TColumn) FastReadField10(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.ChildrenColumn = make([]*TColumn, 0, size)
	for i := 0; i < size; i++ {
		_elem := NewTColumn()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.ChildrenColumn = append(p.ChildrenColumn, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TColumn) FastReadField11(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.ColUniqueId = v

	}
	return offset, nil
}

func (p *TColumn) FastReadField12(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.HasBitmapIndex = v

	}
	return offset, nil
}

func (p *TColumn) FastReadField13(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.HasNgramBfIndex = v

	}
	return offset, nil
}

func (p *TColumn) FastReadField14(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.GramSize = &v

	}
	return offset, nil
}

func (p *TColumn) FastReadField15(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.GramBfSize = &v

	}
	return offset, nil
}

func (p *TColumn) FastReadField16(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Aggregation = &v

	}
	return offset, nil
}

func (p *TColumn) FastReadField17(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.ResultIsNullable = &v

	}
	return offset, nil
}

func (p *TColumn) FastReadField18(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.IsAutoIncrement = v

	}
	return offset, nil
}

func (p *TColumn) FastReadField19(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.ClusterKeyId = v

	}
	return offset, nil
}

// for compatibility
func (p *TColumn) FastWrite(buf []byte) int {
	return 0
}

func (p *TColumn) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TColumn")
	if p != nil {
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField9(buf[offset:], binaryWriter)
		offset += p.fastWriteField11(buf[offset:], binaryWriter)
		offset += p.fastWriteField12(buf[offset:], binaryWriter)
		offset += p.fastWriteField13(buf[offset:], binaryWriter)
		offset += p.fastWriteField14(buf[offset:], binaryWriter)
		offset += p.fastWriteField15(buf[offset:], binaryWriter)
		offset += p.fastWriteField17(buf[offset:], binaryWriter)
		offset += p.fastWriteField18(buf[offset:], binaryWriter)
		offset += p.fastWriteField19(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
		offset += p.fastWriteField10(buf[offset:], binaryWriter)
		offset += p.fastWriteField16(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TColumn) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TColumn")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field9Length()
		l += p.field10Length()
		l += p.field11Length()
		l += p.field12Length()
		l += p.field13Length()
		l += p.field14Length()
		l += p.field15Length()
		l += p.field16Length()
		l += p.field17Length()
		l += p.field18Length()
		l += p.field19Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TColumn) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "column_name", thrift.STRING, 1)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.ColumnName)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TColumn) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "column_type", thrift.STRUCT, 2)
	offset += p.ColumnType.FastWriteNocopy(buf[offset:], binaryWriter)
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TColumn) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetAggregationType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "aggregation_type", thrift.I32, 3)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.AggregationType))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TColumn) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIsKey() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "is_key", thrift.BOOL, 4)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.IsKey)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TColumn) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIsAllowNull() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "is_allow_null", thrift.BOOL, 5)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.IsAllowNull)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TColumn) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDefaultValue() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "default_value", thrift.STRING, 6)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.DefaultValue)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TColumn) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIsBloomFilterColumn() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "is_bloom_filter_column", thrift.BOOL, 7)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.IsBloomFilterColumn)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TColumn) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDefineExpr() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "define_expr", thrift.STRUCT, 8)
		offset += p.DefineExpr.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TColumn) fastWriteField9(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetVisible() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "visible", thrift.BOOL, 9)
		offset += bthrift.Binary.WriteBool(buf[offset:], p.Visible)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TColumn) fastWriteField10(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetChildrenColumn() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "children_column", thrift.LIST, 10)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.ChildrenColumn {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TColumn) fastWriteField11(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetColUniqueId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "col_unique_id", thrift.I32, 11)
		offset += bthrift.Binary.WriteI32(buf[offset:], p.ColUniqueId)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TColumn) fastWriteField12(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetHasBitmapIndex() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "has_bitmap_index", thrift.BOOL, 12)
		offset += bthrift.Binary.WriteBool(buf[offset:], p.HasBitmapIndex)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TColumn) fastWriteField13(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetHasNgramBfIndex() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "has_ngram_bf_index", thrift.BOOL, 13)
		offset += bthrift.Binary.WriteBool(buf[offset:], p.HasNgramBfIndex)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TColumn) fastWriteField14(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetGramSize() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "gram_size", thrift.I32, 14)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.GramSize)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TColumn) fastWriteField15(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetGramBfSize() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "gram_bf_size", thrift.I32, 15)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.GramBfSize)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TColumn) fastWriteField16(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetAggregation() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "aggregation", thrift.STRING, 16)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Aggregation)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TColumn) fastWriteField17(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetResultIsNullable() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "result_is_nullable", thrift.BOOL, 17)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.ResultIsNullable)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TColumn) fastWriteField18(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIsAutoIncrement() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "is_auto_increment", thrift.BOOL, 18)
		offset += bthrift.Binary.WriteBool(buf[offset:], p.IsAutoIncrement)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TColumn) fastWriteField19(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetClusterKeyId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "cluster_key_id", thrift.I32, 19)
		offset += bthrift.Binary.WriteI32(buf[offset:], p.ClusterKeyId)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TColumn) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("column_name", thrift.STRING, 1)
	l += bthrift.Binary.StringLengthNocopy(p.ColumnName)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TColumn) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("column_type", thrift.STRUCT, 2)
	l += p.ColumnType.BLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TColumn) field3Length() int {
	l := 0
	if p.IsSetAggregationType() {
		l += bthrift.Binary.FieldBeginLength("aggregation_type", thrift.I32, 3)
		l += bthrift.Binary.I32Length(int32(*p.AggregationType))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TColumn) field4Length() int {
	l := 0
	if p.IsSetIsKey() {
		l += bthrift.Binary.FieldBeginLength("is_key", thrift.BOOL, 4)
		l += bthrift.Binary.BoolLength(*p.IsKey)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TColumn) field5Length() int {
	l := 0
	if p.IsSetIsAllowNull() {
		l += bthrift.Binary.FieldBeginLength("is_allow_null", thrift.BOOL, 5)
		l += bthrift.Binary.BoolLength(*p.IsAllowNull)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TColumn) field6Length() int {
	l := 0
	if p.IsSetDefaultValue() {
		l += bthrift.Binary.FieldBeginLength("default_value", thrift.STRING, 6)
		l += bthrift.Binary.StringLengthNocopy(*p.DefaultValue)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TColumn) field7Length() int {
	l := 0
	if p.IsSetIsBloomFilterColumn() {
		l += bthrift.Binary.FieldBeginLength("is_bloom_filter_column", thrift.BOOL, 7)
		l += bthrift.Binary.BoolLength(*p.IsBloomFilterColumn)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TColumn) field8Length() int {
	l := 0
	if p.IsSetDefineExpr() {
		l += bthrift.Binary.FieldBeginLength("define_expr", thrift.STRUCT, 8)
		l += p.DefineExpr.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TColumn) field9Length() int {
	l := 0
	if p.IsSetVisible() {
		l += bthrift.Binary.FieldBeginLength("visible", thrift.BOOL, 9)
		l += bthrift.Binary.BoolLength(p.Visible)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TColumn) field10Length() int {
	l := 0
	if p.IsSetChildrenColumn() {
		l += bthrift.Binary.FieldBeginLength("children_column", thrift.LIST, 10)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.ChildrenColumn))
		for _, v := range p.ChildrenColumn {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TColumn) field11Length() int {
	l := 0
	if p.IsSetColUniqueId() {
		l += bthrift.Binary.FieldBeginLength("col_unique_id", thrift.I32, 11)
		l += bthrift.Binary.I32Length(p.ColUniqueId)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TColumn) field12Length() int {
	l := 0
	if p.IsSetHasBitmapIndex() {
		l += bthrift.Binary.FieldBeginLength("has_bitmap_index", thrift.BOOL, 12)
		l += bthrift.Binary.BoolLength(p.HasBitmapIndex)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TColumn) field13Length() int {
	l := 0
	if p.IsSetHasNgramBfIndex() {
		l += bthrift.Binary.FieldBeginLength("has_ngram_bf_index", thrift.BOOL, 13)
		l += bthrift.Binary.BoolLength(p.HasNgramBfIndex)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TColumn) field14Length() int {
	l := 0
	if p.IsSetGramSize() {
		l += bthrift.Binary.FieldBeginLength("gram_size", thrift.I32, 14)
		l += bthrift.Binary.I32Length(*p.GramSize)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TColumn) field15Length() int {
	l := 0
	if p.IsSetGramBfSize() {
		l += bthrift.Binary.FieldBeginLength("gram_bf_size", thrift.I32, 15)
		l += bthrift.Binary.I32Length(*p.GramBfSize)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TColumn) field16Length() int {
	l := 0
	if p.IsSetAggregation() {
		l += bthrift.Binary.FieldBeginLength("aggregation", thrift.STRING, 16)
		l += bthrift.Binary.StringLengthNocopy(*p.Aggregation)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TColumn) field17Length() int {
	l := 0
	if p.IsSetResultIsNullable() {
		l += bthrift.Binary.FieldBeginLength("result_is_nullable", thrift.BOOL, 17)
		l += bthrift.Binary.BoolLength(*p.ResultIsNullable)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TColumn) field18Length() int {
	l := 0
	if p.IsSetIsAutoIncrement() {
		l += bthrift.Binary.FieldBeginLength("is_auto_increment", thrift.BOOL, 18)
		l += bthrift.Binary.BoolLength(p.IsAutoIncrement)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TColumn) field19Length() int {
	l := 0
	if p.IsSetClusterKeyId() {
		l += bthrift.Binary.FieldBeginLength("cluster_key_id", thrift.I32, 19)
		l += bthrift.Binary.I32Length(p.ClusterKeyId)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TSlotDescriptor) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetId bool = false
	var issetParent bool = false
	var issetSlotType bool = false
	var issetColumnPos bool = false
	var issetByteOffset bool = false
	var issetNullIndicatorByte bool = false
	var issetNullIndicatorBit bool = false
	var issetColName bool = false
	var issetSlotIdx bool = false
	var issetIsMaterialized bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetParent = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetSlotType = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetColumnPos = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetByteOffset = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetNullIndicatorByte = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetNullIndicatorBit = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetColName = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField9(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetSlotIdx = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetIsMaterialized = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 11:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField11(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 12:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField12(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 13:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField13(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 14:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField14(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 15:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField15(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 16:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField16(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 17:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField17(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetId {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetParent {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetSlotType {
		fieldId = 3
		goto RequiredFieldNotSetError
	}

	if !issetColumnPos {
		fieldId = 4
		goto RequiredFieldNotSetError
	}

	if !issetByteOffset {
		fieldId = 5
		goto RequiredFieldNotSetError
	}

	if !issetNullIndicatorByte {
		fieldId = 6
		goto RequiredFieldNotSetError
	}

	if !issetNullIndicatorBit {
		fieldId = 7
		goto RequiredFieldNotSetError
	}

	if !issetColName {
		fieldId = 8
		goto RequiredFieldNotSetError
	}

	if !issetSlotIdx {
		fieldId = 9
		goto RequiredFieldNotSetError
	}

	if !issetIsMaterialized {
		fieldId = 10
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TSlotDescriptor[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TSlotDescriptor[fieldId]))
}

func (p *TSlotDescriptor) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Id = v

	}
	return offset, nil
}

func (p *TSlotDescriptor) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Parent = v

	}
	return offset, nil
}

func (p *TSlotDescriptor) FastReadField3(buf []byte) (int, error) {
	offset := 0

	tmp := types.NewTTypeDesc()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.SlotType = tmp
	return offset, nil
}

func (p *TSlotDescriptor) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.ColumnPos = v

	}
	return offset, nil
}

func (p *TSlotDescriptor) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.ByteOffset = v

	}
	return offset, nil
}

func (p *TSlotDescriptor) FastReadField6(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.NullIndicatorByte = v

	}
	return offset, nil
}

func (p *TSlotDescriptor) FastReadField7(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.NullIndicatorBit = v

	}
	return offset, nil
}

func (p *TSlotDescriptor) FastReadField8(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.ColName = v

	}
	return offset, nil
}

func (p *TSlotDescriptor) FastReadField9(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.SlotIdx = v

	}
	return offset, nil
}

func (p *TSlotDescriptor) FastReadField10(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.IsMaterialized = v

	}
	return offset, nil
}

func (p *TSlotDescriptor) FastReadField11(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.ColUniqueId = v

	}
	return offset, nil
}

func (p *TSlotDescriptor) FastReadField12(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.IsKey = v

	}
	return offset, nil
}

func (p *TSlotDescriptor) FastReadField13(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.NeedMaterialize = v

	}
	return offset, nil
}

func (p *TSlotDescriptor) FastReadField14(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.IsAutoIncrement = v

	}
	return offset, nil
}

func (p *TSlotDescriptor) FastReadField15(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.ColumnPaths = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.ColumnPaths = append(p.ColumnPaths, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TSlotDescriptor) FastReadField16(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.ColDefaultValue = &v

	}
	return offset, nil
}

func (p *TSlotDescriptor) FastReadField17(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.PrimitiveType = types.TPrimitiveType(v)

	}
	return offset, nil
}

// for compatibility
func (p *TSlotDescriptor) FastWrite(buf []byte) int {
	return 0
}

func (p *TSlotDescriptor) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TSlotDescriptor")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField9(buf[offset:], binaryWriter)
		offset += p.fastWriteField10(buf[offset:], binaryWriter)
		offset += p.fastWriteField11(buf[offset:], binaryWriter)
		offset += p.fastWriteField12(buf[offset:], binaryWriter)
		offset += p.fastWriteField13(buf[offset:], binaryWriter)
		offset += p.fastWriteField14(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
		offset += p.fastWriteField15(buf[offset:], binaryWriter)
		offset += p.fastWriteField16(buf[offset:], binaryWriter)
		offset += p.fastWriteField17(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TSlotDescriptor) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TSlotDescriptor")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field9Length()
		l += p.field10Length()
		l += p.field11Length()
		l += p.field12Length()
		l += p.field13Length()
		l += p.field14Length()
		l += p.field15Length()
		l += p.field16Length()
		l += p.field17Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TSlotDescriptor) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "id", thrift.I32, 1)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.Id)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TSlotDescriptor) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "parent", thrift.I32, 2)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.Parent)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TSlotDescriptor) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "slotType", thrift.STRUCT, 3)
	offset += p.SlotType.FastWriteNocopy(buf[offset:], binaryWriter)
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TSlotDescriptor) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "columnPos", thrift.I32, 4)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.ColumnPos)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TSlotDescriptor) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "byteOffset", thrift.I32, 5)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.ByteOffset)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TSlotDescriptor) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "nullIndicatorByte", thrift.I32, 6)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.NullIndicatorByte)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TSlotDescriptor) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "nullIndicatorBit", thrift.I32, 7)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.NullIndicatorBit)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TSlotDescriptor) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "colName", thrift.STRING, 8)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.ColName)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TSlotDescriptor) fastWriteField9(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "slotIdx", thrift.I32, 9)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.SlotIdx)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TSlotDescriptor) fastWriteField10(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "isMaterialized", thrift.BOOL, 10)
	offset += bthrift.Binary.WriteBool(buf[offset:], p.IsMaterialized)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TSlotDescriptor) fastWriteField11(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetColUniqueId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "col_unique_id", thrift.I32, 11)
		offset += bthrift.Binary.WriteI32(buf[offset:], p.ColUniqueId)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TSlotDescriptor) fastWriteField12(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIsKey() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "is_key", thrift.BOOL, 12)
		offset += bthrift.Binary.WriteBool(buf[offset:], p.IsKey)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TSlotDescriptor) fastWriteField13(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetNeedMaterialize() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "need_materialize", thrift.BOOL, 13)
		offset += bthrift.Binary.WriteBool(buf[offset:], p.NeedMaterialize)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TSlotDescriptor) fastWriteField14(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIsAutoIncrement() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "is_auto_increment", thrift.BOOL, 14)
		offset += bthrift.Binary.WriteBool(buf[offset:], p.IsAutoIncrement)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TSlotDescriptor) fastWriteField15(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetColumnPaths() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "column_paths", thrift.LIST, 15)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRING, 0)
		var length int
		for _, v := range p.ColumnPaths {
			length++
			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRING, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TSlotDescriptor) fastWriteField16(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetColDefaultValue() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "col_default_value", thrift.STRING, 16)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.ColDefaultValue)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TSlotDescriptor) fastWriteField17(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPrimitiveType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "primitive_type", thrift.I32, 17)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(p.PrimitiveType))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TSlotDescriptor) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("id", thrift.I32, 1)
	l += bthrift.Binary.I32Length(p.Id)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TSlotDescriptor) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("parent", thrift.I32, 2)
	l += bthrift.Binary.I32Length(p.Parent)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TSlotDescriptor) field3Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("slotType", thrift.STRUCT, 3)
	l += p.SlotType.BLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TSlotDescriptor) field4Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("columnPos", thrift.I32, 4)
	l += bthrift.Binary.I32Length(p.ColumnPos)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TSlotDescriptor) field5Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("byteOffset", thrift.I32, 5)
	l += bthrift.Binary.I32Length(p.ByteOffset)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TSlotDescriptor) field6Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("nullIndicatorByte", thrift.I32, 6)
	l += bthrift.Binary.I32Length(p.NullIndicatorByte)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TSlotDescriptor) field7Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("nullIndicatorBit", thrift.I32, 7)
	l += bthrift.Binary.I32Length(p.NullIndicatorBit)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TSlotDescriptor) field8Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("colName", thrift.STRING, 8)
	l += bthrift.Binary.StringLengthNocopy(p.ColName)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TSlotDescriptor) field9Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("slotIdx", thrift.I32, 9)
	l += bthrift.Binary.I32Length(p.SlotIdx)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TSlotDescriptor) field10Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("isMaterialized", thrift.BOOL, 10)
	l += bthrift.Binary.BoolLength(p.IsMaterialized)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TSlotDescriptor) field11Length() int {
	l := 0
	if p.IsSetColUniqueId() {
		l += bthrift.Binary.FieldBeginLength("col_unique_id", thrift.I32, 11)
		l += bthrift.Binary.I32Length(p.ColUniqueId)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TSlotDescriptor) field12Length() int {
	l := 0
	if p.IsSetIsKey() {
		l += bthrift.Binary.FieldBeginLength("is_key", thrift.BOOL, 12)
		l += bthrift.Binary.BoolLength(p.IsKey)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TSlotDescriptor) field13Length() int {
	l := 0
	if p.IsSetNeedMaterialize() {
		l += bthrift.Binary.FieldBeginLength("need_materialize", thrift.BOOL, 13)
		l += bthrift.Binary.BoolLength(p.NeedMaterialize)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TSlotDescriptor) field14Length() int {
	l := 0
	if p.IsSetIsAutoIncrement() {
		l += bthrift.Binary.FieldBeginLength("is_auto_increment", thrift.BOOL, 14)
		l += bthrift.Binary.BoolLength(p.IsAutoIncrement)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TSlotDescriptor) field15Length() int {
	l := 0
	if p.IsSetColumnPaths() {
		l += bthrift.Binary.FieldBeginLength("column_paths", thrift.LIST, 15)
		l += bthrift.Binary.ListBeginLength(thrift.STRING, len(p.ColumnPaths))
		for _, v := range p.ColumnPaths {
			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TSlotDescriptor) field16Length() int {
	l := 0
	if p.IsSetColDefaultValue() {
		l += bthrift.Binary.FieldBeginLength("col_default_value", thrift.STRING, 16)
		l += bthrift.Binary.StringLengthNocopy(*p.ColDefaultValue)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TSlotDescriptor) field17Length() int {
	l := 0
	if p.IsSetPrimitiveType() {
		l += bthrift.Binary.FieldBeginLength("primitive_type", thrift.I32, 17)
		l += bthrift.Binary.I32Length(int32(p.PrimitiveType))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTupleDescriptor) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetId bool = false
	var issetByteSize bool = false
	var issetNumNullBytes bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetByteSize = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetNumNullBytes = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetId {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetByteSize {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetNumNullBytes {
		fieldId = 3
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TTupleDescriptor[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TTupleDescriptor[fieldId]))
}

func (p *TTupleDescriptor) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Id = v

	}
	return offset, nil
}

func (p *TTupleDescriptor) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.ByteSize = v

	}
	return offset, nil
}

func (p *TTupleDescriptor) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.NumNullBytes = v

	}
	return offset, nil
}

func (p *TTupleDescriptor) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.TableId = &v

	}
	return offset, nil
}

func (p *TTupleDescriptor) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.NumNullSlots = &v

	}
	return offset, nil
}

// for compatibility
func (p *TTupleDescriptor) FastWrite(buf []byte) int {
	return 0
}

func (p *TTupleDescriptor) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TTupleDescriptor")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TTupleDescriptor) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TTupleDescriptor")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TTupleDescriptor) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "id", thrift.I32, 1)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.Id)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TTupleDescriptor) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "byteSize", thrift.I32, 2)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.ByteSize)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TTupleDescriptor) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "numNullBytes", thrift.I32, 3)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.NumNullBytes)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TTupleDescriptor) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTableId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tableId", thrift.I64, 4)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.TableId)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTupleDescriptor) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetNumNullSlots() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "numNullSlots", thrift.I32, 5)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.NumNullSlots)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTupleDescriptor) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("id", thrift.I32, 1)
	l += bthrift.Binary.I32Length(p.Id)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TTupleDescriptor) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("byteSize", thrift.I32, 2)
	l += bthrift.Binary.I32Length(p.ByteSize)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TTupleDescriptor) field3Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("numNullBytes", thrift.I32, 3)
	l += bthrift.Binary.I32Length(p.NumNullBytes)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TTupleDescriptor) field4Length() int {
	l := 0
	if p.IsSetTableId() {
		l += bthrift.Binary.FieldBeginLength("tableId", thrift.I64, 4)
		l += bthrift.Binary.I64Length(*p.TableId)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTupleDescriptor) field5Length() int {
	l := 0
	if p.IsSetNumNullSlots() {
		l += bthrift.Binary.FieldBeginLength("numNullSlots", thrift.I32, 5)
		l += bthrift.Binary.I32Length(*p.NumNullSlots)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTableIndexTablets) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetIndexId bool = false
	var issetTablets bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetIndexId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetTablets = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetIndexId {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetTablets {
		fieldId = 2
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TOlapTableIndexTablets[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TOlapTableIndexTablets[fieldId]))
}

func (p *TOlapTableIndexTablets) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.IndexId = v

	}
	return offset, nil
}

func (p *TOlapTableIndexTablets) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Tablets = make([]int64, 0, size)
	for i := 0; i < size; i++ {
		var _elem int64
		if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.Tablets = append(p.Tablets, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

// for compatibility
func (p *TOlapTableIndexTablets) FastWrite(buf []byte) int {
	return 0
}

func (p *TOlapTableIndexTablets) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TOlapTableIndexTablets")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TOlapTableIndexTablets) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TOlapTableIndexTablets")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TOlapTableIndexTablets) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "index_id", thrift.I64, 1)
	offset += bthrift.Binary.WriteI64(buf[offset:], p.IndexId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapTableIndexTablets) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tablets", thrift.LIST, 2)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.I64, 0)
	var length int
	for _, v := range p.Tablets {
		length++
		offset += bthrift.Binary.WriteI64(buf[offset:], v)

	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.I64, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapTableIndexTablets) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("index_id", thrift.I64, 1)
	l += bthrift.Binary.I64Length(p.IndexId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapTableIndexTablets) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("tablets", thrift.LIST, 2)
	l += bthrift.Binary.ListBeginLength(thrift.I64, len(p.Tablets))
	var tmpV int64
	l += bthrift.Binary.I64Length(int64(tmpV)) * len(p.Tablets)
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapTablePartition) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetId bool = false
	var issetNumBuckets bool = false
	var issetIndexes bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetNumBuckets = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetIndexes = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField9(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 11:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField11(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetId {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetNumBuckets {
		fieldId = 4
		goto RequiredFieldNotSetError
	}

	if !issetIndexes {
		fieldId = 5
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TOlapTablePartition[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TOlapTablePartition[fieldId]))
}

func (p *TOlapTablePartition) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Id = v

	}
	return offset, nil
}

func (p *TOlapTablePartition) FastReadField2(buf []byte) (int, error) {
	offset := 0

	tmp := exprs.NewTExprNode()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.StartKey = tmp
	return offset, nil
}

func (p *TOlapTablePartition) FastReadField3(buf []byte) (int, error) {
	offset := 0

	tmp := exprs.NewTExprNode()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.EndKey = tmp
	return offset, nil
}

func (p *TOlapTablePartition) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.NumBuckets = v

	}
	return offset, nil
}

func (p *TOlapTablePartition) FastReadField5(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Indexes = make([]*TOlapTableIndexTablets, 0, size)
	for i := 0; i < size; i++ {
		_elem := NewTOlapTableIndexTablets()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.Indexes = append(p.Indexes, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TOlapTablePartition) FastReadField6(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.StartKeys = make([]*exprs.TExprNode, 0, size)
	for i := 0; i < size; i++ {
		_elem := exprs.NewTExprNode()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.StartKeys = append(p.StartKeys, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TOlapTablePartition) FastReadField7(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.EndKeys = make([]*exprs.TExprNode, 0, size)
	for i := 0; i < size; i++ {
		_elem := exprs.NewTExprNode()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.EndKeys = append(p.EndKeys, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TOlapTablePartition) FastReadField8(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.InKeys = make([][]*exprs.TExprNode, 0, size)
	for i := 0; i < size; i++ {
		_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
		offset += l
		if err != nil {
			return offset, err
		}
		_elem := make([]*exprs.TExprNode, 0, size)
		for i := 0; i < size; i++ {
			_elem1 := exprs.NewTExprNode()
			if l, err := _elem1.FastRead(buf[offset:]); err != nil {
				return offset, err
			} else {
				offset += l
			}

			_elem = append(_elem, _elem1)
		}
		if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.InKeys = append(p.InKeys, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TOlapTablePartition) FastReadField9(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.IsMutable = v

	}
	return offset, nil
}

func (p *TOlapTablePartition) FastReadField10(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.IsDefaultPartition = &v

	}
	return offset, nil
}

func (p *TOlapTablePartition) FastReadField11(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.LoadTabletIdx = &v

	}
	return offset, nil
}

// for compatibility
func (p *TOlapTablePartition) FastWrite(buf []byte) int {
	return 0
}

func (p *TOlapTablePartition) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TOlapTablePartition")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField9(buf[offset:], binaryWriter)
		offset += p.fastWriteField10(buf[offset:], binaryWriter)
		offset += p.fastWriteField11(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TOlapTablePartition) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TOlapTablePartition")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field9Length()
		l += p.field10Length()
		l += p.field11Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TOlapTablePartition) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "id", thrift.I64, 1)
	offset += bthrift.Binary.WriteI64(buf[offset:], p.Id)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapTablePartition) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetStartKey() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "start_key", thrift.STRUCT, 2)
		offset += p.StartKey.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTablePartition) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetEndKey() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "end_key", thrift.STRUCT, 3)
		offset += p.EndKey.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTablePartition) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "num_buckets", thrift.I32, 4)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.NumBuckets)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapTablePartition) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "indexes", thrift.LIST, 5)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
	var length int
	for _, v := range p.Indexes {
		length++
		offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapTablePartition) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetStartKeys() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "start_keys", thrift.LIST, 6)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.StartKeys {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTablePartition) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetEndKeys() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "end_keys", thrift.LIST, 7)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.EndKeys {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTablePartition) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetInKeys() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "in_keys", thrift.LIST, 8)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.LIST, 0)
		var length int
		for _, v := range p.InKeys {
			length++
			listBeginOffset := offset
			offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
			var length int
			for _, v := range v {
				length++
				offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
			}
			bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
			offset += bthrift.Binary.WriteListEnd(buf[offset:])
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.LIST, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTablePartition) fastWriteField9(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIsMutable() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "is_mutable", thrift.BOOL, 9)
		offset += bthrift.Binary.WriteBool(buf[offset:], p.IsMutable)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTablePartition) fastWriteField10(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIsDefaultPartition() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "is_default_partition", thrift.BOOL, 10)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.IsDefaultPartition)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTablePartition) fastWriteField11(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetLoadTabletIdx() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "load_tablet_idx", thrift.I64, 11)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.LoadTabletIdx)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTablePartition) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("id", thrift.I64, 1)
	l += bthrift.Binary.I64Length(p.Id)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapTablePartition) field2Length() int {
	l := 0
	if p.IsSetStartKey() {
		l += bthrift.Binary.FieldBeginLength("start_key", thrift.STRUCT, 2)
		l += p.StartKey.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTablePartition) field3Length() int {
	l := 0
	if p.IsSetEndKey() {
		l += bthrift.Binary.FieldBeginLength("end_key", thrift.STRUCT, 3)
		l += p.EndKey.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTablePartition) field4Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("num_buckets", thrift.I32, 4)
	l += bthrift.Binary.I32Length(p.NumBuckets)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapTablePartition) field5Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("indexes", thrift.LIST, 5)
	l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.Indexes))
	for _, v := range p.Indexes {
		l += v.BLength()
	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapTablePartition) field6Length() int {
	l := 0
	if p.IsSetStartKeys() {
		l += bthrift.Binary.FieldBeginLength("start_keys", thrift.LIST, 6)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.StartKeys))
		for _, v := range p.StartKeys {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTablePartition) field7Length() int {
	l := 0
	if p.IsSetEndKeys() {
		l += bthrift.Binary.FieldBeginLength("end_keys", thrift.LIST, 7)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.EndKeys))
		for _, v := range p.EndKeys {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTablePartition) field8Length() int {
	l := 0
	if p.IsSetInKeys() {
		l += bthrift.Binary.FieldBeginLength("in_keys", thrift.LIST, 8)
		l += bthrift.Binary.ListBeginLength(thrift.LIST, len(p.InKeys))
		for _, v := range p.InKeys {
			l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(v))
			for _, v := range v {
				l += v.BLength()
			}
			l += bthrift.Binary.ListEndLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTablePartition) field9Length() int {
	l := 0
	if p.IsSetIsMutable() {
		l += bthrift.Binary.FieldBeginLength("is_mutable", thrift.BOOL, 9)
		l += bthrift.Binary.BoolLength(p.IsMutable)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTablePartition) field10Length() int {
	l := 0
	if p.IsSetIsDefaultPartition() {
		l += bthrift.Binary.FieldBeginLength("is_default_partition", thrift.BOOL, 10)
		l += bthrift.Binary.BoolLength(*p.IsDefaultPartition)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTablePartition) field11Length() int {
	l := 0
	if p.IsSetLoadTabletIdx() {
		l += bthrift.Binary.FieldBeginLength("load_tablet_idx", thrift.I64, 11)
		l += bthrift.Binary.I64Length(*p.LoadTabletIdx)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTablePartitionParam) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetDbId bool = false
	var issetTableId bool = false
	var issetVersion bool = false
	var issetPartitions bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetDbId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetTableId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetVersion = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetPartitions = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField9(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetDbId {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetTableId {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetVersion {
		fieldId = 3
		goto RequiredFieldNotSetError
	}

	if !issetPartitions {
		fieldId = 6
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TOlapTablePartitionParam[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TOlapTablePartitionParam[fieldId]))
}

func (p *TOlapTablePartitionParam) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.DbId = v

	}
	return offset, nil
}

func (p *TOlapTablePartitionParam) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.TableId = v

	}
	return offset, nil
}

func (p *TOlapTablePartitionParam) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Version = v

	}
	return offset, nil
}

func (p *TOlapTablePartitionParam) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.PartitionColumn = &v

	}
	return offset, nil
}

func (p *TOlapTablePartitionParam) FastReadField5(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.DistributedColumns = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.DistributedColumns = append(p.DistributedColumns, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TOlapTablePartitionParam) FastReadField6(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Partitions = make([]*TOlapTablePartition, 0, size)
	for i := 0; i < size; i++ {
		_elem := NewTOlapTablePartition()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.Partitions = append(p.Partitions, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TOlapTablePartitionParam) FastReadField7(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.PartitionColumns = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.PartitionColumns = append(p.PartitionColumns, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TOlapTablePartitionParam) FastReadField8(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.PartitionFunctionExprs = make([]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_elem := exprs.NewTExpr()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.PartitionFunctionExprs = append(p.PartitionFunctionExprs, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TOlapTablePartitionParam) FastReadField9(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.EnableAutomaticPartition = &v

	}
	return offset, nil
}

func (p *TOlapTablePartitionParam) FastReadField10(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := partitions.TPartitionType(v)
		p.PartitionType = &tmp

	}
	return offset, nil
}

// for compatibility
func (p *TOlapTablePartitionParam) FastWrite(buf []byte) int {
	return 0
}

func (p *TOlapTablePartitionParam) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TOlapTablePartitionParam")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField9(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
		offset += p.fastWriteField10(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TOlapTablePartitionParam) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TOlapTablePartitionParam")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field9Length()
		l += p.field10Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TOlapTablePartitionParam) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "db_id", thrift.I64, 1)
	offset += bthrift.Binary.WriteI64(buf[offset:], p.DbId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapTablePartitionParam) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "table_id", thrift.I64, 2)
	offset += bthrift.Binary.WriteI64(buf[offset:], p.TableId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapTablePartitionParam) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "version", thrift.I64, 3)
	offset += bthrift.Binary.WriteI64(buf[offset:], p.Version)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapTablePartitionParam) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPartitionColumn() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "partition_column", thrift.STRING, 4)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.PartitionColumn)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTablePartitionParam) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDistributedColumns() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "distributed_columns", thrift.LIST, 5)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRING, 0)
		var length int
		for _, v := range p.DistributedColumns {
			length++
			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRING, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTablePartitionParam) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "partitions", thrift.LIST, 6)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
	var length int
	for _, v := range p.Partitions {
		length++
		offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapTablePartitionParam) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPartitionColumns() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "partition_columns", thrift.LIST, 7)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRING, 0)
		var length int
		for _, v := range p.PartitionColumns {
			length++
			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRING, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTablePartitionParam) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPartitionFunctionExprs() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "partition_function_exprs", thrift.LIST, 8)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.PartitionFunctionExprs {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTablePartitionParam) fastWriteField9(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetEnableAutomaticPartition() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "enable_automatic_partition", thrift.BOOL, 9)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.EnableAutomaticPartition)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTablePartitionParam) fastWriteField10(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPartitionType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "partition_type", thrift.I32, 10)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.PartitionType))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTablePartitionParam) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("db_id", thrift.I64, 1)
	l += bthrift.Binary.I64Length(p.DbId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapTablePartitionParam) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("table_id", thrift.I64, 2)
	l += bthrift.Binary.I64Length(p.TableId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapTablePartitionParam) field3Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("version", thrift.I64, 3)
	l += bthrift.Binary.I64Length(p.Version)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapTablePartitionParam) field4Length() int {
	l := 0
	if p.IsSetPartitionColumn() {
		l += bthrift.Binary.FieldBeginLength("partition_column", thrift.STRING, 4)
		l += bthrift.Binary.StringLengthNocopy(*p.PartitionColumn)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTablePartitionParam) field5Length() int {
	l := 0
	if p.IsSetDistributedColumns() {
		l += bthrift.Binary.FieldBeginLength("distributed_columns", thrift.LIST, 5)
		l += bthrift.Binary.ListBeginLength(thrift.STRING, len(p.DistributedColumns))
		for _, v := range p.DistributedColumns {
			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTablePartitionParam) field6Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("partitions", thrift.LIST, 6)
	l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.Partitions))
	for _, v := range p.Partitions {
		l += v.BLength()
	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapTablePartitionParam) field7Length() int {
	l := 0
	if p.IsSetPartitionColumns() {
		l += bthrift.Binary.FieldBeginLength("partition_columns", thrift.LIST, 7)
		l += bthrift.Binary.ListBeginLength(thrift.STRING, len(p.PartitionColumns))
		for _, v := range p.PartitionColumns {
			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTablePartitionParam) field8Length() int {
	l := 0
	if p.IsSetPartitionFunctionExprs() {
		l += bthrift.Binary.FieldBeginLength("partition_function_exprs", thrift.LIST, 8)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.PartitionFunctionExprs))
		for _, v := range p.PartitionFunctionExprs {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTablePartitionParam) field9Length() int {
	l := 0
	if p.IsSetEnableAutomaticPartition() {
		l += bthrift.Binary.FieldBeginLength("enable_automatic_partition", thrift.BOOL, 9)
		l += bthrift.Binary.BoolLength(*p.EnableAutomaticPartition)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTablePartitionParam) field10Length() int {
	l := 0
	if p.IsSetPartitionType() {
		l += bthrift.Binary.FieldBeginLength("partition_type", thrift.I32, 10)
		l += bthrift.Binary.I32Length(int32(*p.PartitionType))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTableIndex) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TOlapTableIndex[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TOlapTableIndex) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.IndexName = &v

	}
	return offset, nil
}

func (p *TOlapTableIndex) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Columns = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.Columns = append(p.Columns, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TOlapTableIndex) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := TIndexType(v)
		p.IndexType = &tmp

	}
	return offset, nil
}

func (p *TOlapTableIndex) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Comment = &v

	}
	return offset, nil
}

func (p *TOlapTableIndex) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.IndexId = &v

	}
	return offset, nil
}

func (p *TOlapTableIndex) FastReadField6(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := bthrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Properties = make(map[string]string, size)
	for i := 0; i < size; i++ {
		var _key string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_key = v

		}

		var _val string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_val = v

		}

		p.Properties[_key] = _val
	}
	if l, err := bthrift.Binary.ReadMapEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

// for compatibility
func (p *TOlapTableIndex) FastWrite(buf []byte) int {
	return 0
}

func (p *TOlapTableIndex) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TOlapTableIndex")
	if p != nil {
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TOlapTableIndex) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TOlapTableIndex")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TOlapTableIndex) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIndexName() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "index_name", thrift.STRING, 1)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.IndexName)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTableIndex) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetColumns() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "columns", thrift.LIST, 2)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRING, 0)
		var length int
		for _, v := range p.Columns {
			length++
			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRING, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTableIndex) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIndexType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "index_type", thrift.I32, 3)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.IndexType))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTableIndex) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetComment() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "comment", thrift.STRING, 4)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Comment)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTableIndex) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIndexId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "index_id", thrift.I64, 5)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.IndexId)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTableIndex) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetProperties() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "properties", thrift.MAP, 6)
		mapBeginOffset := offset
		offset += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRING, 0)
		var length int
		for k, v := range p.Properties {
			length++

			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, k)

			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.STRING, thrift.STRING, length)
		offset += bthrift.Binary.WriteMapEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTableIndex) field1Length() int {
	l := 0
	if p.IsSetIndexName() {
		l += bthrift.Binary.FieldBeginLength("index_name", thrift.STRING, 1)
		l += bthrift.Binary.StringLengthNocopy(*p.IndexName)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTableIndex) field2Length() int {
	l := 0
	if p.IsSetColumns() {
		l += bthrift.Binary.FieldBeginLength("columns", thrift.LIST, 2)
		l += bthrift.Binary.ListBeginLength(thrift.STRING, len(p.Columns))
		for _, v := range p.Columns {
			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTableIndex) field3Length() int {
	l := 0
	if p.IsSetIndexType() {
		l += bthrift.Binary.FieldBeginLength("index_type", thrift.I32, 3)
		l += bthrift.Binary.I32Length(int32(*p.IndexType))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTableIndex) field4Length() int {
	l := 0
	if p.IsSetComment() {
		l += bthrift.Binary.FieldBeginLength("comment", thrift.STRING, 4)
		l += bthrift.Binary.StringLengthNocopy(*p.Comment)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTableIndex) field5Length() int {
	l := 0
	if p.IsSetIndexId() {
		l += bthrift.Binary.FieldBeginLength("index_id", thrift.I64, 5)
		l += bthrift.Binary.I64Length(*p.IndexId)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTableIndex) field6Length() int {
	l := 0
	if p.IsSetProperties() {
		l += bthrift.Binary.FieldBeginLength("properties", thrift.MAP, 6)
		l += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRING, len(p.Properties))
		for k, v := range p.Properties {

			l += bthrift.Binary.StringLengthNocopy(k)

			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.MapEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTableIndexSchema) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetId bool = false
	var issetColumns bool = false
	var issetSchemaHash bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetColumns = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetSchemaHash = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetId {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetColumns {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetSchemaHash {
		fieldId = 3
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TOlapTableIndexSchema[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TOlapTableIndexSchema[fieldId]))
}

func (p *TOlapTableIndexSchema) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Id = v

	}
	return offset, nil
}

func (p *TOlapTableIndexSchema) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Columns = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.Columns = append(p.Columns, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TOlapTableIndexSchema) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.SchemaHash = v

	}
	return offset, nil
}

func (p *TOlapTableIndexSchema) FastReadField4(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.ColumnsDesc = make([]*TColumn, 0, size)
	for i := 0; i < size; i++ {
		_elem := NewTColumn()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.ColumnsDesc = append(p.ColumnsDesc, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TOlapTableIndexSchema) FastReadField5(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.IndexesDesc = make([]*TOlapTableIndex, 0, size)
	for i := 0; i < size; i++ {
		_elem := NewTOlapTableIndex()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.IndexesDesc = append(p.IndexesDesc, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TOlapTableIndexSchema) FastReadField6(buf []byte) (int, error) {
	offset := 0

	tmp := exprs.NewTExpr()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.WhereClause = tmp
	return offset, nil
}

// for compatibility
func (p *TOlapTableIndexSchema) FastWrite(buf []byte) int {
	return 0
}

func (p *TOlapTableIndexSchema) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TOlapTableIndexSchema")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TOlapTableIndexSchema) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TOlapTableIndexSchema")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TOlapTableIndexSchema) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "id", thrift.I64, 1)
	offset += bthrift.Binary.WriteI64(buf[offset:], p.Id)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapTableIndexSchema) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "columns", thrift.LIST, 2)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.STRING, 0)
	var length int
	for _, v := range p.Columns {
		length++
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRING, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapTableIndexSchema) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "schema_hash", thrift.I32, 3)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.SchemaHash)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapTableIndexSchema) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetColumnsDesc() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "columns_desc", thrift.LIST, 4)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.ColumnsDesc {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTableIndexSchema) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIndexesDesc() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "indexes_desc", thrift.LIST, 5)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.IndexesDesc {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTableIndexSchema) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetWhereClause() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "where_clause", thrift.STRUCT, 6)
		offset += p.WhereClause.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTableIndexSchema) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("id", thrift.I64, 1)
	l += bthrift.Binary.I64Length(p.Id)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapTableIndexSchema) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("columns", thrift.LIST, 2)
	l += bthrift.Binary.ListBeginLength(thrift.STRING, len(p.Columns))
	for _, v := range p.Columns {
		l += bthrift.Binary.StringLengthNocopy(v)

	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapTableIndexSchema) field3Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("schema_hash", thrift.I32, 3)
	l += bthrift.Binary.I32Length(p.SchemaHash)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapTableIndexSchema) field4Length() int {
	l := 0
	if p.IsSetColumnsDesc() {
		l += bthrift.Binary.FieldBeginLength("columns_desc", thrift.LIST, 4)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.ColumnsDesc))
		for _, v := range p.ColumnsDesc {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTableIndexSchema) field5Length() int {
	l := 0
	if p.IsSetIndexesDesc() {
		l += bthrift.Binary.FieldBeginLength("indexes_desc", thrift.LIST, 5)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.IndexesDesc))
		for _, v := range p.IndexesDesc {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTableIndexSchema) field6Length() int {
	l := 0
	if p.IsSetWhereClause() {
		l += bthrift.Binary.FieldBeginLength("where_clause", thrift.STRUCT, 6)
		l += p.WhereClause.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTableSchemaParam) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetDbId bool = false
	var issetTableId bool = false
	var issetVersion bool = false
	var issetSlotDescs bool = false
	var issetTupleDesc bool = false
	var issetIndexes bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetDbId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetTableId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetVersion = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetSlotDescs = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetTupleDesc = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetIndexes = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField9(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetDbId {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetTableId {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetVersion {
		fieldId = 3
		goto RequiredFieldNotSetError
	}

	if !issetSlotDescs {
		fieldId = 4
		goto RequiredFieldNotSetError
	}

	if !issetTupleDesc {
		fieldId = 5
		goto RequiredFieldNotSetError
	}

	if !issetIndexes {
		fieldId = 6
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TOlapTableSchemaParam[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TOlapTableSchemaParam[fieldId]))
}

func (p *TOlapTableSchemaParam) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.DbId = v

	}
	return offset, nil
}

func (p *TOlapTableSchemaParam) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.TableId = v

	}
	return offset, nil
}

func (p *TOlapTableSchemaParam) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Version = v

	}
	return offset, nil
}

func (p *TOlapTableSchemaParam) FastReadField4(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.SlotDescs = make([]*TSlotDescriptor, 0, size)
	for i := 0; i < size; i++ {
		_elem := NewTSlotDescriptor()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.SlotDescs = append(p.SlotDescs, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TOlapTableSchemaParam) FastReadField5(buf []byte) (int, error) {
	offset := 0

	tmp := NewTTupleDescriptor()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.TupleDesc = tmp
	return offset, nil
}

func (p *TOlapTableSchemaParam) FastReadField6(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Indexes = make([]*TOlapTableIndexSchema, 0, size)
	for i := 0; i < size; i++ {
		_elem := NewTOlapTableIndexSchema()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.Indexes = append(p.Indexes, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TOlapTableSchemaParam) FastReadField7(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.IsDynamicSchema = &v

	}
	return offset, nil
}

func (p *TOlapTableSchemaParam) FastReadField8(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.IsPartialUpdate = &v

	}
	return offset, nil
}

func (p *TOlapTableSchemaParam) FastReadField9(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.PartialUpdateInputColumns = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.PartialUpdateInputColumns = append(p.PartialUpdateInputColumns, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TOlapTableSchemaParam) FastReadField10(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.IsStrictMode = v

	}
	return offset, nil
}

// for compatibility
func (p *TOlapTableSchemaParam) FastWrite(buf []byte) int {
	return 0
}

func (p *TOlapTableSchemaParam) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TOlapTableSchemaParam")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
		offset += p.fastWriteField10(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField9(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TOlapTableSchemaParam) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TOlapTableSchemaParam")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field9Length()
		l += p.field10Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TOlapTableSchemaParam) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "db_id", thrift.I64, 1)
	offset += bthrift.Binary.WriteI64(buf[offset:], p.DbId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapTableSchemaParam) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "table_id", thrift.I64, 2)
	offset += bthrift.Binary.WriteI64(buf[offset:], p.TableId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapTableSchemaParam) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "version", thrift.I64, 3)
	offset += bthrift.Binary.WriteI64(buf[offset:], p.Version)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapTableSchemaParam) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "slot_descs", thrift.LIST, 4)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
	var length int
	for _, v := range p.SlotDescs {
		length++
		offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapTableSchemaParam) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tuple_desc", thrift.STRUCT, 5)
	offset += p.TupleDesc.FastWriteNocopy(buf[offset:], binaryWriter)
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapTableSchemaParam) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "indexes", thrift.LIST, 6)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
	var length int
	for _, v := range p.Indexes {
		length++
		offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapTableSchemaParam) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIsDynamicSchema() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "is_dynamic_schema", thrift.BOOL, 7)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.IsDynamicSchema)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTableSchemaParam) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIsPartialUpdate() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "is_partial_update", thrift.BOOL, 8)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.IsPartialUpdate)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTableSchemaParam) fastWriteField9(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPartialUpdateInputColumns() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "partial_update_input_columns", thrift.LIST, 9)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRING, 0)
		var length int
		for _, v := range p.PartialUpdateInputColumns {
			length++
			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRING, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTableSchemaParam) fastWriteField10(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIsStrictMode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "is_strict_mode", thrift.BOOL, 10)
		offset += bthrift.Binary.WriteBool(buf[offset:], p.IsStrictMode)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapTableSchemaParam) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("db_id", thrift.I64, 1)
	l += bthrift.Binary.I64Length(p.DbId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapTableSchemaParam) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("table_id", thrift.I64, 2)
	l += bthrift.Binary.I64Length(p.TableId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapTableSchemaParam) field3Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("version", thrift.I64, 3)
	l += bthrift.Binary.I64Length(p.Version)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapTableSchemaParam) field4Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("slot_descs", thrift.LIST, 4)
	l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.SlotDescs))
	for _, v := range p.SlotDescs {
		l += v.BLength()
	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapTableSchemaParam) field5Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("tuple_desc", thrift.STRUCT, 5)
	l += p.TupleDesc.BLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapTableSchemaParam) field6Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("indexes", thrift.LIST, 6)
	l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.Indexes))
	for _, v := range p.Indexes {
		l += v.BLength()
	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapTableSchemaParam) field7Length() int {
	l := 0
	if p.IsSetIsDynamicSchema() {
		l += bthrift.Binary.FieldBeginLength("is_dynamic_schema", thrift.BOOL, 7)
		l += bthrift.Binary.BoolLength(*p.IsDynamicSchema)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTableSchemaParam) field8Length() int {
	l := 0
	if p.IsSetIsPartialUpdate() {
		l += bthrift.Binary.FieldBeginLength("is_partial_update", thrift.BOOL, 8)
		l += bthrift.Binary.BoolLength(*p.IsPartialUpdate)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTableSchemaParam) field9Length() int {
	l := 0
	if p.IsSetPartialUpdateInputColumns() {
		l += bthrift.Binary.FieldBeginLength("partial_update_input_columns", thrift.LIST, 9)
		l += bthrift.Binary.ListBeginLength(thrift.STRING, len(p.PartialUpdateInputColumns))
		for _, v := range p.PartialUpdateInputColumns {
			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapTableSchemaParam) field10Length() int {
	l := 0
	if p.IsSetIsStrictMode() {
		l += bthrift.Binary.FieldBeginLength("is_strict_mode", thrift.BOOL, 10)
		l += bthrift.Binary.BoolLength(p.IsStrictMode)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTabletLocation) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetTabletId bool = false
	var issetNodeIds bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetTabletId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetNodeIds = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetTabletId {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetNodeIds {
		fieldId = 2
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TTabletLocation[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TTabletLocation[fieldId]))
}

func (p *TTabletLocation) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.TabletId = v

	}
	return offset, nil
}

func (p *TTabletLocation) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.NodeIds = make([]int64, 0, size)
	for i := 0; i < size; i++ {
		var _elem int64
		if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.NodeIds = append(p.NodeIds, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

// for compatibility
func (p *TTabletLocation) FastWrite(buf []byte) int {
	return 0
}

func (p *TTabletLocation) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TTabletLocation")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TTabletLocation) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TTabletLocation")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TTabletLocation) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tablet_id", thrift.I64, 1)
	offset += bthrift.Binary.WriteI64(buf[offset:], p.TabletId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TTabletLocation) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "node_ids", thrift.LIST, 2)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.I64, 0)
	var length int
	for _, v := range p.NodeIds {
		length++
		offset += bthrift.Binary.WriteI64(buf[offset:], v)

	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.I64, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TTabletLocation) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("tablet_id", thrift.I64, 1)
	l += bthrift.Binary.I64Length(p.TabletId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TTabletLocation) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("node_ids", thrift.LIST, 2)
	l += bthrift.Binary.ListBeginLength(thrift.I64, len(p.NodeIds))
	var tmpV int64
	l += bthrift.Binary.I64Length(int64(tmpV)) * len(p.NodeIds)
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapTableLocationParam) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetDbId bool = false
	var issetTableId bool = false
	var issetVersion bool = false
	var issetTablets bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetDbId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetTableId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetVersion = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetTablets = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetDbId {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetTableId {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetVersion {
		fieldId = 3
		goto RequiredFieldNotSetError
	}

	if !issetTablets {
		fieldId = 4
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TOlapTableLocationParam[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TOlapTableLocationParam[fieldId]))
}

func (p *TOlapTableLocationParam) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.DbId = v

	}
	return offset, nil
}

func (p *TOlapTableLocationParam) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.TableId = v

	}
	return offset, nil
}

func (p *TOlapTableLocationParam) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Version = v

	}
	return offset, nil
}

func (p *TOlapTableLocationParam) FastReadField4(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Tablets = make([]*TTabletLocation, 0, size)
	for i := 0; i < size; i++ {
		_elem := NewTTabletLocation()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.Tablets = append(p.Tablets, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

// for compatibility
func (p *TOlapTableLocationParam) FastWrite(buf []byte) int {
	return 0
}

func (p *TOlapTableLocationParam) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TOlapTableLocationParam")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TOlapTableLocationParam) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TOlapTableLocationParam")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TOlapTableLocationParam) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "db_id", thrift.I64, 1)
	offset += bthrift.Binary.WriteI64(buf[offset:], p.DbId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapTableLocationParam) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "table_id", thrift.I64, 2)
	offset += bthrift.Binary.WriteI64(buf[offset:], p.TableId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapTableLocationParam) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "version", thrift.I64, 3)
	offset += bthrift.Binary.WriteI64(buf[offset:], p.Version)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapTableLocationParam) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tablets", thrift.LIST, 4)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
	var length int
	for _, v := range p.Tablets {
		length++
		offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapTableLocationParam) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("db_id", thrift.I64, 1)
	l += bthrift.Binary.I64Length(p.DbId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapTableLocationParam) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("table_id", thrift.I64, 2)
	l += bthrift.Binary.I64Length(p.TableId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapTableLocationParam) field3Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("version", thrift.I64, 3)
	l += bthrift.Binary.I64Length(p.Version)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapTableLocationParam) field4Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("tablets", thrift.LIST, 4)
	l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.Tablets))
	for _, v := range p.Tablets {
		l += v.BLength()
	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TNodeInfo) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetId bool = false
	var issetOption bool = false
	var issetHost bool = false
	var issetAsyncInternalPort bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetOption = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetHost = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetAsyncInternalPort = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetId {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetOption {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetHost {
		fieldId = 3
		goto RequiredFieldNotSetError
	}

	if !issetAsyncInternalPort {
		fieldId = 4
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TNodeInfo[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TNodeInfo[fieldId]))
}

func (p *TNodeInfo) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Id = v

	}
	return offset, nil
}

func (p *TNodeInfo) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Option = v

	}
	return offset, nil
}

func (p *TNodeInfo) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Host = v

	}
	return offset, nil
}

func (p *TNodeInfo) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.AsyncInternalPort = v

	}
	return offset, nil
}

// for compatibility
func (p *TNodeInfo) FastWrite(buf []byte) int {
	return 0
}

func (p *TNodeInfo) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TNodeInfo")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TNodeInfo) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TNodeInfo")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TNodeInfo) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "id", thrift.I64, 1)
	offset += bthrift.Binary.WriteI64(buf[offset:], p.Id)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TNodeInfo) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "option", thrift.I64, 2)
	offset += bthrift.Binary.WriteI64(buf[offset:], p.Option)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TNodeInfo) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "host", thrift.STRING, 3)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.Host)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TNodeInfo) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "async_internal_port", thrift.I32, 4)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.AsyncInternalPort)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TNodeInfo) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("id", thrift.I64, 1)
	l += bthrift.Binary.I64Length(p.Id)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TNodeInfo) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("option", thrift.I64, 2)
	l += bthrift.Binary.I64Length(p.Option)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TNodeInfo) field3Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("host", thrift.STRING, 3)
	l += bthrift.Binary.StringLengthNocopy(p.Host)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TNodeInfo) field4Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("async_internal_port", thrift.I32, 4)
	l += bthrift.Binary.I32Length(p.AsyncInternalPort)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TPaloNodesInfo) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetVersion bool = false
	var issetNodes bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetVersion = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetNodes = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetVersion {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetNodes {
		fieldId = 2
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TPaloNodesInfo[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TPaloNodesInfo[fieldId]))
}

func (p *TPaloNodesInfo) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Version = v

	}
	return offset, nil
}

func (p *TPaloNodesInfo) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Nodes = make([]*TNodeInfo, 0, size)
	for i := 0; i < size; i++ {
		_elem := NewTNodeInfo()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.Nodes = append(p.Nodes, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

// for compatibility
func (p *TPaloNodesInfo) FastWrite(buf []byte) int {
	return 0
}

func (p *TPaloNodesInfo) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TPaloNodesInfo")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TPaloNodesInfo) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TPaloNodesInfo")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TPaloNodesInfo) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "version", thrift.I64, 1)
	offset += bthrift.Binary.WriteI64(buf[offset:], p.Version)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TPaloNodesInfo) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "nodes", thrift.LIST, 2)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
	var length int
	for _, v := range p.Nodes {
		length++
		offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TPaloNodesInfo) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("version", thrift.I64, 1)
	l += bthrift.Binary.I64Length(p.Version)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TPaloNodesInfo) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("nodes", thrift.LIST, 2)
	l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.Nodes))
	for _, v := range p.Nodes {
		l += v.BLength()
	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapTable) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetTableName bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetTableName = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetTableName {
		fieldId = 1
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TOlapTable[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TOlapTable[fieldId]))
}

func (p *TOlapTable) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.TableName = v

	}
	return offset, nil
}

// for compatibility
func (p *TOlapTable) FastWrite(buf []byte) int {
	return 0
}

func (p *TOlapTable) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TOlapTable")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TOlapTable) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TOlapTable")
	if p != nil {
		l += p.field1Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TOlapTable) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tableName", thrift.STRING, 1)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.TableName)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapTable) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("tableName", thrift.STRING, 1)
	l += bthrift.Binary.StringLengthNocopy(p.TableName)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TMySQLTable) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetHost bool = false
	var issetPort bool = false
	var issetUser bool = false
	var issetPasswd bool = false
	var issetDb bool = false
	var issetTable bool = false
	var issetCharset bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetHost = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetPort = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetUser = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetPasswd = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetDb = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetTable = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetCharset = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetHost {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetPort {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetUser {
		fieldId = 3
		goto RequiredFieldNotSetError
	}

	if !issetPasswd {
		fieldId = 4
		goto RequiredFieldNotSetError
	}

	if !issetDb {
		fieldId = 5
		goto RequiredFieldNotSetError
	}

	if !issetTable {
		fieldId = 6
		goto RequiredFieldNotSetError
	}

	if !issetCharset {
		fieldId = 7
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TMySQLTable[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TMySQLTable[fieldId]))
}

func (p *TMySQLTable) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Host = v

	}
	return offset, nil
}

func (p *TMySQLTable) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Port = v

	}
	return offset, nil
}

func (p *TMySQLTable) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.User = v

	}
	return offset, nil
}

func (p *TMySQLTable) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Passwd = v

	}
	return offset, nil
}

func (p *TMySQLTable) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Db = v

	}
	return offset, nil
}

func (p *TMySQLTable) FastReadField6(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Table = v

	}
	return offset, nil
}

func (p *TMySQLTable) FastReadField7(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Charset = v

	}
	return offset, nil
}

// for compatibility
func (p *TMySQLTable) FastWrite(buf []byte) int {
	return 0
}

func (p *TMySQLTable) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TMySQLTable")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TMySQLTable) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TMySQLTable")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TMySQLTable) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "host", thrift.STRING, 1)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.Host)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TMySQLTable) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "port", thrift.STRING, 2)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.Port)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TMySQLTable) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "user", thrift.STRING, 3)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.User)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TMySQLTable) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "passwd", thrift.STRING, 4)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.Passwd)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TMySQLTable) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "db", thrift.STRING, 5)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.Db)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TMySQLTable) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "table", thrift.STRING, 6)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.Table)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TMySQLTable) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "charset", thrift.STRING, 7)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.Charset)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TMySQLTable) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("host", thrift.STRING, 1)
	l += bthrift.Binary.StringLengthNocopy(p.Host)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TMySQLTable) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("port", thrift.STRING, 2)
	l += bthrift.Binary.StringLengthNocopy(p.Port)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TMySQLTable) field3Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("user", thrift.STRING, 3)
	l += bthrift.Binary.StringLengthNocopy(p.User)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TMySQLTable) field4Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("passwd", thrift.STRING, 4)
	l += bthrift.Binary.StringLengthNocopy(p.Passwd)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TMySQLTable) field5Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("db", thrift.STRING, 5)
	l += bthrift.Binary.StringLengthNocopy(p.Db)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TMySQLTable) field6Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("table", thrift.STRING, 6)
	l += bthrift.Binary.StringLengthNocopy(p.Table)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TMySQLTable) field7Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("charset", thrift.STRING, 7)
	l += bthrift.Binary.StringLengthNocopy(p.Charset)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOdbcTable) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TOdbcTable[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TOdbcTable) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Host = &v

	}
	return offset, nil
}

func (p *TOdbcTable) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Port = &v

	}
	return offset, nil
}

func (p *TOdbcTable) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.User = &v

	}
	return offset, nil
}

func (p *TOdbcTable) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Passwd = &v

	}
	return offset, nil
}

func (p *TOdbcTable) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Db = &v

	}
	return offset, nil
}

func (p *TOdbcTable) FastReadField6(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Table = &v

	}
	return offset, nil
}

func (p *TOdbcTable) FastReadField7(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Driver = &v

	}
	return offset, nil
}

func (p *TOdbcTable) FastReadField8(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := types.TOdbcTableType(v)
		p.Type = &tmp

	}
	return offset, nil
}

// for compatibility
func (p *TOdbcTable) FastWrite(buf []byte) int {
	return 0
}

func (p *TOdbcTable) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TOdbcTable")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TOdbcTable) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TOdbcTable")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TOdbcTable) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetHost() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "host", thrift.STRING, 1)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Host)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOdbcTable) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPort() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "port", thrift.STRING, 2)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Port)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOdbcTable) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetUser() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "user", thrift.STRING, 3)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.User)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOdbcTable) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPasswd() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "passwd", thrift.STRING, 4)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Passwd)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOdbcTable) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDb() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "db", thrift.STRING, 5)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Db)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOdbcTable) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTable() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "table", thrift.STRING, 6)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Table)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOdbcTable) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDriver() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "driver", thrift.STRING, 7)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Driver)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOdbcTable) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "type", thrift.I32, 8)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.Type))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOdbcTable) field1Length() int {
	l := 0
	if p.IsSetHost() {
		l += bthrift.Binary.FieldBeginLength("host", thrift.STRING, 1)
		l += bthrift.Binary.StringLengthNocopy(*p.Host)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOdbcTable) field2Length() int {
	l := 0
	if p.IsSetPort() {
		l += bthrift.Binary.FieldBeginLength("port", thrift.STRING, 2)
		l += bthrift.Binary.StringLengthNocopy(*p.Port)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOdbcTable) field3Length() int {
	l := 0
	if p.IsSetUser() {
		l += bthrift.Binary.FieldBeginLength("user", thrift.STRING, 3)
		l += bthrift.Binary.StringLengthNocopy(*p.User)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOdbcTable) field4Length() int {
	l := 0
	if p.IsSetPasswd() {
		l += bthrift.Binary.FieldBeginLength("passwd", thrift.STRING, 4)
		l += bthrift.Binary.StringLengthNocopy(*p.Passwd)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOdbcTable) field5Length() int {
	l := 0
	if p.IsSetDb() {
		l += bthrift.Binary.FieldBeginLength("db", thrift.STRING, 5)
		l += bthrift.Binary.StringLengthNocopy(*p.Db)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOdbcTable) field6Length() int {
	l := 0
	if p.IsSetTable() {
		l += bthrift.Binary.FieldBeginLength("table", thrift.STRING, 6)
		l += bthrift.Binary.StringLengthNocopy(*p.Table)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOdbcTable) field7Length() int {
	l := 0
	if p.IsSetDriver() {
		l += bthrift.Binary.FieldBeginLength("driver", thrift.STRING, 7)
		l += bthrift.Binary.StringLengthNocopy(*p.Driver)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOdbcTable) field8Length() int {
	l := 0
	if p.IsSetType() {
		l += bthrift.Binary.FieldBeginLength("type", thrift.I32, 8)
		l += bthrift.Binary.I32Length(int32(*p.Type))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TEsTable) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
		offset += l
		if err != nil {
			goto SkipFieldTypeError
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)

SkipFieldTypeError:
	return offset, thrift.PrependError(fmt.Sprintf("%T skip field type %d error", p, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

// for compatibility
func (p *TEsTable) FastWrite(buf []byte) int {
	return 0
}

func (p *TEsTable) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TEsTable")
	if p != nil {
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TEsTable) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TEsTable")
	if p != nil {
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TSchemaTable) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetTableType bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetTableType = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetTableType {
		fieldId = 1
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TSchemaTable[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TSchemaTable[fieldId]))
}

func (p *TSchemaTable) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.TableType = TSchemaTableType(v)

	}
	return offset, nil
}

// for compatibility
func (p *TSchemaTable) FastWrite(buf []byte) int {
	return 0
}

func (p *TSchemaTable) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TSchemaTable")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TSchemaTable) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TSchemaTable")
	if p != nil {
		l += p.field1Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TSchemaTable) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tableType", thrift.I32, 1)
	offset += bthrift.Binary.WriteI32(buf[offset:], int32(p.TableType))

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TSchemaTable) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("tableType", thrift.I32, 1)
	l += bthrift.Binary.I32Length(int32(p.TableType))

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TBrokerTable) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
		offset += l
		if err != nil {
			goto SkipFieldTypeError
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)

SkipFieldTypeError:
	return offset, thrift.PrependError(fmt.Sprintf("%T skip field type %d error", p, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

// for compatibility
func (p *TBrokerTable) FastWrite(buf []byte) int {
	return 0
}

func (p *TBrokerTable) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TBrokerTable")
	if p != nil {
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TBrokerTable) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TBrokerTable")
	if p != nil {
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *THiveTable) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetDbName bool = false
	var issetTableName bool = false
	var issetProperties bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetDbName = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetTableName = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetProperties = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetDbName {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetTableName {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetProperties {
		fieldId = 3
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_THiveTable[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_THiveTable[fieldId]))
}

func (p *THiveTable) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.DbName = v

	}
	return offset, nil
}

func (p *THiveTable) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.TableName = v

	}
	return offset, nil
}

func (p *THiveTable) FastReadField3(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := bthrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Properties = make(map[string]string, size)
	for i := 0; i < size; i++ {
		var _key string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_key = v

		}

		var _val string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_val = v

		}

		p.Properties[_key] = _val
	}
	if l, err := bthrift.Binary.ReadMapEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

// for compatibility
func (p *THiveTable) FastWrite(buf []byte) int {
	return 0
}

func (p *THiveTable) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "THiveTable")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *THiveTable) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("THiveTable")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *THiveTable) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "db_name", thrift.STRING, 1)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.DbName)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *THiveTable) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "table_name", thrift.STRING, 2)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.TableName)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *THiveTable) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "properties", thrift.MAP, 3)
	mapBeginOffset := offset
	offset += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRING, 0)
	var length int
	for k, v := range p.Properties {
		length++

		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, k)

		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

	}
	bthrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.STRING, thrift.STRING, length)
	offset += bthrift.Binary.WriteMapEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *THiveTable) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("db_name", thrift.STRING, 1)
	l += bthrift.Binary.StringLengthNocopy(p.DbName)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *THiveTable) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("table_name", thrift.STRING, 2)
	l += bthrift.Binary.StringLengthNocopy(p.TableName)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *THiveTable) field3Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("properties", thrift.MAP, 3)
	l += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRING, len(p.Properties))
	for k, v := range p.Properties {

		l += bthrift.Binary.StringLengthNocopy(k)

		l += bthrift.Binary.StringLengthNocopy(v)

	}
	l += bthrift.Binary.MapEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TIcebergTable) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetDbName bool = false
	var issetTableName bool = false
	var issetProperties bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetDbName = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetTableName = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetProperties = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetDbName {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetTableName {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetProperties {
		fieldId = 3
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TIcebergTable[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TIcebergTable[fieldId]))
}

func (p *TIcebergTable) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.DbName = v

	}
	return offset, nil
}

func (p *TIcebergTable) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.TableName = v

	}
	return offset, nil
}

func (p *TIcebergTable) FastReadField3(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := bthrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Properties = make(map[string]string, size)
	for i := 0; i < size; i++ {
		var _key string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_key = v

		}

		var _val string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_val = v

		}

		p.Properties[_key] = _val
	}
	if l, err := bthrift.Binary.ReadMapEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

// for compatibility
func (p *TIcebergTable) FastWrite(buf []byte) int {
	return 0
}

func (p *TIcebergTable) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TIcebergTable")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TIcebergTable) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TIcebergTable")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TIcebergTable) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "db_name", thrift.STRING, 1)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.DbName)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TIcebergTable) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "table_name", thrift.STRING, 2)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.TableName)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TIcebergTable) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "properties", thrift.MAP, 3)
	mapBeginOffset := offset
	offset += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRING, 0)
	var length int
	for k, v := range p.Properties {
		length++

		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, k)

		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

	}
	bthrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.STRING, thrift.STRING, length)
	offset += bthrift.Binary.WriteMapEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TIcebergTable) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("db_name", thrift.STRING, 1)
	l += bthrift.Binary.StringLengthNocopy(p.DbName)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TIcebergTable) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("table_name", thrift.STRING, 2)
	l += bthrift.Binary.StringLengthNocopy(p.TableName)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TIcebergTable) field3Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("properties", thrift.MAP, 3)
	l += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRING, len(p.Properties))
	for k, v := range p.Properties {

		l += bthrift.Binary.StringLengthNocopy(k)

		l += bthrift.Binary.StringLengthNocopy(v)

	}
	l += bthrift.Binary.MapEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *THudiTable) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_THudiTable[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *THudiTable) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.DbName = &v

	}
	return offset, nil
}

func (p *THudiTable) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.TableName = &v

	}
	return offset, nil
}

func (p *THudiTable) FastReadField3(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := bthrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Properties = make(map[string]string, size)
	for i := 0; i < size; i++ {
		var _key string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_key = v

		}

		var _val string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_val = v

		}

		p.Properties[_key] = _val
	}
	if l, err := bthrift.Binary.ReadMapEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

// for compatibility
func (p *THudiTable) FastWrite(buf []byte) int {
	return 0
}

func (p *THudiTable) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "THudiTable")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *THudiTable) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("THudiTable")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *THudiTable) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDbName() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "dbName", thrift.STRING, 1)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.DbName)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THudiTable) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTableName() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tableName", thrift.STRING, 2)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.TableName)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THudiTable) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetProperties() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "properties", thrift.MAP, 3)
		mapBeginOffset := offset
		offset += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRING, 0)
		var length int
		for k, v := range p.Properties {
			length++

			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, k)

			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.STRING, thrift.STRING, length)
		offset += bthrift.Binary.WriteMapEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THudiTable) field1Length() int {
	l := 0
	if p.IsSetDbName() {
		l += bthrift.Binary.FieldBeginLength("dbName", thrift.STRING, 1)
		l += bthrift.Binary.StringLengthNocopy(*p.DbName)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THudiTable) field2Length() int {
	l := 0
	if p.IsSetTableName() {
		l += bthrift.Binary.FieldBeginLength("tableName", thrift.STRING, 2)
		l += bthrift.Binary.StringLengthNocopy(*p.TableName)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THudiTable) field3Length() int {
	l := 0
	if p.IsSetProperties() {
		l += bthrift.Binary.FieldBeginLength("properties", thrift.MAP, 3)
		l += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRING, len(p.Properties))
		for k, v := range p.Properties {

			l += bthrift.Binary.StringLengthNocopy(k)

			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.MapEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TJdbcTable) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TJdbcTable[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TJdbcTable) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.JdbcUrl = &v

	}
	return offset, nil
}

func (p *TJdbcTable) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.JdbcTableName = &v

	}
	return offset, nil
}

func (p *TJdbcTable) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.JdbcUser = &v

	}
	return offset, nil
}

func (p *TJdbcTable) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.JdbcPassword = &v

	}
	return offset, nil
}

func (p *TJdbcTable) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.JdbcDriverUrl = &v

	}
	return offset, nil
}

func (p *TJdbcTable) FastReadField6(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.JdbcResourceName = &v

	}
	return offset, nil
}

func (p *TJdbcTable) FastReadField7(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.JdbcDriverClass = &v

	}
	return offset, nil
}

func (p *TJdbcTable) FastReadField8(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.JdbcDriverChecksum = &v

	}
	return offset, nil
}

// for compatibility
func (p *TJdbcTable) FastWrite(buf []byte) int {
	return 0
}

func (p *TJdbcTable) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TJdbcTable")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TJdbcTable) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TJdbcTable")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TJdbcTable) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetJdbcUrl() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "jdbc_url", thrift.STRING, 1)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.JdbcUrl)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TJdbcTable) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetJdbcTableName() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "jdbc_table_name", thrift.STRING, 2)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.JdbcTableName)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TJdbcTable) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetJdbcUser() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "jdbc_user", thrift.STRING, 3)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.JdbcUser)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TJdbcTable) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetJdbcPassword() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "jdbc_password", thrift.STRING, 4)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.JdbcPassword)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TJdbcTable) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetJdbcDriverUrl() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "jdbc_driver_url", thrift.STRING, 5)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.JdbcDriverUrl)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TJdbcTable) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetJdbcResourceName() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "jdbc_resource_name", thrift.STRING, 6)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.JdbcResourceName)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TJdbcTable) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetJdbcDriverClass() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "jdbc_driver_class", thrift.STRING, 7)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.JdbcDriverClass)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TJdbcTable) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetJdbcDriverChecksum() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "jdbc_driver_checksum", thrift.STRING, 8)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.JdbcDriverChecksum)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TJdbcTable) field1Length() int {
	l := 0
	if p.IsSetJdbcUrl() {
		l += bthrift.Binary.FieldBeginLength("jdbc_url", thrift.STRING, 1)
		l += bthrift.Binary.StringLengthNocopy(*p.JdbcUrl)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TJdbcTable) field2Length() int {
	l := 0
	if p.IsSetJdbcTableName() {
		l += bthrift.Binary.FieldBeginLength("jdbc_table_name", thrift.STRING, 2)
		l += bthrift.Binary.StringLengthNocopy(*p.JdbcTableName)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TJdbcTable) field3Length() int {
	l := 0
	if p.IsSetJdbcUser() {
		l += bthrift.Binary.FieldBeginLength("jdbc_user", thrift.STRING, 3)
		l += bthrift.Binary.StringLengthNocopy(*p.JdbcUser)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TJdbcTable) field4Length() int {
	l := 0
	if p.IsSetJdbcPassword() {
		l += bthrift.Binary.FieldBeginLength("jdbc_password", thrift.STRING, 4)
		l += bthrift.Binary.StringLengthNocopy(*p.JdbcPassword)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TJdbcTable) field5Length() int {
	l := 0
	if p.IsSetJdbcDriverUrl() {
		l += bthrift.Binary.FieldBeginLength("jdbc_driver_url", thrift.STRING, 5)
		l += bthrift.Binary.StringLengthNocopy(*p.JdbcDriverUrl)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TJdbcTable) field6Length() int {
	l := 0
	if p.IsSetJdbcResourceName() {
		l += bthrift.Binary.FieldBeginLength("jdbc_resource_name", thrift.STRING, 6)
		l += bthrift.Binary.StringLengthNocopy(*p.JdbcResourceName)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TJdbcTable) field7Length() int {
	l := 0
	if p.IsSetJdbcDriverClass() {
		l += bthrift.Binary.FieldBeginLength("jdbc_driver_class", thrift.STRING, 7)
		l += bthrift.Binary.StringLengthNocopy(*p.JdbcDriverClass)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TJdbcTable) field8Length() int {
	l := 0
	if p.IsSetJdbcDriverChecksum() {
		l += bthrift.Binary.FieldBeginLength("jdbc_driver_checksum", thrift.STRING, 8)
		l += bthrift.Binary.StringLengthNocopy(*p.JdbcDriverChecksum)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TMCTable) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TMCTable[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TMCTable) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Region = &v

	}
	return offset, nil
}

func (p *TMCTable) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Project = &v

	}
	return offset, nil
}

func (p *TMCTable) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Table = &v

	}
	return offset, nil
}

func (p *TMCTable) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.AccessKey = &v

	}
	return offset, nil
}

func (p *TMCTable) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.SecretKey = &v

	}
	return offset, nil
}

func (p *TMCTable) FastReadField6(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.PublicAccess = &v

	}
	return offset, nil
}

func (p *TMCTable) FastReadField7(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.PartitionSpec = &v

	}
	return offset, nil
}

// for compatibility
func (p *TMCTable) FastWrite(buf []byte) int {
	return 0
}

func (p *TMCTable) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TMCTable")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TMCTable) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TMCTable")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TMCTable) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetRegion() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "region", thrift.STRING, 1)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Region)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TMCTable) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetProject() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "project", thrift.STRING, 2)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Project)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TMCTable) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTable() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "table", thrift.STRING, 3)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Table)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TMCTable) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetAccessKey() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "access_key", thrift.STRING, 4)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.AccessKey)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TMCTable) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSecretKey() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "secret_key", thrift.STRING, 5)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.SecretKey)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TMCTable) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPublicAccess() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "public_access", thrift.STRING, 6)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.PublicAccess)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TMCTable) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPartitionSpec() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "partition_spec", thrift.STRING, 7)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.PartitionSpec)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TMCTable) field1Length() int {
	l := 0
	if p.IsSetRegion() {
		l += bthrift.Binary.FieldBeginLength("region", thrift.STRING, 1)
		l += bthrift.Binary.StringLengthNocopy(*p.Region)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TMCTable) field2Length() int {
	l := 0
	if p.IsSetProject() {
		l += bthrift.Binary.FieldBeginLength("project", thrift.STRING, 2)
		l += bthrift.Binary.StringLengthNocopy(*p.Project)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TMCTable) field3Length() int {
	l := 0
	if p.IsSetTable() {
		l += bthrift.Binary.FieldBeginLength("table", thrift.STRING, 3)
		l += bthrift.Binary.StringLengthNocopy(*p.Table)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TMCTable) field4Length() int {
	l := 0
	if p.IsSetAccessKey() {
		l += bthrift.Binary.FieldBeginLength("access_key", thrift.STRING, 4)
		l += bthrift.Binary.StringLengthNocopy(*p.AccessKey)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TMCTable) field5Length() int {
	l := 0
	if p.IsSetSecretKey() {
		l += bthrift.Binary.FieldBeginLength("secret_key", thrift.STRING, 5)
		l += bthrift.Binary.StringLengthNocopy(*p.SecretKey)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TMCTable) field6Length() int {
	l := 0
	if p.IsSetPublicAccess() {
		l += bthrift.Binary.FieldBeginLength("public_access", thrift.STRING, 6)
		l += bthrift.Binary.StringLengthNocopy(*p.PublicAccess)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TMCTable) field7Length() int {
	l := 0
	if p.IsSetPartitionSpec() {
		l += bthrift.Binary.FieldBeginLength("partition_spec", thrift.STRING, 7)
		l += bthrift.Binary.StringLengthNocopy(*p.PartitionSpec)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTableDescriptor) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetId bool = false
	var issetTableType bool = false
	var issetNumCols bool = false
	var issetNumClusteringCols bool = false
	var issetTableName bool = false
	var issetDbName bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetTableType = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetNumCols = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetNumClusteringCols = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetTableName = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetDbName = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 11:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField11(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 12:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField12(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 14:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField14(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 15:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField15(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 16:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField16(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 17:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField17(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 18:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField18(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 19:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField19(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 20:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField20(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 21:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField21(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetId {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetTableType {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetNumCols {
		fieldId = 3
		goto RequiredFieldNotSetError
	}

	if !issetNumClusteringCols {
		fieldId = 4
		goto RequiredFieldNotSetError
	}

	if !issetTableName {
		fieldId = 7
		goto RequiredFieldNotSetError
	}

	if !issetDbName {
		fieldId = 8
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TTableDescriptor[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TTableDescriptor[fieldId]))
}

func (p *TTableDescriptor) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Id = v

	}
	return offset, nil
}

func (p *TTableDescriptor) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.TableType = types.TTableType(v)

	}
	return offset, nil
}

func (p *TTableDescriptor) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.NumCols = v

	}
	return offset, nil
}

func (p *TTableDescriptor) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.NumClusteringCols = v

	}
	return offset, nil
}

func (p *TTableDescriptor) FastReadField7(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.TableName = v

	}
	return offset, nil
}

func (p *TTableDescriptor) FastReadField8(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.DbName = v

	}
	return offset, nil
}

func (p *TTableDescriptor) FastReadField10(buf []byte) (int, error) {
	offset := 0

	tmp := NewTMySQLTable()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.MysqlTable = tmp
	return offset, nil
}

func (p *TTableDescriptor) FastReadField11(buf []byte) (int, error) {
	offset := 0

	tmp := NewTOlapTable()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.OlapTable = tmp
	return offset, nil
}

func (p *TTableDescriptor) FastReadField12(buf []byte) (int, error) {
	offset := 0

	tmp := NewTSchemaTable()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.SchemaTable = tmp
	return offset, nil
}

func (p *TTableDescriptor) FastReadField14(buf []byte) (int, error) {
	offset := 0

	tmp := NewTBrokerTable()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.BrokerTable = tmp
	return offset, nil
}

func (p *TTableDescriptor) FastReadField15(buf []byte) (int, error) {
	offset := 0

	tmp := NewTEsTable()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.EsTable = tmp
	return offset, nil
}

func (p *TTableDescriptor) FastReadField16(buf []byte) (int, error) {
	offset := 0

	tmp := NewTOdbcTable()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.OdbcTable = tmp
	return offset, nil
}

func (p *TTableDescriptor) FastReadField17(buf []byte) (int, error) {
	offset := 0

	tmp := NewTHiveTable()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.HiveTable = tmp
	return offset, nil
}

func (p *TTableDescriptor) FastReadField18(buf []byte) (int, error) {
	offset := 0

	tmp := NewTIcebergTable()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.IcebergTable = tmp
	return offset, nil
}

func (p *TTableDescriptor) FastReadField19(buf []byte) (int, error) {
	offset := 0

	tmp := NewTHudiTable()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.HudiTable = tmp
	return offset, nil
}

func (p *TTableDescriptor) FastReadField20(buf []byte) (int, error) {
	offset := 0

	tmp := NewTJdbcTable()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.JdbcTable = tmp
	return offset, nil
}

func (p *TTableDescriptor) FastReadField21(buf []byte) (int, error) {
	offset := 0

	tmp := NewTMCTable()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.McTable = tmp
	return offset, nil
}

// for compatibility
func (p *TTableDescriptor) FastWrite(buf []byte) int {
	return 0
}

func (p *TTableDescriptor) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TTableDescriptor")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
		offset += p.fastWriteField10(buf[offset:], binaryWriter)
		offset += p.fastWriteField11(buf[offset:], binaryWriter)
		offset += p.fastWriteField12(buf[offset:], binaryWriter)
		offset += p.fastWriteField14(buf[offset:], binaryWriter)
		offset += p.fastWriteField15(buf[offset:], binaryWriter)
		offset += p.fastWriteField16(buf[offset:], binaryWriter)
		offset += p.fastWriteField17(buf[offset:], binaryWriter)
		offset += p.fastWriteField18(buf[offset:], binaryWriter)
		offset += p.fastWriteField19(buf[offset:], binaryWriter)
		offset += p.fastWriteField20(buf[offset:], binaryWriter)
		offset += p.fastWriteField21(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TTableDescriptor) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TTableDescriptor")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field10Length()
		l += p.field11Length()
		l += p.field12Length()
		l += p.field14Length()
		l += p.field15Length()
		l += p.field16Length()
		l += p.field17Length()
		l += p.field18Length()
		l += p.field19Length()
		l += p.field20Length()
		l += p.field21Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TTableDescriptor) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "id", thrift.I64, 1)
	offset += bthrift.Binary.WriteI64(buf[offset:], p.Id)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TTableDescriptor) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tableType", thrift.I32, 2)
	offset += bthrift.Binary.WriteI32(buf[offset:], int32(p.TableType))

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TTableDescriptor) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "numCols", thrift.I32, 3)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.NumCols)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TTableDescriptor) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "numClusteringCols", thrift.I32, 4)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.NumClusteringCols)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TTableDescriptor) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tableName", thrift.STRING, 7)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.TableName)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TTableDescriptor) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "dbName", thrift.STRING, 8)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.DbName)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TTableDescriptor) fastWriteField10(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetMysqlTable() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "mysqlTable", thrift.STRUCT, 10)
		offset += p.MysqlTable.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTableDescriptor) fastWriteField11(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetOlapTable() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "olapTable", thrift.STRUCT, 11)
		offset += p.OlapTable.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTableDescriptor) fastWriteField12(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSchemaTable() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "schemaTable", thrift.STRUCT, 12)
		offset += p.SchemaTable.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTableDescriptor) fastWriteField14(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetBrokerTable() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "BrokerTable", thrift.STRUCT, 14)
		offset += p.BrokerTable.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTableDescriptor) fastWriteField15(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetEsTable() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "esTable", thrift.STRUCT, 15)
		offset += p.EsTable.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTableDescriptor) fastWriteField16(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetOdbcTable() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "odbcTable", thrift.STRUCT, 16)
		offset += p.OdbcTable.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTableDescriptor) fastWriteField17(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetHiveTable() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "hiveTable", thrift.STRUCT, 17)
		offset += p.HiveTable.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTableDescriptor) fastWriteField18(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIcebergTable() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "icebergTable", thrift.STRUCT, 18)
		offset += p.IcebergTable.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTableDescriptor) fastWriteField19(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetHudiTable() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "hudiTable", thrift.STRUCT, 19)
		offset += p.HudiTable.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTableDescriptor) fastWriteField20(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetJdbcTable() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "jdbcTable", thrift.STRUCT, 20)
		offset += p.JdbcTable.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTableDescriptor) fastWriteField21(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetMcTable() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "mcTable", thrift.STRUCT, 21)
		offset += p.McTable.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTableDescriptor) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("id", thrift.I64, 1)
	l += bthrift.Binary.I64Length(p.Id)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TTableDescriptor) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("tableType", thrift.I32, 2)
	l += bthrift.Binary.I32Length(int32(p.TableType))

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TTableDescriptor) field3Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("numCols", thrift.I32, 3)
	l += bthrift.Binary.I32Length(p.NumCols)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TTableDescriptor) field4Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("numClusteringCols", thrift.I32, 4)
	l += bthrift.Binary.I32Length(p.NumClusteringCols)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TTableDescriptor) field7Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("tableName", thrift.STRING, 7)
	l += bthrift.Binary.StringLengthNocopy(p.TableName)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TTableDescriptor) field8Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("dbName", thrift.STRING, 8)
	l += bthrift.Binary.StringLengthNocopy(p.DbName)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TTableDescriptor) field10Length() int {
	l := 0
	if p.IsSetMysqlTable() {
		l += bthrift.Binary.FieldBeginLength("mysqlTable", thrift.STRUCT, 10)
		l += p.MysqlTable.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTableDescriptor) field11Length() int {
	l := 0
	if p.IsSetOlapTable() {
		l += bthrift.Binary.FieldBeginLength("olapTable", thrift.STRUCT, 11)
		l += p.OlapTable.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTableDescriptor) field12Length() int {
	l := 0
	if p.IsSetSchemaTable() {
		l += bthrift.Binary.FieldBeginLength("schemaTable", thrift.STRUCT, 12)
		l += p.SchemaTable.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTableDescriptor) field14Length() int {
	l := 0
	if p.IsSetBrokerTable() {
		l += bthrift.Binary.FieldBeginLength("BrokerTable", thrift.STRUCT, 14)
		l += p.BrokerTable.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTableDescriptor) field15Length() int {
	l := 0
	if p.IsSetEsTable() {
		l += bthrift.Binary.FieldBeginLength("esTable", thrift.STRUCT, 15)
		l += p.EsTable.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTableDescriptor) field16Length() int {
	l := 0
	if p.IsSetOdbcTable() {
		l += bthrift.Binary.FieldBeginLength("odbcTable", thrift.STRUCT, 16)
		l += p.OdbcTable.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTableDescriptor) field17Length() int {
	l := 0
	if p.IsSetHiveTable() {
		l += bthrift.Binary.FieldBeginLength("hiveTable", thrift.STRUCT, 17)
		l += p.HiveTable.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTableDescriptor) field18Length() int {
	l := 0
	if p.IsSetIcebergTable() {
		l += bthrift.Binary.FieldBeginLength("icebergTable", thrift.STRUCT, 18)
		l += p.IcebergTable.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTableDescriptor) field19Length() int {
	l := 0
	if p.IsSetHudiTable() {
		l += bthrift.Binary.FieldBeginLength("hudiTable", thrift.STRUCT, 19)
		l += p.HudiTable.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTableDescriptor) field20Length() int {
	l := 0
	if p.IsSetJdbcTable() {
		l += bthrift.Binary.FieldBeginLength("jdbcTable", thrift.STRUCT, 20)
		l += p.JdbcTable.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTableDescriptor) field21Length() int {
	l := 0
	if p.IsSetMcTable() {
		l += bthrift.Binary.FieldBeginLength("mcTable", thrift.STRUCT, 21)
		l += p.McTable.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TDescriptorTable) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetTupleDescriptors bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetTupleDescriptors = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetTupleDescriptors {
		fieldId = 2
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TDescriptorTable[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TDescriptorTable[fieldId]))
}

func (p *TDescriptorTable) FastReadField1(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.SlotDescriptors = make([]*TSlotDescriptor, 0, size)
	for i := 0; i < size; i++ {
		_elem := NewTSlotDescriptor()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.SlotDescriptors = append(p.SlotDescriptors, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TDescriptorTable) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.TupleDescriptors = make([]*TTupleDescriptor, 0, size)
	for i := 0; i < size; i++ {
		_elem := NewTTupleDescriptor()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.TupleDescriptors = append(p.TupleDescriptors, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TDescriptorTable) FastReadField3(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.TableDescriptors = make([]*TTableDescriptor, 0, size)
	for i := 0; i < size; i++ {
		_elem := NewTTableDescriptor()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.TableDescriptors = append(p.TableDescriptors, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

// for compatibility
func (p *TDescriptorTable) FastWrite(buf []byte) int {
	return 0
}

func (p *TDescriptorTable) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TDescriptorTable")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TDescriptorTable) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TDescriptorTable")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TDescriptorTable) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSlotDescriptors() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "slotDescriptors", thrift.LIST, 1)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.SlotDescriptors {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TDescriptorTable) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tupleDescriptors", thrift.LIST, 2)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
	var length int
	for _, v := range p.TupleDescriptors {
		length++
		offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TDescriptorTable) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTableDescriptors() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tableDescriptors", thrift.LIST, 3)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.TableDescriptors {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TDescriptorTable) field1Length() int {
	l := 0
	if p.IsSetSlotDescriptors() {
		l += bthrift.Binary.FieldBeginLength("slotDescriptors", thrift.LIST, 1)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.SlotDescriptors))
		for _, v := range p.SlotDescriptors {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TDescriptorTable) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("tupleDescriptors", thrift.LIST, 2)
	l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.TupleDescriptors))
	for _, v := range p.TupleDescriptors {
		l += v.BLength()
	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TDescriptorTable) field3Length() int {
	l := 0
	if p.IsSetTableDescriptors() {
		l += bthrift.Binary.FieldBeginLength("tableDescriptors", thrift.LIST, 3)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.TableDescriptors))
		for _, v := range p.TableDescriptors {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}
