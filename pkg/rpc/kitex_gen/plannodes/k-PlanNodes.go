// Code generated by Kitex v0.8.0. DO NOT EDIT.

package plannodes

import (
	"bytes"
	"fmt"
	"reflect"
	"strings"

	"github.com/apache/thrift/lib/go/thrift"

	"github.com/cloudwego/kitex/pkg/protocol/bthrift"

	"github.com/selectdb/ccr_syncer/pkg/rpc/kitex_gen/descriptors"
	"github.com/selectdb/ccr_syncer/pkg/rpc/kitex_gen/exprs"
	"github.com/selectdb/ccr_syncer/pkg/rpc/kitex_gen/opcodes"
	"github.com/selectdb/ccr_syncer/pkg/rpc/kitex_gen/partitions"
	"github.com/selectdb/ccr_syncer/pkg/rpc/kitex_gen/types"
)

// unused protection
var (
	_ = fmt.Formatter(nil)
	_ = (*bytes.Buffer)(nil)
	_ = (*strings.Builder)(nil)
	_ = reflect.Type(nil)
	_ = thrift.TProtocol(nil)
	_ = bthrift.BinaryWriter(nil)
	_ = descriptors.KitexUnusedProtection
	_ = exprs.KitexUnusedProtection
	_ = opcodes.KitexUnusedProtection
	_ = partitions.KitexUnusedProtection
	_ = types.KitexUnusedProtection
)

func (p *TKeyRange) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetBeginKey bool = false
	var issetEndKey bool = false
	var issetColumnType bool = false
	var issetColumnName bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetBeginKey = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetEndKey = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetColumnType = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetColumnName = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetBeginKey {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetEndKey {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetColumnType {
		fieldId = 3
		goto RequiredFieldNotSetError
	}

	if !issetColumnName {
		fieldId = 4
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TKeyRange[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TKeyRange[fieldId]))
}

func (p *TKeyRange) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.BeginKey = v

	}
	return offset, nil
}

func (p *TKeyRange) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.EndKey = v

	}
	return offset, nil
}

func (p *TKeyRange) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.ColumnType = types.TPrimitiveType(v)

	}
	return offset, nil
}

func (p *TKeyRange) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.ColumnName = v

	}
	return offset, nil
}

// for compatibility
func (p *TKeyRange) FastWrite(buf []byte) int {
	return 0
}

func (p *TKeyRange) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TKeyRange")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TKeyRange) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TKeyRange")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TKeyRange) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "begin_key", thrift.I64, 1)
	offset += bthrift.Binary.WriteI64(buf[offset:], p.BeginKey)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TKeyRange) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "end_key", thrift.I64, 2)
	offset += bthrift.Binary.WriteI64(buf[offset:], p.EndKey)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TKeyRange) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "column_type", thrift.I32, 3)
	offset += bthrift.Binary.WriteI32(buf[offset:], int32(p.ColumnType))

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TKeyRange) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "column_name", thrift.STRING, 4)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.ColumnName)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TKeyRange) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("begin_key", thrift.I64, 1)
	l += bthrift.Binary.I64Length(p.BeginKey)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TKeyRange) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("end_key", thrift.I64, 2)
	l += bthrift.Binary.I64Length(p.EndKey)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TKeyRange) field3Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("column_type", thrift.I32, 3)
	l += bthrift.Binary.I32Length(int32(p.ColumnType))

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TKeyRange) field4Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("column_name", thrift.STRING, 4)
	l += bthrift.Binary.StringLengthNocopy(p.ColumnName)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TPaloScanRange) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetHosts bool = false
	var issetSchemaHash bool = false
	var issetVersion bool = false
	var issetVersionHash bool = false
	var issetTabletId bool = false
	var issetDbName bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetHosts = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetSchemaHash = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetVersion = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetVersionHash = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetTabletId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetDbName = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField9(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetHosts {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetSchemaHash {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetVersion {
		fieldId = 3
		goto RequiredFieldNotSetError
	}

	if !issetVersionHash {
		fieldId = 4
		goto RequiredFieldNotSetError
	}

	if !issetTabletId {
		fieldId = 5
		goto RequiredFieldNotSetError
	}

	if !issetDbName {
		fieldId = 6
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TPaloScanRange[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TPaloScanRange[fieldId]))
}

func (p *TPaloScanRange) FastReadField1(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Hosts = make([]*types.TNetworkAddress, 0, size)
	for i := 0; i < size; i++ {
		_elem := types.NewTNetworkAddress()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.Hosts = append(p.Hosts, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TPaloScanRange) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.SchemaHash = v

	}
	return offset, nil
}

func (p *TPaloScanRange) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Version = v

	}
	return offset, nil
}

func (p *TPaloScanRange) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.VersionHash = v

	}
	return offset, nil
}

func (p *TPaloScanRange) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.TabletId = v

	}
	return offset, nil
}

func (p *TPaloScanRange) FastReadField6(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.DbName = v

	}
	return offset, nil
}

func (p *TPaloScanRange) FastReadField7(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.PartitionColumnRanges = make([]*TKeyRange, 0, size)
	for i := 0; i < size; i++ {
		_elem := NewTKeyRange()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.PartitionColumnRanges = append(p.PartitionColumnRanges, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TPaloScanRange) FastReadField8(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.IndexName = &v

	}
	return offset, nil
}

func (p *TPaloScanRange) FastReadField9(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.TableName = &v

	}
	return offset, nil
}

// for compatibility
func (p *TPaloScanRange) FastWrite(buf []byte) int {
	return 0
}

func (p *TPaloScanRange) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TPaloScanRange")
	if p != nil {
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
		offset += p.fastWriteField9(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TPaloScanRange) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TPaloScanRange")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field9Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TPaloScanRange) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "hosts", thrift.LIST, 1)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
	var length int
	for _, v := range p.Hosts {
		length++
		offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TPaloScanRange) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "schema_hash", thrift.STRING, 2)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.SchemaHash)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TPaloScanRange) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "version", thrift.STRING, 3)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.Version)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TPaloScanRange) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "version_hash", thrift.STRING, 4)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.VersionHash)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TPaloScanRange) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tablet_id", thrift.I64, 5)
	offset += bthrift.Binary.WriteI64(buf[offset:], p.TabletId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TPaloScanRange) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "db_name", thrift.STRING, 6)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.DbName)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TPaloScanRange) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPartitionColumnRanges() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "partition_column_ranges", thrift.LIST, 7)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.PartitionColumnRanges {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPaloScanRange) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIndexName() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "index_name", thrift.STRING, 8)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.IndexName)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPaloScanRange) fastWriteField9(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTableName() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "table_name", thrift.STRING, 9)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.TableName)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPaloScanRange) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("hosts", thrift.LIST, 1)
	l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.Hosts))
	for _, v := range p.Hosts {
		l += v.BLength()
	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TPaloScanRange) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("schema_hash", thrift.STRING, 2)
	l += bthrift.Binary.StringLengthNocopy(p.SchemaHash)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TPaloScanRange) field3Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("version", thrift.STRING, 3)
	l += bthrift.Binary.StringLengthNocopy(p.Version)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TPaloScanRange) field4Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("version_hash", thrift.STRING, 4)
	l += bthrift.Binary.StringLengthNocopy(p.VersionHash)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TPaloScanRange) field5Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("tablet_id", thrift.I64, 5)
	l += bthrift.Binary.I64Length(p.TabletId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TPaloScanRange) field6Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("db_name", thrift.STRING, 6)
	l += bthrift.Binary.StringLengthNocopy(p.DbName)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TPaloScanRange) field7Length() int {
	l := 0
	if p.IsSetPartitionColumnRanges() {
		l += bthrift.Binary.FieldBeginLength("partition_column_ranges", thrift.LIST, 7)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.PartitionColumnRanges))
		for _, v := range p.PartitionColumnRanges {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPaloScanRange) field8Length() int {
	l := 0
	if p.IsSetIndexName() {
		l += bthrift.Binary.FieldBeginLength("index_name", thrift.STRING, 8)
		l += bthrift.Binary.StringLengthNocopy(*p.IndexName)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPaloScanRange) field9Length() int {
	l := 0
	if p.IsSetTableName() {
		l += bthrift.Binary.FieldBeginLength("table_name", thrift.STRING, 9)
		l += bthrift.Binary.StringLengthNocopy(*p.TableName)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THdfsConf) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetKey bool = false
	var issetValue bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetKey = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetValue = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetKey {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetValue {
		fieldId = 2
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_THdfsConf[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_THdfsConf[fieldId]))
}

func (p *THdfsConf) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Key = v

	}
	return offset, nil
}

func (p *THdfsConf) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Value = v

	}
	return offset, nil
}

// for compatibility
func (p *THdfsConf) FastWrite(buf []byte) int {
	return 0
}

func (p *THdfsConf) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "THdfsConf")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *THdfsConf) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("THdfsConf")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *THdfsConf) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "key", thrift.STRING, 1)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.Key)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *THdfsConf) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "value", thrift.STRING, 2)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.Value)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *THdfsConf) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("key", thrift.STRING, 1)
	l += bthrift.Binary.StringLengthNocopy(p.Key)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *THdfsConf) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("value", thrift.STRING, 2)
	l += bthrift.Binary.StringLengthNocopy(p.Value)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *THdfsParams) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_THdfsParams[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *THdfsParams) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.FsName = &v

	}
	return offset, nil
}

func (p *THdfsParams) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.User = &v

	}
	return offset, nil
}

func (p *THdfsParams) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.HdfsKerberosPrincipal = &v

	}
	return offset, nil
}

func (p *THdfsParams) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.HdfsKerberosKeytab = &v

	}
	return offset, nil
}

func (p *THdfsParams) FastReadField5(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.HdfsConf = make([]*THdfsConf, 0, size)
	for i := 0; i < size; i++ {
		_elem := NewTHdfsConf()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.HdfsConf = append(p.HdfsConf, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *THdfsParams) FastReadField6(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.RootPath = &v

	}
	return offset, nil
}

// for compatibility
func (p *THdfsParams) FastWrite(buf []byte) int {
	return 0
}

func (p *THdfsParams) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "THdfsParams")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *THdfsParams) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("THdfsParams")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *THdfsParams) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFsName() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "fs_name", thrift.STRING, 1)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.FsName)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THdfsParams) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetUser() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "user", thrift.STRING, 2)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.User)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THdfsParams) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetHdfsKerberosPrincipal() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "hdfs_kerberos_principal", thrift.STRING, 3)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.HdfsKerberosPrincipal)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THdfsParams) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetHdfsKerberosKeytab() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "hdfs_kerberos_keytab", thrift.STRING, 4)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.HdfsKerberosKeytab)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THdfsParams) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetHdfsConf() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "hdfs_conf", thrift.LIST, 5)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.HdfsConf {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THdfsParams) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetRootPath() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "root_path", thrift.STRING, 6)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.RootPath)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THdfsParams) field1Length() int {
	l := 0
	if p.IsSetFsName() {
		l += bthrift.Binary.FieldBeginLength("fs_name", thrift.STRING, 1)
		l += bthrift.Binary.StringLengthNocopy(*p.FsName)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THdfsParams) field2Length() int {
	l := 0
	if p.IsSetUser() {
		l += bthrift.Binary.FieldBeginLength("user", thrift.STRING, 2)
		l += bthrift.Binary.StringLengthNocopy(*p.User)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THdfsParams) field3Length() int {
	l := 0
	if p.IsSetHdfsKerberosPrincipal() {
		l += bthrift.Binary.FieldBeginLength("hdfs_kerberos_principal", thrift.STRING, 3)
		l += bthrift.Binary.StringLengthNocopy(*p.HdfsKerberosPrincipal)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THdfsParams) field4Length() int {
	l := 0
	if p.IsSetHdfsKerberosKeytab() {
		l += bthrift.Binary.FieldBeginLength("hdfs_kerberos_keytab", thrift.STRING, 4)
		l += bthrift.Binary.StringLengthNocopy(*p.HdfsKerberosKeytab)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THdfsParams) field5Length() int {
	l := 0
	if p.IsSetHdfsConf() {
		l += bthrift.Binary.FieldBeginLength("hdfs_conf", thrift.LIST, 5)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.HdfsConf))
		for _, v := range p.HdfsConf {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THdfsParams) field6Length() int {
	l := 0
	if p.IsSetRootPath() {
		l += bthrift.Binary.FieldBeginLength("root_path", thrift.STRING, 6)
		l += bthrift.Binary.StringLengthNocopy(*p.RootPath)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TBrokerRangeDesc) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetFileType bool = false
	var issetFormatType bool = false
	var issetSplittable bool = false
	var issetPath bool = false
	var issetStartOffset bool = false
	var issetSize bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetFileType = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetFormatType = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetSplittable = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetPath = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetStartOffset = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetSize = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField9(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 11:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField11(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 12:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField12(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 13:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField13(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 14:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField14(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 15:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField15(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 16:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField16(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 17:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField17(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 18:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField18(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 19:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField19(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 20:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField20(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetFileType {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetFormatType {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetSplittable {
		fieldId = 3
		goto RequiredFieldNotSetError
	}

	if !issetPath {
		fieldId = 4
		goto RequiredFieldNotSetError
	}

	if !issetStartOffset {
		fieldId = 5
		goto RequiredFieldNotSetError
	}

	if !issetSize {
		fieldId = 6
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TBrokerRangeDesc[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TBrokerRangeDesc[fieldId]))
}

func (p *TBrokerRangeDesc) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.FileType = types.TFileType(v)

	}
	return offset, nil
}

func (p *TBrokerRangeDesc) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.FormatType = TFileFormatType(v)

	}
	return offset, nil
}

func (p *TBrokerRangeDesc) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Splittable = v

	}
	return offset, nil
}

func (p *TBrokerRangeDesc) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Path = v

	}
	return offset, nil
}

func (p *TBrokerRangeDesc) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.StartOffset = v

	}
	return offset, nil
}

func (p *TBrokerRangeDesc) FastReadField6(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Size = v

	}
	return offset, nil
}

func (p *TBrokerRangeDesc) FastReadField7(buf []byte) (int, error) {
	offset := 0

	tmp := types.NewTUniqueId()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.LoadId = tmp
	return offset, nil
}

func (p *TBrokerRangeDesc) FastReadField8(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.FileSize = &v

	}
	return offset, nil
}

func (p *TBrokerRangeDesc) FastReadField9(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.NumOfColumnsFromFile = &v

	}
	return offset, nil
}

func (p *TBrokerRangeDesc) FastReadField10(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.ColumnsFromPath = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.ColumnsFromPath = append(p.ColumnsFromPath, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TBrokerRangeDesc) FastReadField11(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.StripOuterArray = &v

	}
	return offset, nil
}

func (p *TBrokerRangeDesc) FastReadField12(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Jsonpaths = &v

	}
	return offset, nil
}

func (p *TBrokerRangeDesc) FastReadField13(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.JsonRoot = &v

	}
	return offset, nil
}

func (p *TBrokerRangeDesc) FastReadField14(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.NumAsString = &v

	}
	return offset, nil
}

func (p *TBrokerRangeDesc) FastReadField15(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.FuzzyParse = &v

	}
	return offset, nil
}

func (p *TBrokerRangeDesc) FastReadField16(buf []byte) (int, error) {
	offset := 0

	tmp := NewTHdfsParams()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.HdfsParams = tmp
	return offset, nil
}

func (p *TBrokerRangeDesc) FastReadField17(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.ReadJsonByLine = &v

	}
	return offset, nil
}

func (p *TBrokerRangeDesc) FastReadField18(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.ReadByColumnDef = &v

	}
	return offset, nil
}

func (p *TBrokerRangeDesc) FastReadField19(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.HeaderType = &v

	}
	return offset, nil
}

func (p *TBrokerRangeDesc) FastReadField20(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.SkipLines = &v

	}
	return offset, nil
}

// for compatibility
func (p *TBrokerRangeDesc) FastWrite(buf []byte) int {
	return 0
}

func (p *TBrokerRangeDesc) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TBrokerRangeDesc")
	if p != nil {
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
		offset += p.fastWriteField9(buf[offset:], binaryWriter)
		offset += p.fastWriteField11(buf[offset:], binaryWriter)
		offset += p.fastWriteField14(buf[offset:], binaryWriter)
		offset += p.fastWriteField15(buf[offset:], binaryWriter)
		offset += p.fastWriteField17(buf[offset:], binaryWriter)
		offset += p.fastWriteField18(buf[offset:], binaryWriter)
		offset += p.fastWriteField20(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField10(buf[offset:], binaryWriter)
		offset += p.fastWriteField12(buf[offset:], binaryWriter)
		offset += p.fastWriteField13(buf[offset:], binaryWriter)
		offset += p.fastWriteField16(buf[offset:], binaryWriter)
		offset += p.fastWriteField19(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TBrokerRangeDesc) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TBrokerRangeDesc")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field9Length()
		l += p.field10Length()
		l += p.field11Length()
		l += p.field12Length()
		l += p.field13Length()
		l += p.field14Length()
		l += p.field15Length()
		l += p.field16Length()
		l += p.field17Length()
		l += p.field18Length()
		l += p.field19Length()
		l += p.field20Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TBrokerRangeDesc) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "file_type", thrift.I32, 1)
	offset += bthrift.Binary.WriteI32(buf[offset:], int32(p.FileType))

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TBrokerRangeDesc) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "format_type", thrift.I32, 2)
	offset += bthrift.Binary.WriteI32(buf[offset:], int32(p.FormatType))

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TBrokerRangeDesc) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "splittable", thrift.BOOL, 3)
	offset += bthrift.Binary.WriteBool(buf[offset:], p.Splittable)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TBrokerRangeDesc) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "path", thrift.STRING, 4)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.Path)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TBrokerRangeDesc) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "start_offset", thrift.I64, 5)
	offset += bthrift.Binary.WriteI64(buf[offset:], p.StartOffset)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TBrokerRangeDesc) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "size", thrift.I64, 6)
	offset += bthrift.Binary.WriteI64(buf[offset:], p.Size)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TBrokerRangeDesc) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetLoadId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "load_id", thrift.STRUCT, 7)
		offset += p.LoadId.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TBrokerRangeDesc) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFileSize() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "file_size", thrift.I64, 8)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.FileSize)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TBrokerRangeDesc) fastWriteField9(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetNumOfColumnsFromFile() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "num_of_columns_from_file", thrift.I32, 9)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.NumOfColumnsFromFile)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TBrokerRangeDesc) fastWriteField10(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetColumnsFromPath() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "columns_from_path", thrift.LIST, 10)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRING, 0)
		var length int
		for _, v := range p.ColumnsFromPath {
			length++
			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRING, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TBrokerRangeDesc) fastWriteField11(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetStripOuterArray() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "strip_outer_array", thrift.BOOL, 11)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.StripOuterArray)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TBrokerRangeDesc) fastWriteField12(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetJsonpaths() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "jsonpaths", thrift.STRING, 12)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Jsonpaths)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TBrokerRangeDesc) fastWriteField13(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetJsonRoot() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "json_root", thrift.STRING, 13)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.JsonRoot)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TBrokerRangeDesc) fastWriteField14(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetNumAsString() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "num_as_string", thrift.BOOL, 14)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.NumAsString)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TBrokerRangeDesc) fastWriteField15(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFuzzyParse() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "fuzzy_parse", thrift.BOOL, 15)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.FuzzyParse)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TBrokerRangeDesc) fastWriteField16(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetHdfsParams() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "hdfs_params", thrift.STRUCT, 16)
		offset += p.HdfsParams.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TBrokerRangeDesc) fastWriteField17(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetReadJsonByLine() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "read_json_by_line", thrift.BOOL, 17)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.ReadJsonByLine)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TBrokerRangeDesc) fastWriteField18(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetReadByColumnDef() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "read_by_column_def", thrift.BOOL, 18)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.ReadByColumnDef)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TBrokerRangeDesc) fastWriteField19(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetHeaderType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "header_type", thrift.STRING, 19)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.HeaderType)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TBrokerRangeDesc) fastWriteField20(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSkipLines() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "skip_lines", thrift.I32, 20)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.SkipLines)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TBrokerRangeDesc) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("file_type", thrift.I32, 1)
	l += bthrift.Binary.I32Length(int32(p.FileType))

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TBrokerRangeDesc) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("format_type", thrift.I32, 2)
	l += bthrift.Binary.I32Length(int32(p.FormatType))

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TBrokerRangeDesc) field3Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("splittable", thrift.BOOL, 3)
	l += bthrift.Binary.BoolLength(p.Splittable)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TBrokerRangeDesc) field4Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("path", thrift.STRING, 4)
	l += bthrift.Binary.StringLengthNocopy(p.Path)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TBrokerRangeDesc) field5Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("start_offset", thrift.I64, 5)
	l += bthrift.Binary.I64Length(p.StartOffset)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TBrokerRangeDesc) field6Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("size", thrift.I64, 6)
	l += bthrift.Binary.I64Length(p.Size)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TBrokerRangeDesc) field7Length() int {
	l := 0
	if p.IsSetLoadId() {
		l += bthrift.Binary.FieldBeginLength("load_id", thrift.STRUCT, 7)
		l += p.LoadId.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TBrokerRangeDesc) field8Length() int {
	l := 0
	if p.IsSetFileSize() {
		l += bthrift.Binary.FieldBeginLength("file_size", thrift.I64, 8)
		l += bthrift.Binary.I64Length(*p.FileSize)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TBrokerRangeDesc) field9Length() int {
	l := 0
	if p.IsSetNumOfColumnsFromFile() {
		l += bthrift.Binary.FieldBeginLength("num_of_columns_from_file", thrift.I32, 9)
		l += bthrift.Binary.I32Length(*p.NumOfColumnsFromFile)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TBrokerRangeDesc) field10Length() int {
	l := 0
	if p.IsSetColumnsFromPath() {
		l += bthrift.Binary.FieldBeginLength("columns_from_path", thrift.LIST, 10)
		l += bthrift.Binary.ListBeginLength(thrift.STRING, len(p.ColumnsFromPath))
		for _, v := range p.ColumnsFromPath {
			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TBrokerRangeDesc) field11Length() int {
	l := 0
	if p.IsSetStripOuterArray() {
		l += bthrift.Binary.FieldBeginLength("strip_outer_array", thrift.BOOL, 11)
		l += bthrift.Binary.BoolLength(*p.StripOuterArray)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TBrokerRangeDesc) field12Length() int {
	l := 0
	if p.IsSetJsonpaths() {
		l += bthrift.Binary.FieldBeginLength("jsonpaths", thrift.STRING, 12)
		l += bthrift.Binary.StringLengthNocopy(*p.Jsonpaths)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TBrokerRangeDesc) field13Length() int {
	l := 0
	if p.IsSetJsonRoot() {
		l += bthrift.Binary.FieldBeginLength("json_root", thrift.STRING, 13)
		l += bthrift.Binary.StringLengthNocopy(*p.JsonRoot)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TBrokerRangeDesc) field14Length() int {
	l := 0
	if p.IsSetNumAsString() {
		l += bthrift.Binary.FieldBeginLength("num_as_string", thrift.BOOL, 14)
		l += bthrift.Binary.BoolLength(*p.NumAsString)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TBrokerRangeDesc) field15Length() int {
	l := 0
	if p.IsSetFuzzyParse() {
		l += bthrift.Binary.FieldBeginLength("fuzzy_parse", thrift.BOOL, 15)
		l += bthrift.Binary.BoolLength(*p.FuzzyParse)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TBrokerRangeDesc) field16Length() int {
	l := 0
	if p.IsSetHdfsParams() {
		l += bthrift.Binary.FieldBeginLength("hdfs_params", thrift.STRUCT, 16)
		l += p.HdfsParams.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TBrokerRangeDesc) field17Length() int {
	l := 0
	if p.IsSetReadJsonByLine() {
		l += bthrift.Binary.FieldBeginLength("read_json_by_line", thrift.BOOL, 17)
		l += bthrift.Binary.BoolLength(*p.ReadJsonByLine)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TBrokerRangeDesc) field18Length() int {
	l := 0
	if p.IsSetReadByColumnDef() {
		l += bthrift.Binary.FieldBeginLength("read_by_column_def", thrift.BOOL, 18)
		l += bthrift.Binary.BoolLength(*p.ReadByColumnDef)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TBrokerRangeDesc) field19Length() int {
	l := 0
	if p.IsSetHeaderType() {
		l += bthrift.Binary.FieldBeginLength("header_type", thrift.STRING, 19)
		l += bthrift.Binary.StringLengthNocopy(*p.HeaderType)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TBrokerRangeDesc) field20Length() int {
	l := 0
	if p.IsSetSkipLines() {
		l += bthrift.Binary.FieldBeginLength("skip_lines", thrift.I32, 20)
		l += bthrift.Binary.I32Length(*p.SkipLines)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TBrokerScanRangeParams) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetColumnSeparator bool = false
	var issetLineDelimiter bool = false
	var issetSrcTupleId bool = false
	var issetSrcSlotIds bool = false
	var issetDestTupleId bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.BYTE {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetColumnSeparator = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.BYTE {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetLineDelimiter = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetSrcTupleId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetSrcSlotIds = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetDestTupleId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField9(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 11:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField11(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 12:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField12(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 13:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField13(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 14:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField14(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 15:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField15(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetColumnSeparator {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetLineDelimiter {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetSrcTupleId {
		fieldId = 3
		goto RequiredFieldNotSetError
	}

	if !issetSrcSlotIds {
		fieldId = 4
		goto RequiredFieldNotSetError
	}

	if !issetDestTupleId {
		fieldId = 5
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TBrokerScanRangeParams[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TBrokerScanRangeParams[fieldId]))
}

func (p *TBrokerScanRangeParams) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadByte(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.ColumnSeparator = v

	}
	return offset, nil
}

func (p *TBrokerScanRangeParams) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadByte(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.LineDelimiter = v

	}
	return offset, nil
}

func (p *TBrokerScanRangeParams) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.SrcTupleId = v

	}
	return offset, nil
}

func (p *TBrokerScanRangeParams) FastReadField4(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.SrcSlotIds = make([]types.TSlotId, 0, size)
	for i := 0; i < size; i++ {
		var _elem types.TSlotId
		if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.SrcSlotIds = append(p.SrcSlotIds, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TBrokerScanRangeParams) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.DestTupleId = v

	}
	return offset, nil
}

func (p *TBrokerScanRangeParams) FastReadField6(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := bthrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.ExprOfDestSlot = make(map[types.TSlotId]*exprs.TExpr, size)
	for i := 0; i < size; i++ {
		var _key types.TSlotId
		if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_key = v

		}
		_val := exprs.NewTExpr()
		if l, err := _val.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.ExprOfDestSlot[_key] = _val
	}
	if l, err := bthrift.Binary.ReadMapEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TBrokerScanRangeParams) FastReadField7(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := bthrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Properties = make(map[string]string, size)
	for i := 0; i < size; i++ {
		var _key string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_key = v

		}

		var _val string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_val = v

		}

		p.Properties[_key] = _val
	}
	if l, err := bthrift.Binary.ReadMapEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TBrokerScanRangeParams) FastReadField8(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.PartitionIds = make([]int64, 0, size)
	for i := 0; i < size; i++ {
		var _elem int64
		if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.PartitionIds = append(p.PartitionIds, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TBrokerScanRangeParams) FastReadField9(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := bthrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.DestSidToSrcSidWithoutTrans = make(map[types.TSlotId]types.TSlotId, size)
	for i := 0; i < size; i++ {
		var _key types.TSlotId
		if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_key = v

		}

		var _val types.TSlotId
		if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_val = v

		}

		p.DestSidToSrcSidWithoutTrans[_key] = _val
	}
	if l, err := bthrift.Binary.ReadMapEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TBrokerScanRangeParams) FastReadField10(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.StrictMode = &v

	}
	return offset, nil
}

func (p *TBrokerScanRangeParams) FastReadField11(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.ColumnSeparatorLength = v

	}
	return offset, nil
}

func (p *TBrokerScanRangeParams) FastReadField12(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.LineDelimiterLength = v

	}
	return offset, nil
}

func (p *TBrokerScanRangeParams) FastReadField13(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.ColumnSeparatorStr = &v

	}
	return offset, nil
}

func (p *TBrokerScanRangeParams) FastReadField14(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.LineDelimiterStr = &v

	}
	return offset, nil
}

func (p *TBrokerScanRangeParams) FastReadField15(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.TrimDoubleQuotes = &v

	}
	return offset, nil
}

// for compatibility
func (p *TBrokerScanRangeParams) FastWrite(buf []byte) int {
	return 0
}

func (p *TBrokerScanRangeParams) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TBrokerScanRangeParams")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField10(buf[offset:], binaryWriter)
		offset += p.fastWriteField11(buf[offset:], binaryWriter)
		offset += p.fastWriteField12(buf[offset:], binaryWriter)
		offset += p.fastWriteField15(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
		offset += p.fastWriteField9(buf[offset:], binaryWriter)
		offset += p.fastWriteField13(buf[offset:], binaryWriter)
		offset += p.fastWriteField14(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TBrokerScanRangeParams) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TBrokerScanRangeParams")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field9Length()
		l += p.field10Length()
		l += p.field11Length()
		l += p.field12Length()
		l += p.field13Length()
		l += p.field14Length()
		l += p.field15Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TBrokerScanRangeParams) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "column_separator", thrift.BYTE, 1)
	offset += bthrift.Binary.WriteByte(buf[offset:], p.ColumnSeparator)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TBrokerScanRangeParams) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "line_delimiter", thrift.BYTE, 2)
	offset += bthrift.Binary.WriteByte(buf[offset:], p.LineDelimiter)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TBrokerScanRangeParams) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "src_tuple_id", thrift.I32, 3)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.SrcTupleId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TBrokerScanRangeParams) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "src_slot_ids", thrift.LIST, 4)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.I32, 0)
	var length int
	for _, v := range p.SrcSlotIds {
		length++
		offset += bthrift.Binary.WriteI32(buf[offset:], v)

	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.I32, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TBrokerScanRangeParams) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "dest_tuple_id", thrift.I32, 5)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.DestTupleId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TBrokerScanRangeParams) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetExprOfDestSlot() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "expr_of_dest_slot", thrift.MAP, 6)
		mapBeginOffset := offset
		offset += bthrift.Binary.MapBeginLength(thrift.I32, thrift.STRUCT, 0)
		var length int
		for k, v := range p.ExprOfDestSlot {
			length++

			offset += bthrift.Binary.WriteI32(buf[offset:], k)

			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.I32, thrift.STRUCT, length)
		offset += bthrift.Binary.WriteMapEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TBrokerScanRangeParams) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetProperties() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "properties", thrift.MAP, 7)
		mapBeginOffset := offset
		offset += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRING, 0)
		var length int
		for k, v := range p.Properties {
			length++

			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, k)

			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.STRING, thrift.STRING, length)
		offset += bthrift.Binary.WriteMapEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TBrokerScanRangeParams) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPartitionIds() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "partition_ids", thrift.LIST, 8)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.I64, 0)
		var length int
		for _, v := range p.PartitionIds {
			length++
			offset += bthrift.Binary.WriteI64(buf[offset:], v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.I64, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TBrokerScanRangeParams) fastWriteField9(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDestSidToSrcSidWithoutTrans() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "dest_sid_to_src_sid_without_trans", thrift.MAP, 9)
		mapBeginOffset := offset
		offset += bthrift.Binary.MapBeginLength(thrift.I32, thrift.I32, 0)
		var length int
		for k, v := range p.DestSidToSrcSidWithoutTrans {
			length++

			offset += bthrift.Binary.WriteI32(buf[offset:], k)

			offset += bthrift.Binary.WriteI32(buf[offset:], v)

		}
		bthrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.I32, thrift.I32, length)
		offset += bthrift.Binary.WriteMapEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TBrokerScanRangeParams) fastWriteField10(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetStrictMode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "strict_mode", thrift.BOOL, 10)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.StrictMode)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TBrokerScanRangeParams) fastWriteField11(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetColumnSeparatorLength() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "column_separator_length", thrift.I32, 11)
		offset += bthrift.Binary.WriteI32(buf[offset:], p.ColumnSeparatorLength)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TBrokerScanRangeParams) fastWriteField12(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetLineDelimiterLength() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "line_delimiter_length", thrift.I32, 12)
		offset += bthrift.Binary.WriteI32(buf[offset:], p.LineDelimiterLength)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TBrokerScanRangeParams) fastWriteField13(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetColumnSeparatorStr() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "column_separator_str", thrift.STRING, 13)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.ColumnSeparatorStr)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TBrokerScanRangeParams) fastWriteField14(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetLineDelimiterStr() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "line_delimiter_str", thrift.STRING, 14)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.LineDelimiterStr)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TBrokerScanRangeParams) fastWriteField15(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTrimDoubleQuotes() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "trim_double_quotes", thrift.BOOL, 15)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.TrimDoubleQuotes)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TBrokerScanRangeParams) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("column_separator", thrift.BYTE, 1)
	l += bthrift.Binary.ByteLength(p.ColumnSeparator)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TBrokerScanRangeParams) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("line_delimiter", thrift.BYTE, 2)
	l += bthrift.Binary.ByteLength(p.LineDelimiter)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TBrokerScanRangeParams) field3Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("src_tuple_id", thrift.I32, 3)
	l += bthrift.Binary.I32Length(p.SrcTupleId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TBrokerScanRangeParams) field4Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("src_slot_ids", thrift.LIST, 4)
	l += bthrift.Binary.ListBeginLength(thrift.I32, len(p.SrcSlotIds))
	var tmpV types.TSlotId
	l += bthrift.Binary.I32Length(int32(tmpV)) * len(p.SrcSlotIds)
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TBrokerScanRangeParams) field5Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("dest_tuple_id", thrift.I32, 5)
	l += bthrift.Binary.I32Length(p.DestTupleId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TBrokerScanRangeParams) field6Length() int {
	l := 0
	if p.IsSetExprOfDestSlot() {
		l += bthrift.Binary.FieldBeginLength("expr_of_dest_slot", thrift.MAP, 6)
		l += bthrift.Binary.MapBeginLength(thrift.I32, thrift.STRUCT, len(p.ExprOfDestSlot))
		for k, v := range p.ExprOfDestSlot {

			l += bthrift.Binary.I32Length(k)

			l += v.BLength()
		}
		l += bthrift.Binary.MapEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TBrokerScanRangeParams) field7Length() int {
	l := 0
	if p.IsSetProperties() {
		l += bthrift.Binary.FieldBeginLength("properties", thrift.MAP, 7)
		l += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRING, len(p.Properties))
		for k, v := range p.Properties {

			l += bthrift.Binary.StringLengthNocopy(k)

			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.MapEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TBrokerScanRangeParams) field8Length() int {
	l := 0
	if p.IsSetPartitionIds() {
		l += bthrift.Binary.FieldBeginLength("partition_ids", thrift.LIST, 8)
		l += bthrift.Binary.ListBeginLength(thrift.I64, len(p.PartitionIds))
		var tmpV int64
		l += bthrift.Binary.I64Length(int64(tmpV)) * len(p.PartitionIds)
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TBrokerScanRangeParams) field9Length() int {
	l := 0
	if p.IsSetDestSidToSrcSidWithoutTrans() {
		l += bthrift.Binary.FieldBeginLength("dest_sid_to_src_sid_without_trans", thrift.MAP, 9)
		l += bthrift.Binary.MapBeginLength(thrift.I32, thrift.I32, len(p.DestSidToSrcSidWithoutTrans))
		var tmpK types.TSlotId
		var tmpV types.TSlotId
		l += (bthrift.Binary.I32Length(int32(tmpK)) + bthrift.Binary.I32Length(int32(tmpV))) * len(p.DestSidToSrcSidWithoutTrans)
		l += bthrift.Binary.MapEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TBrokerScanRangeParams) field10Length() int {
	l := 0
	if p.IsSetStrictMode() {
		l += bthrift.Binary.FieldBeginLength("strict_mode", thrift.BOOL, 10)
		l += bthrift.Binary.BoolLength(*p.StrictMode)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TBrokerScanRangeParams) field11Length() int {
	l := 0
	if p.IsSetColumnSeparatorLength() {
		l += bthrift.Binary.FieldBeginLength("column_separator_length", thrift.I32, 11)
		l += bthrift.Binary.I32Length(p.ColumnSeparatorLength)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TBrokerScanRangeParams) field12Length() int {
	l := 0
	if p.IsSetLineDelimiterLength() {
		l += bthrift.Binary.FieldBeginLength("line_delimiter_length", thrift.I32, 12)
		l += bthrift.Binary.I32Length(p.LineDelimiterLength)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TBrokerScanRangeParams) field13Length() int {
	l := 0
	if p.IsSetColumnSeparatorStr() {
		l += bthrift.Binary.FieldBeginLength("column_separator_str", thrift.STRING, 13)
		l += bthrift.Binary.StringLengthNocopy(*p.ColumnSeparatorStr)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TBrokerScanRangeParams) field14Length() int {
	l := 0
	if p.IsSetLineDelimiterStr() {
		l += bthrift.Binary.FieldBeginLength("line_delimiter_str", thrift.STRING, 14)
		l += bthrift.Binary.StringLengthNocopy(*p.LineDelimiterStr)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TBrokerScanRangeParams) field15Length() int {
	l := 0
	if p.IsSetTrimDoubleQuotes() {
		l += bthrift.Binary.FieldBeginLength("trim_double_quotes", thrift.BOOL, 15)
		l += bthrift.Binary.BoolLength(*p.TrimDoubleQuotes)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TBrokerScanRange) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetRanges bool = false
	var issetParams bool = false
	var issetBrokerAddresses bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetRanges = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetParams = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetBrokerAddresses = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetRanges {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetParams {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetBrokerAddresses {
		fieldId = 3
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TBrokerScanRange[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TBrokerScanRange[fieldId]))
}

func (p *TBrokerScanRange) FastReadField1(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Ranges = make([]*TBrokerRangeDesc, 0, size)
	for i := 0; i < size; i++ {
		_elem := NewTBrokerRangeDesc()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.Ranges = append(p.Ranges, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TBrokerScanRange) FastReadField2(buf []byte) (int, error) {
	offset := 0

	tmp := NewTBrokerScanRangeParams()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.Params = tmp
	return offset, nil
}

func (p *TBrokerScanRange) FastReadField3(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.BrokerAddresses = make([]*types.TNetworkAddress, 0, size)
	for i := 0; i < size; i++ {
		_elem := types.NewTNetworkAddress()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.BrokerAddresses = append(p.BrokerAddresses, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

// for compatibility
func (p *TBrokerScanRange) FastWrite(buf []byte) int {
	return 0
}

func (p *TBrokerScanRange) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TBrokerScanRange")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TBrokerScanRange) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TBrokerScanRange")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TBrokerScanRange) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "ranges", thrift.LIST, 1)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
	var length int
	for _, v := range p.Ranges {
		length++
		offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TBrokerScanRange) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "params", thrift.STRUCT, 2)
	offset += p.Params.FastWriteNocopy(buf[offset:], binaryWriter)
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TBrokerScanRange) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "broker_addresses", thrift.LIST, 3)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
	var length int
	for _, v := range p.BrokerAddresses {
		length++
		offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TBrokerScanRange) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("ranges", thrift.LIST, 1)
	l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.Ranges))
	for _, v := range p.Ranges {
		l += v.BLength()
	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TBrokerScanRange) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("params", thrift.STRUCT, 2)
	l += p.Params.BLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TBrokerScanRange) field3Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("broker_addresses", thrift.LIST, 3)
	l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.BrokerAddresses))
	for _, v := range p.BrokerAddresses {
		l += v.BLength()
	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TEsScanRange) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetEsHosts bool = false
	var issetIndex bool = false
	var issetShardId bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetEsHosts = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetIndex = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetShardId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetEsHosts {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetIndex {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetShardId {
		fieldId = 4
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TEsScanRange[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TEsScanRange[fieldId]))
}

func (p *TEsScanRange) FastReadField1(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.EsHosts = make([]*types.TNetworkAddress, 0, size)
	for i := 0; i < size; i++ {
		_elem := types.NewTNetworkAddress()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.EsHosts = append(p.EsHosts, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TEsScanRange) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Index = v

	}
	return offset, nil
}

func (p *TEsScanRange) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Type = &v

	}
	return offset, nil
}

func (p *TEsScanRange) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.ShardId = v

	}
	return offset, nil
}

// for compatibility
func (p *TEsScanRange) FastWrite(buf []byte) int {
	return 0
}

func (p *TEsScanRange) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TEsScanRange")
	if p != nil {
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TEsScanRange) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TEsScanRange")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TEsScanRange) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "es_hosts", thrift.LIST, 1)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
	var length int
	for _, v := range p.EsHosts {
		length++
		offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TEsScanRange) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "index", thrift.STRING, 2)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.Index)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TEsScanRange) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "type", thrift.STRING, 3)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Type)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TEsScanRange) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "shard_id", thrift.I32, 4)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.ShardId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TEsScanRange) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("es_hosts", thrift.LIST, 1)
	l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.EsHosts))
	for _, v := range p.EsHosts {
		l += v.BLength()
	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TEsScanRange) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("index", thrift.STRING, 2)
	l += bthrift.Binary.StringLengthNocopy(p.Index)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TEsScanRange) field3Length() int {
	l := 0
	if p.IsSetType() {
		l += bthrift.Binary.FieldBeginLength("type", thrift.STRING, 3)
		l += bthrift.Binary.StringLengthNocopy(*p.Type)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TEsScanRange) field4Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("shard_id", thrift.I32, 4)
	l += bthrift.Binary.I32Length(p.ShardId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TFileTextScanRangeParams) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.BYTE {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.BYTE {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TFileTextScanRangeParams[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TFileTextScanRangeParams) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.ColumnSeparator = &v

	}
	return offset, nil
}

func (p *TFileTextScanRangeParams) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.LineDelimiter = &v

	}
	return offset, nil
}

func (p *TFileTextScanRangeParams) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.CollectionDelimiter = &v

	}
	return offset, nil
}

func (p *TFileTextScanRangeParams) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.MapkvDelimiter = &v

	}
	return offset, nil
}

func (p *TFileTextScanRangeParams) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadByte(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Enclose = &v

	}
	return offset, nil
}

func (p *TFileTextScanRangeParams) FastReadField6(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadByte(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Escape = &v

	}
	return offset, nil
}

// for compatibility
func (p *TFileTextScanRangeParams) FastWrite(buf []byte) int {
	return 0
}

func (p *TFileTextScanRangeParams) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TFileTextScanRangeParams")
	if p != nil {
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TFileTextScanRangeParams) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TFileTextScanRangeParams")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TFileTextScanRangeParams) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetColumnSeparator() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "column_separator", thrift.STRING, 1)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.ColumnSeparator)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileTextScanRangeParams) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetLineDelimiter() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "line_delimiter", thrift.STRING, 2)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.LineDelimiter)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileTextScanRangeParams) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetCollectionDelimiter() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "collection_delimiter", thrift.STRING, 3)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.CollectionDelimiter)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileTextScanRangeParams) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetMapkvDelimiter() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "mapkv_delimiter", thrift.STRING, 4)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.MapkvDelimiter)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileTextScanRangeParams) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetEnclose() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "enclose", thrift.BYTE, 5)
		offset += bthrift.Binary.WriteByte(buf[offset:], *p.Enclose)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileTextScanRangeParams) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetEscape() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "escape", thrift.BYTE, 6)
		offset += bthrift.Binary.WriteByte(buf[offset:], *p.Escape)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileTextScanRangeParams) field1Length() int {
	l := 0
	if p.IsSetColumnSeparator() {
		l += bthrift.Binary.FieldBeginLength("column_separator", thrift.STRING, 1)
		l += bthrift.Binary.StringLengthNocopy(*p.ColumnSeparator)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileTextScanRangeParams) field2Length() int {
	l := 0
	if p.IsSetLineDelimiter() {
		l += bthrift.Binary.FieldBeginLength("line_delimiter", thrift.STRING, 2)
		l += bthrift.Binary.StringLengthNocopy(*p.LineDelimiter)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileTextScanRangeParams) field3Length() int {
	l := 0
	if p.IsSetCollectionDelimiter() {
		l += bthrift.Binary.FieldBeginLength("collection_delimiter", thrift.STRING, 3)
		l += bthrift.Binary.StringLengthNocopy(*p.CollectionDelimiter)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileTextScanRangeParams) field4Length() int {
	l := 0
	if p.IsSetMapkvDelimiter() {
		l += bthrift.Binary.FieldBeginLength("mapkv_delimiter", thrift.STRING, 4)
		l += bthrift.Binary.StringLengthNocopy(*p.MapkvDelimiter)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileTextScanRangeParams) field5Length() int {
	l := 0
	if p.IsSetEnclose() {
		l += bthrift.Binary.FieldBeginLength("enclose", thrift.BYTE, 5)
		l += bthrift.Binary.ByteLength(*p.Enclose)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileTextScanRangeParams) field6Length() int {
	l := 0
	if p.IsSetEscape() {
		l += bthrift.Binary.FieldBeginLength("escape", thrift.BYTE, 6)
		l += bthrift.Binary.ByteLength(*p.Escape)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileScanSlotInfo) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TFileScanSlotInfo[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TFileScanSlotInfo) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.SlotId = &v

	}
	return offset, nil
}

func (p *TFileScanSlotInfo) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.IsFileSlot = &v

	}
	return offset, nil
}

// for compatibility
func (p *TFileScanSlotInfo) FastWrite(buf []byte) int {
	return 0
}

func (p *TFileScanSlotInfo) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TFileScanSlotInfo")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TFileScanSlotInfo) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TFileScanSlotInfo")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TFileScanSlotInfo) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSlotId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "slot_id", thrift.I32, 1)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.SlotId)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileScanSlotInfo) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIsFileSlot() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "is_file_slot", thrift.BOOL, 2)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.IsFileSlot)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileScanSlotInfo) field1Length() int {
	l := 0
	if p.IsSetSlotId() {
		l += bthrift.Binary.FieldBeginLength("slot_id", thrift.I32, 1)
		l += bthrift.Binary.I32Length(*p.SlotId)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileScanSlotInfo) field2Length() int {
	l := 0
	if p.IsSetIsFileSlot() {
		l += bthrift.Binary.FieldBeginLength("is_file_slot", thrift.BOOL, 2)
		l += bthrift.Binary.BoolLength(*p.IsFileSlot)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileAttributes) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField9(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 11:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField11(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 1001:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField1001(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TFileAttributes[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TFileAttributes) FastReadField1(buf []byte) (int, error) {
	offset := 0

	tmp := NewTFileTextScanRangeParams()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.TextParams = tmp
	return offset, nil
}

func (p *TFileAttributes) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.StripOuterArray = &v

	}
	return offset, nil
}

func (p *TFileAttributes) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Jsonpaths = &v

	}
	return offset, nil
}

func (p *TFileAttributes) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.JsonRoot = &v

	}
	return offset, nil
}

func (p *TFileAttributes) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.NumAsString = &v

	}
	return offset, nil
}

func (p *TFileAttributes) FastReadField6(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.FuzzyParse = &v

	}
	return offset, nil
}

func (p *TFileAttributes) FastReadField7(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.ReadJsonByLine = &v

	}
	return offset, nil
}

func (p *TFileAttributes) FastReadField8(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.ReadByColumnDef = &v

	}
	return offset, nil
}

func (p *TFileAttributes) FastReadField9(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.HeaderType = &v

	}
	return offset, nil
}

func (p *TFileAttributes) FastReadField10(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.TrimDoubleQuotes = &v

	}
	return offset, nil
}

func (p *TFileAttributes) FastReadField11(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.SkipLines = &v

	}
	return offset, nil
}

func (p *TFileAttributes) FastReadField1001(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.IgnoreCsvRedundantCol = &v

	}
	return offset, nil
}

// for compatibility
func (p *TFileAttributes) FastWrite(buf []byte) int {
	return 0
}

func (p *TFileAttributes) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TFileAttributes")
	if p != nil {
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
		offset += p.fastWriteField10(buf[offset:], binaryWriter)
		offset += p.fastWriteField11(buf[offset:], binaryWriter)
		offset += p.fastWriteField1001(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField9(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TFileAttributes) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TFileAttributes")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field9Length()
		l += p.field10Length()
		l += p.field11Length()
		l += p.field1001Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TFileAttributes) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTextParams() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "text_params", thrift.STRUCT, 1)
		offset += p.TextParams.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileAttributes) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetStripOuterArray() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "strip_outer_array", thrift.BOOL, 2)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.StripOuterArray)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileAttributes) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetJsonpaths() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "jsonpaths", thrift.STRING, 3)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Jsonpaths)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileAttributes) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetJsonRoot() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "json_root", thrift.STRING, 4)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.JsonRoot)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileAttributes) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetNumAsString() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "num_as_string", thrift.BOOL, 5)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.NumAsString)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileAttributes) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFuzzyParse() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "fuzzy_parse", thrift.BOOL, 6)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.FuzzyParse)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileAttributes) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetReadJsonByLine() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "read_json_by_line", thrift.BOOL, 7)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.ReadJsonByLine)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileAttributes) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetReadByColumnDef() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "read_by_column_def", thrift.BOOL, 8)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.ReadByColumnDef)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileAttributes) fastWriteField9(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetHeaderType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "header_type", thrift.STRING, 9)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.HeaderType)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileAttributes) fastWriteField10(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTrimDoubleQuotes() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "trim_double_quotes", thrift.BOOL, 10)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.TrimDoubleQuotes)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileAttributes) fastWriteField11(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSkipLines() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "skip_lines", thrift.I32, 11)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.SkipLines)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileAttributes) fastWriteField1001(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIgnoreCsvRedundantCol() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "ignore_csv_redundant_col", thrift.BOOL, 1001)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.IgnoreCsvRedundantCol)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileAttributes) field1Length() int {
	l := 0
	if p.IsSetTextParams() {
		l += bthrift.Binary.FieldBeginLength("text_params", thrift.STRUCT, 1)
		l += p.TextParams.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileAttributes) field2Length() int {
	l := 0
	if p.IsSetStripOuterArray() {
		l += bthrift.Binary.FieldBeginLength("strip_outer_array", thrift.BOOL, 2)
		l += bthrift.Binary.BoolLength(*p.StripOuterArray)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileAttributes) field3Length() int {
	l := 0
	if p.IsSetJsonpaths() {
		l += bthrift.Binary.FieldBeginLength("jsonpaths", thrift.STRING, 3)
		l += bthrift.Binary.StringLengthNocopy(*p.Jsonpaths)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileAttributes) field4Length() int {
	l := 0
	if p.IsSetJsonRoot() {
		l += bthrift.Binary.FieldBeginLength("json_root", thrift.STRING, 4)
		l += bthrift.Binary.StringLengthNocopy(*p.JsonRoot)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileAttributes) field5Length() int {
	l := 0
	if p.IsSetNumAsString() {
		l += bthrift.Binary.FieldBeginLength("num_as_string", thrift.BOOL, 5)
		l += bthrift.Binary.BoolLength(*p.NumAsString)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileAttributes) field6Length() int {
	l := 0
	if p.IsSetFuzzyParse() {
		l += bthrift.Binary.FieldBeginLength("fuzzy_parse", thrift.BOOL, 6)
		l += bthrift.Binary.BoolLength(*p.FuzzyParse)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileAttributes) field7Length() int {
	l := 0
	if p.IsSetReadJsonByLine() {
		l += bthrift.Binary.FieldBeginLength("read_json_by_line", thrift.BOOL, 7)
		l += bthrift.Binary.BoolLength(*p.ReadJsonByLine)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileAttributes) field8Length() int {
	l := 0
	if p.IsSetReadByColumnDef() {
		l += bthrift.Binary.FieldBeginLength("read_by_column_def", thrift.BOOL, 8)
		l += bthrift.Binary.BoolLength(*p.ReadByColumnDef)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileAttributes) field9Length() int {
	l := 0
	if p.IsSetHeaderType() {
		l += bthrift.Binary.FieldBeginLength("header_type", thrift.STRING, 9)
		l += bthrift.Binary.StringLengthNocopy(*p.HeaderType)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileAttributes) field10Length() int {
	l := 0
	if p.IsSetTrimDoubleQuotes() {
		l += bthrift.Binary.FieldBeginLength("trim_double_quotes", thrift.BOOL, 10)
		l += bthrift.Binary.BoolLength(*p.TrimDoubleQuotes)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileAttributes) field11Length() int {
	l := 0
	if p.IsSetSkipLines() {
		l += bthrift.Binary.FieldBeginLength("skip_lines", thrift.I32, 11)
		l += bthrift.Binary.I32Length(*p.SkipLines)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileAttributes) field1001Length() int {
	l := 0
	if p.IsSetIgnoreCsvRedundantCol() {
		l += bthrift.Binary.FieldBeginLength("ignore_csv_redundant_col", thrift.BOOL, 1001)
		l += bthrift.Binary.BoolLength(*p.IgnoreCsvRedundantCol)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TIcebergDeleteFileDesc) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TIcebergDeleteFileDesc[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TIcebergDeleteFileDesc) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Path = &v

	}
	return offset, nil
}

func (p *TIcebergDeleteFileDesc) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.PositionLowerBound = &v

	}
	return offset, nil
}

func (p *TIcebergDeleteFileDesc) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.PositionUpperBound = &v

	}
	return offset, nil
}

func (p *TIcebergDeleteFileDesc) FastReadField4(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.FieldIds = make([]int32, 0, size)
	for i := 0; i < size; i++ {
		var _elem int32
		if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.FieldIds = append(p.FieldIds, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TIcebergDeleteFileDesc) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Content = &v

	}
	return offset, nil
}

// for compatibility
func (p *TIcebergDeleteFileDesc) FastWrite(buf []byte) int {
	return 0
}

func (p *TIcebergDeleteFileDesc) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TIcebergDeleteFileDesc")
	if p != nil {
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TIcebergDeleteFileDesc) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TIcebergDeleteFileDesc")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TIcebergDeleteFileDesc) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPath() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "path", thrift.STRING, 1)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Path)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TIcebergDeleteFileDesc) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPositionLowerBound() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "position_lower_bound", thrift.I64, 2)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.PositionLowerBound)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TIcebergDeleteFileDesc) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPositionUpperBound() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "position_upper_bound", thrift.I64, 3)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.PositionUpperBound)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TIcebergDeleteFileDesc) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFieldIds() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "field_ids", thrift.LIST, 4)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.I32, 0)
		var length int
		for _, v := range p.FieldIds {
			length++
			offset += bthrift.Binary.WriteI32(buf[offset:], v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.I32, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TIcebergDeleteFileDesc) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetContent() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "content", thrift.I32, 5)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.Content)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TIcebergDeleteFileDesc) field1Length() int {
	l := 0
	if p.IsSetPath() {
		l += bthrift.Binary.FieldBeginLength("path", thrift.STRING, 1)
		l += bthrift.Binary.StringLengthNocopy(*p.Path)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TIcebergDeleteFileDesc) field2Length() int {
	l := 0
	if p.IsSetPositionLowerBound() {
		l += bthrift.Binary.FieldBeginLength("position_lower_bound", thrift.I64, 2)
		l += bthrift.Binary.I64Length(*p.PositionLowerBound)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TIcebergDeleteFileDesc) field3Length() int {
	l := 0
	if p.IsSetPositionUpperBound() {
		l += bthrift.Binary.FieldBeginLength("position_upper_bound", thrift.I64, 3)
		l += bthrift.Binary.I64Length(*p.PositionUpperBound)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TIcebergDeleteFileDesc) field4Length() int {
	l := 0
	if p.IsSetFieldIds() {
		l += bthrift.Binary.FieldBeginLength("field_ids", thrift.LIST, 4)
		l += bthrift.Binary.ListBeginLength(thrift.I32, len(p.FieldIds))
		var tmpV int32
		l += bthrift.Binary.I32Length(int32(tmpV)) * len(p.FieldIds)
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TIcebergDeleteFileDesc) field5Length() int {
	l := 0
	if p.IsSetContent() {
		l += bthrift.Binary.FieldBeginLength("content", thrift.I32, 5)
		l += bthrift.Binary.I32Length(*p.Content)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TIcebergFileDesc) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TIcebergFileDesc[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TIcebergFileDesc) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.FormatVersion = &v

	}
	return offset, nil
}

func (p *TIcebergFileDesc) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Content = &v

	}
	return offset, nil
}

func (p *TIcebergFileDesc) FastReadField3(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.DeleteFiles = make([]*TIcebergDeleteFileDesc, 0, size)
	for i := 0; i < size; i++ {
		_elem := NewTIcebergDeleteFileDesc()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.DeleteFiles = append(p.DeleteFiles, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TIcebergFileDesc) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.DeleteTableTupleId = &v

	}
	return offset, nil
}

func (p *TIcebergFileDesc) FastReadField5(buf []byte) (int, error) {
	offset := 0

	tmp := exprs.NewTExpr()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.FileSelectConjunct = tmp
	return offset, nil
}

func (p *TIcebergFileDesc) FastReadField6(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.OriginalFilePath = &v

	}
	return offset, nil
}

// for compatibility
func (p *TIcebergFileDesc) FastWrite(buf []byte) int {
	return 0
}

func (p *TIcebergFileDesc) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TIcebergFileDesc")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TIcebergFileDesc) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TIcebergFileDesc")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TIcebergFileDesc) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFormatVersion() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "format_version", thrift.I32, 1)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.FormatVersion)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TIcebergFileDesc) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetContent() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "content", thrift.I32, 2)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.Content)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TIcebergFileDesc) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDeleteFiles() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "delete_files", thrift.LIST, 3)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.DeleteFiles {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TIcebergFileDesc) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDeleteTableTupleId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "delete_table_tuple_id", thrift.I32, 4)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.DeleteTableTupleId)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TIcebergFileDesc) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFileSelectConjunct() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "file_select_conjunct", thrift.STRUCT, 5)
		offset += p.FileSelectConjunct.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TIcebergFileDesc) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetOriginalFilePath() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "original_file_path", thrift.STRING, 6)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.OriginalFilePath)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TIcebergFileDesc) field1Length() int {
	l := 0
	if p.IsSetFormatVersion() {
		l += bthrift.Binary.FieldBeginLength("format_version", thrift.I32, 1)
		l += bthrift.Binary.I32Length(*p.FormatVersion)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TIcebergFileDesc) field2Length() int {
	l := 0
	if p.IsSetContent() {
		l += bthrift.Binary.FieldBeginLength("content", thrift.I32, 2)
		l += bthrift.Binary.I32Length(*p.Content)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TIcebergFileDesc) field3Length() int {
	l := 0
	if p.IsSetDeleteFiles() {
		l += bthrift.Binary.FieldBeginLength("delete_files", thrift.LIST, 3)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.DeleteFiles))
		for _, v := range p.DeleteFiles {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TIcebergFileDesc) field4Length() int {
	l := 0
	if p.IsSetDeleteTableTupleId() {
		l += bthrift.Binary.FieldBeginLength("delete_table_tuple_id", thrift.I32, 4)
		l += bthrift.Binary.I32Length(*p.DeleteTableTupleId)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TIcebergFileDesc) field5Length() int {
	l := 0
	if p.IsSetFileSelectConjunct() {
		l += bthrift.Binary.FieldBeginLength("file_select_conjunct", thrift.STRUCT, 5)
		l += p.FileSelectConjunct.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TIcebergFileDesc) field6Length() int {
	l := 0
	if p.IsSetOriginalFilePath() {
		l += bthrift.Binary.FieldBeginLength("original_file_path", thrift.STRING, 6)
		l += bthrift.Binary.StringLengthNocopy(*p.OriginalFilePath)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPaimonDeletionFileDesc) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TPaimonDeletionFileDesc[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TPaimonDeletionFileDesc) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Path = &v

	}
	return offset, nil
}

func (p *TPaimonDeletionFileDesc) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Offset = &v

	}
	return offset, nil
}

func (p *TPaimonDeletionFileDesc) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Length = &v

	}
	return offset, nil
}

// for compatibility
func (p *TPaimonDeletionFileDesc) FastWrite(buf []byte) int {
	return 0
}

func (p *TPaimonDeletionFileDesc) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TPaimonDeletionFileDesc")
	if p != nil {
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TPaimonDeletionFileDesc) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TPaimonDeletionFileDesc")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TPaimonDeletionFileDesc) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPath() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "path", thrift.STRING, 1)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Path)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPaimonDeletionFileDesc) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetOffset() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "offset", thrift.I64, 2)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.Offset)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPaimonDeletionFileDesc) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetLength() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "length", thrift.I64, 3)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.Length)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPaimonDeletionFileDesc) field1Length() int {
	l := 0
	if p.IsSetPath() {
		l += bthrift.Binary.FieldBeginLength("path", thrift.STRING, 1)
		l += bthrift.Binary.StringLengthNocopy(*p.Path)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPaimonDeletionFileDesc) field2Length() int {
	l := 0
	if p.IsSetOffset() {
		l += bthrift.Binary.FieldBeginLength("offset", thrift.I64, 2)
		l += bthrift.Binary.I64Length(*p.Offset)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPaimonDeletionFileDesc) field3Length() int {
	l := 0
	if p.IsSetLength() {
		l += bthrift.Binary.FieldBeginLength("length", thrift.I64, 3)
		l += bthrift.Binary.I64Length(*p.Length)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPaimonFileDesc) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField9(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 11:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField11(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 12:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField12(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 13:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField13(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TPaimonFileDesc[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TPaimonFileDesc) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.PaimonSplit = &v

	}
	return offset, nil
}

func (p *TPaimonFileDesc) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.PaimonColumnNames = &v

	}
	return offset, nil
}

func (p *TPaimonFileDesc) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.DbName = &v

	}
	return offset, nil
}

func (p *TPaimonFileDesc) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.TableName = &v

	}
	return offset, nil
}

func (p *TPaimonFileDesc) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.PaimonPredicate = &v

	}
	return offset, nil
}

func (p *TPaimonFileDesc) FastReadField6(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := bthrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.PaimonOptions = make(map[string]string, size)
	for i := 0; i < size; i++ {
		var _key string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_key = v

		}

		var _val string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_val = v

		}

		p.PaimonOptions[_key] = _val
	}
	if l, err := bthrift.Binary.ReadMapEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TPaimonFileDesc) FastReadField7(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.CtlId = &v

	}
	return offset, nil
}

func (p *TPaimonFileDesc) FastReadField8(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.DbId = &v

	}
	return offset, nil
}

func (p *TPaimonFileDesc) FastReadField9(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.TblId = &v

	}
	return offset, nil
}

func (p *TPaimonFileDesc) FastReadField10(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.LastUpdateTime = &v

	}
	return offset, nil
}

func (p *TPaimonFileDesc) FastReadField11(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.FileFormat = &v

	}
	return offset, nil
}

func (p *TPaimonFileDesc) FastReadField12(buf []byte) (int, error) {
	offset := 0

	tmp := NewTPaimonDeletionFileDesc()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.DeletionFile = tmp
	return offset, nil
}

func (p *TPaimonFileDesc) FastReadField13(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := bthrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.HadoopConf = make(map[string]string, size)
	for i := 0; i < size; i++ {
		var _key string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_key = v

		}

		var _val string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_val = v

		}

		p.HadoopConf[_key] = _val
	}
	if l, err := bthrift.Binary.ReadMapEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

// for compatibility
func (p *TPaimonFileDesc) FastWrite(buf []byte) int {
	return 0
}

func (p *TPaimonFileDesc) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TPaimonFileDesc")
	if p != nil {
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
		offset += p.fastWriteField9(buf[offset:], binaryWriter)
		offset += p.fastWriteField10(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField11(buf[offset:], binaryWriter)
		offset += p.fastWriteField12(buf[offset:], binaryWriter)
		offset += p.fastWriteField13(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TPaimonFileDesc) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TPaimonFileDesc")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field9Length()
		l += p.field10Length()
		l += p.field11Length()
		l += p.field12Length()
		l += p.field13Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TPaimonFileDesc) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPaimonSplit() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "paimon_split", thrift.STRING, 1)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.PaimonSplit)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPaimonFileDesc) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPaimonColumnNames() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "paimon_column_names", thrift.STRING, 2)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.PaimonColumnNames)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPaimonFileDesc) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDbName() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "db_name", thrift.STRING, 3)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.DbName)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPaimonFileDesc) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTableName() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "table_name", thrift.STRING, 4)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.TableName)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPaimonFileDesc) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPaimonPredicate() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "paimon_predicate", thrift.STRING, 5)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.PaimonPredicate)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPaimonFileDesc) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPaimonOptions() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "paimon_options", thrift.MAP, 6)
		mapBeginOffset := offset
		offset += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRING, 0)
		var length int
		for k, v := range p.PaimonOptions {
			length++

			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, k)

			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.STRING, thrift.STRING, length)
		offset += bthrift.Binary.WriteMapEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPaimonFileDesc) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetCtlId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "ctl_id", thrift.I64, 7)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.CtlId)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPaimonFileDesc) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDbId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "db_id", thrift.I64, 8)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.DbId)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPaimonFileDesc) fastWriteField9(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTblId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tbl_id", thrift.I64, 9)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.TblId)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPaimonFileDesc) fastWriteField10(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetLastUpdateTime() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "last_update_time", thrift.I64, 10)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.LastUpdateTime)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPaimonFileDesc) fastWriteField11(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFileFormat() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "file_format", thrift.STRING, 11)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.FileFormat)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPaimonFileDesc) fastWriteField12(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDeletionFile() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "deletion_file", thrift.STRUCT, 12)
		offset += p.DeletionFile.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPaimonFileDesc) fastWriteField13(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetHadoopConf() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "hadoop_conf", thrift.MAP, 13)
		mapBeginOffset := offset
		offset += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRING, 0)
		var length int
		for k, v := range p.HadoopConf {
			length++

			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, k)

			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.STRING, thrift.STRING, length)
		offset += bthrift.Binary.WriteMapEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPaimonFileDesc) field1Length() int {
	l := 0
	if p.IsSetPaimonSplit() {
		l += bthrift.Binary.FieldBeginLength("paimon_split", thrift.STRING, 1)
		l += bthrift.Binary.StringLengthNocopy(*p.PaimonSplit)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPaimonFileDesc) field2Length() int {
	l := 0
	if p.IsSetPaimonColumnNames() {
		l += bthrift.Binary.FieldBeginLength("paimon_column_names", thrift.STRING, 2)
		l += bthrift.Binary.StringLengthNocopy(*p.PaimonColumnNames)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPaimonFileDesc) field3Length() int {
	l := 0
	if p.IsSetDbName() {
		l += bthrift.Binary.FieldBeginLength("db_name", thrift.STRING, 3)
		l += bthrift.Binary.StringLengthNocopy(*p.DbName)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPaimonFileDesc) field4Length() int {
	l := 0
	if p.IsSetTableName() {
		l += bthrift.Binary.FieldBeginLength("table_name", thrift.STRING, 4)
		l += bthrift.Binary.StringLengthNocopy(*p.TableName)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPaimonFileDesc) field5Length() int {
	l := 0
	if p.IsSetPaimonPredicate() {
		l += bthrift.Binary.FieldBeginLength("paimon_predicate", thrift.STRING, 5)
		l += bthrift.Binary.StringLengthNocopy(*p.PaimonPredicate)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPaimonFileDesc) field6Length() int {
	l := 0
	if p.IsSetPaimonOptions() {
		l += bthrift.Binary.FieldBeginLength("paimon_options", thrift.MAP, 6)
		l += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRING, len(p.PaimonOptions))
		for k, v := range p.PaimonOptions {

			l += bthrift.Binary.StringLengthNocopy(k)

			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.MapEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPaimonFileDesc) field7Length() int {
	l := 0
	if p.IsSetCtlId() {
		l += bthrift.Binary.FieldBeginLength("ctl_id", thrift.I64, 7)
		l += bthrift.Binary.I64Length(*p.CtlId)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPaimonFileDesc) field8Length() int {
	l := 0
	if p.IsSetDbId() {
		l += bthrift.Binary.FieldBeginLength("db_id", thrift.I64, 8)
		l += bthrift.Binary.I64Length(*p.DbId)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPaimonFileDesc) field9Length() int {
	l := 0
	if p.IsSetTblId() {
		l += bthrift.Binary.FieldBeginLength("tbl_id", thrift.I64, 9)
		l += bthrift.Binary.I64Length(*p.TblId)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPaimonFileDesc) field10Length() int {
	l := 0
	if p.IsSetLastUpdateTime() {
		l += bthrift.Binary.FieldBeginLength("last_update_time", thrift.I64, 10)
		l += bthrift.Binary.I64Length(*p.LastUpdateTime)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPaimonFileDesc) field11Length() int {
	l := 0
	if p.IsSetFileFormat() {
		l += bthrift.Binary.FieldBeginLength("file_format", thrift.STRING, 11)
		l += bthrift.Binary.StringLengthNocopy(*p.FileFormat)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPaimonFileDesc) field12Length() int {
	l := 0
	if p.IsSetDeletionFile() {
		l += bthrift.Binary.FieldBeginLength("deletion_file", thrift.STRUCT, 12)
		l += p.DeletionFile.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPaimonFileDesc) field13Length() int {
	l := 0
	if p.IsSetHadoopConf() {
		l += bthrift.Binary.FieldBeginLength("hadoop_conf", thrift.MAP, 13)
		l += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRING, len(p.HadoopConf))
		for k, v := range p.HadoopConf {

			l += bthrift.Binary.StringLengthNocopy(k)

			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.MapEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTrinoConnectorFileDesc) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField9(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 11:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField11(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TTrinoConnectorFileDesc[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TTrinoConnectorFileDesc) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.CatalogName = &v

	}
	return offset, nil
}

func (p *TTrinoConnectorFileDesc) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.DbName = &v

	}
	return offset, nil
}

func (p *TTrinoConnectorFileDesc) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.TableName = &v

	}
	return offset, nil
}

func (p *TTrinoConnectorFileDesc) FastReadField4(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := bthrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.TrinoConnectorOptions = make(map[string]string, size)
	for i := 0; i < size; i++ {
		var _key string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_key = v

		}

		var _val string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_val = v

		}

		p.TrinoConnectorOptions[_key] = _val
	}
	if l, err := bthrift.Binary.ReadMapEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TTrinoConnectorFileDesc) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.TrinoConnectorTableHandle = &v

	}
	return offset, nil
}

func (p *TTrinoConnectorFileDesc) FastReadField6(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.TrinoConnectorColumnHandles = &v

	}
	return offset, nil
}

func (p *TTrinoConnectorFileDesc) FastReadField7(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.TrinoConnectorColumnMetadata = &v

	}
	return offset, nil
}

func (p *TTrinoConnectorFileDesc) FastReadField8(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.TrinoConnectorColumnNames = &v

	}
	return offset, nil
}

func (p *TTrinoConnectorFileDesc) FastReadField9(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.TrinoConnectorSplit = &v

	}
	return offset, nil
}

func (p *TTrinoConnectorFileDesc) FastReadField10(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.TrinoConnectorPredicate = &v

	}
	return offset, nil
}

func (p *TTrinoConnectorFileDesc) FastReadField11(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.TrinoConnectorTrascationHandle = &v

	}
	return offset, nil
}

// for compatibility
func (p *TTrinoConnectorFileDesc) FastWrite(buf []byte) int {
	return 0
}

func (p *TTrinoConnectorFileDesc) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TTrinoConnectorFileDesc")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
		offset += p.fastWriteField9(buf[offset:], binaryWriter)
		offset += p.fastWriteField10(buf[offset:], binaryWriter)
		offset += p.fastWriteField11(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TTrinoConnectorFileDesc) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TTrinoConnectorFileDesc")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field9Length()
		l += p.field10Length()
		l += p.field11Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TTrinoConnectorFileDesc) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetCatalogName() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "catalog_name", thrift.STRING, 1)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.CatalogName)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTrinoConnectorFileDesc) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDbName() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "db_name", thrift.STRING, 2)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.DbName)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTrinoConnectorFileDesc) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTableName() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "table_name", thrift.STRING, 3)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.TableName)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTrinoConnectorFileDesc) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTrinoConnectorOptions() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "trino_connector_options", thrift.MAP, 4)
		mapBeginOffset := offset
		offset += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRING, 0)
		var length int
		for k, v := range p.TrinoConnectorOptions {
			length++

			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, k)

			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.STRING, thrift.STRING, length)
		offset += bthrift.Binary.WriteMapEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTrinoConnectorFileDesc) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTrinoConnectorTableHandle() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "trino_connector_table_handle", thrift.STRING, 5)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.TrinoConnectorTableHandle)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTrinoConnectorFileDesc) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTrinoConnectorColumnHandles() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "trino_connector_column_handles", thrift.STRING, 6)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.TrinoConnectorColumnHandles)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTrinoConnectorFileDesc) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTrinoConnectorColumnMetadata() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "trino_connector_column_metadata", thrift.STRING, 7)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.TrinoConnectorColumnMetadata)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTrinoConnectorFileDesc) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTrinoConnectorColumnNames() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "trino_connector_column_names", thrift.STRING, 8)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.TrinoConnectorColumnNames)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTrinoConnectorFileDesc) fastWriteField9(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTrinoConnectorSplit() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "trino_connector_split", thrift.STRING, 9)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.TrinoConnectorSplit)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTrinoConnectorFileDesc) fastWriteField10(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTrinoConnectorPredicate() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "trino_connector_predicate", thrift.STRING, 10)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.TrinoConnectorPredicate)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTrinoConnectorFileDesc) fastWriteField11(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTrinoConnectorTrascationHandle() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "trino_connector_trascation_handle", thrift.STRING, 11)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.TrinoConnectorTrascationHandle)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTrinoConnectorFileDesc) field1Length() int {
	l := 0
	if p.IsSetCatalogName() {
		l += bthrift.Binary.FieldBeginLength("catalog_name", thrift.STRING, 1)
		l += bthrift.Binary.StringLengthNocopy(*p.CatalogName)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTrinoConnectorFileDesc) field2Length() int {
	l := 0
	if p.IsSetDbName() {
		l += bthrift.Binary.FieldBeginLength("db_name", thrift.STRING, 2)
		l += bthrift.Binary.StringLengthNocopy(*p.DbName)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTrinoConnectorFileDesc) field3Length() int {
	l := 0
	if p.IsSetTableName() {
		l += bthrift.Binary.FieldBeginLength("table_name", thrift.STRING, 3)
		l += bthrift.Binary.StringLengthNocopy(*p.TableName)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTrinoConnectorFileDesc) field4Length() int {
	l := 0
	if p.IsSetTrinoConnectorOptions() {
		l += bthrift.Binary.FieldBeginLength("trino_connector_options", thrift.MAP, 4)
		l += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRING, len(p.TrinoConnectorOptions))
		for k, v := range p.TrinoConnectorOptions {

			l += bthrift.Binary.StringLengthNocopy(k)

			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.MapEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTrinoConnectorFileDesc) field5Length() int {
	l := 0
	if p.IsSetTrinoConnectorTableHandle() {
		l += bthrift.Binary.FieldBeginLength("trino_connector_table_handle", thrift.STRING, 5)
		l += bthrift.Binary.StringLengthNocopy(*p.TrinoConnectorTableHandle)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTrinoConnectorFileDesc) field6Length() int {
	l := 0
	if p.IsSetTrinoConnectorColumnHandles() {
		l += bthrift.Binary.FieldBeginLength("trino_connector_column_handles", thrift.STRING, 6)
		l += bthrift.Binary.StringLengthNocopy(*p.TrinoConnectorColumnHandles)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTrinoConnectorFileDesc) field7Length() int {
	l := 0
	if p.IsSetTrinoConnectorColumnMetadata() {
		l += bthrift.Binary.FieldBeginLength("trino_connector_column_metadata", thrift.STRING, 7)
		l += bthrift.Binary.StringLengthNocopy(*p.TrinoConnectorColumnMetadata)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTrinoConnectorFileDesc) field8Length() int {
	l := 0
	if p.IsSetTrinoConnectorColumnNames() {
		l += bthrift.Binary.FieldBeginLength("trino_connector_column_names", thrift.STRING, 8)
		l += bthrift.Binary.StringLengthNocopy(*p.TrinoConnectorColumnNames)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTrinoConnectorFileDesc) field9Length() int {
	l := 0
	if p.IsSetTrinoConnectorSplit() {
		l += bthrift.Binary.FieldBeginLength("trino_connector_split", thrift.STRING, 9)
		l += bthrift.Binary.StringLengthNocopy(*p.TrinoConnectorSplit)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTrinoConnectorFileDesc) field10Length() int {
	l := 0
	if p.IsSetTrinoConnectorPredicate() {
		l += bthrift.Binary.FieldBeginLength("trino_connector_predicate", thrift.STRING, 10)
		l += bthrift.Binary.StringLengthNocopy(*p.TrinoConnectorPredicate)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTrinoConnectorFileDesc) field11Length() int {
	l := 0
	if p.IsSetTrinoConnectorTrascationHandle() {
		l += bthrift.Binary.FieldBeginLength("trino_connector_trascation_handle", thrift.STRING, 11)
		l += bthrift.Binary.StringLengthNocopy(*p.TrinoConnectorTrascationHandle)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TMaxComputeFileDesc) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TMaxComputeFileDesc[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TMaxComputeFileDesc) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.PartitionSpec = &v

	}
	return offset, nil
}

// for compatibility
func (p *TMaxComputeFileDesc) FastWrite(buf []byte) int {
	return 0
}

func (p *TMaxComputeFileDesc) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TMaxComputeFileDesc")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TMaxComputeFileDesc) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TMaxComputeFileDesc")
	if p != nil {
		l += p.field1Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TMaxComputeFileDesc) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPartitionSpec() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "partition_spec", thrift.STRING, 1)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.PartitionSpec)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TMaxComputeFileDesc) field1Length() int {
	l := 0
	if p.IsSetPartitionSpec() {
		l += bthrift.Binary.FieldBeginLength("partition_spec", thrift.STRING, 1)
		l += bthrift.Binary.StringLengthNocopy(*p.PartitionSpec)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THudiFileDesc) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField9(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_THudiFileDesc[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *THudiFileDesc) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.InstantTime = &v

	}
	return offset, nil
}

func (p *THudiFileDesc) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Serde = &v

	}
	return offset, nil
}

func (p *THudiFileDesc) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.InputFormat = &v

	}
	return offset, nil
}

func (p *THudiFileDesc) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.BasePath = &v

	}
	return offset, nil
}

func (p *THudiFileDesc) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.DataFilePath = &v

	}
	return offset, nil
}

func (p *THudiFileDesc) FastReadField6(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.DataFileLength = &v

	}
	return offset, nil
}

func (p *THudiFileDesc) FastReadField7(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.DeltaLogs = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.DeltaLogs = append(p.DeltaLogs, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *THudiFileDesc) FastReadField8(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.ColumnNames = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.ColumnNames = append(p.ColumnNames, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *THudiFileDesc) FastReadField9(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.ColumnTypes = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.ColumnTypes = append(p.ColumnTypes, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *THudiFileDesc) FastReadField10(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.NestedFields = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.NestedFields = append(p.NestedFields, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

// for compatibility
func (p *THudiFileDesc) FastWrite(buf []byte) int {
	return 0
}

func (p *THudiFileDesc) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "THudiFileDesc")
	if p != nil {
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
		offset += p.fastWriteField9(buf[offset:], binaryWriter)
		offset += p.fastWriteField10(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *THudiFileDesc) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("THudiFileDesc")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field9Length()
		l += p.field10Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *THudiFileDesc) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetInstantTime() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "instant_time", thrift.STRING, 1)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.InstantTime)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THudiFileDesc) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSerde() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "serde", thrift.STRING, 2)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Serde)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THudiFileDesc) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetInputFormat() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "input_format", thrift.STRING, 3)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.InputFormat)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THudiFileDesc) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetBasePath() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "base_path", thrift.STRING, 4)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.BasePath)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THudiFileDesc) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDataFilePath() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "data_file_path", thrift.STRING, 5)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.DataFilePath)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THudiFileDesc) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDataFileLength() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "data_file_length", thrift.I64, 6)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.DataFileLength)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THudiFileDesc) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDeltaLogs() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "delta_logs", thrift.LIST, 7)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRING, 0)
		var length int
		for _, v := range p.DeltaLogs {
			length++
			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRING, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THudiFileDesc) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetColumnNames() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "column_names", thrift.LIST, 8)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRING, 0)
		var length int
		for _, v := range p.ColumnNames {
			length++
			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRING, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THudiFileDesc) fastWriteField9(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetColumnTypes() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "column_types", thrift.LIST, 9)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRING, 0)
		var length int
		for _, v := range p.ColumnTypes {
			length++
			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRING, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THudiFileDesc) fastWriteField10(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetNestedFields() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "nested_fields", thrift.LIST, 10)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRING, 0)
		var length int
		for _, v := range p.NestedFields {
			length++
			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRING, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THudiFileDesc) field1Length() int {
	l := 0
	if p.IsSetInstantTime() {
		l += bthrift.Binary.FieldBeginLength("instant_time", thrift.STRING, 1)
		l += bthrift.Binary.StringLengthNocopy(*p.InstantTime)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THudiFileDesc) field2Length() int {
	l := 0
	if p.IsSetSerde() {
		l += bthrift.Binary.FieldBeginLength("serde", thrift.STRING, 2)
		l += bthrift.Binary.StringLengthNocopy(*p.Serde)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THudiFileDesc) field3Length() int {
	l := 0
	if p.IsSetInputFormat() {
		l += bthrift.Binary.FieldBeginLength("input_format", thrift.STRING, 3)
		l += bthrift.Binary.StringLengthNocopy(*p.InputFormat)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THudiFileDesc) field4Length() int {
	l := 0
	if p.IsSetBasePath() {
		l += bthrift.Binary.FieldBeginLength("base_path", thrift.STRING, 4)
		l += bthrift.Binary.StringLengthNocopy(*p.BasePath)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THudiFileDesc) field5Length() int {
	l := 0
	if p.IsSetDataFilePath() {
		l += bthrift.Binary.FieldBeginLength("data_file_path", thrift.STRING, 5)
		l += bthrift.Binary.StringLengthNocopy(*p.DataFilePath)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THudiFileDesc) field6Length() int {
	l := 0
	if p.IsSetDataFileLength() {
		l += bthrift.Binary.FieldBeginLength("data_file_length", thrift.I64, 6)
		l += bthrift.Binary.I64Length(*p.DataFileLength)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THudiFileDesc) field7Length() int {
	l := 0
	if p.IsSetDeltaLogs() {
		l += bthrift.Binary.FieldBeginLength("delta_logs", thrift.LIST, 7)
		l += bthrift.Binary.ListBeginLength(thrift.STRING, len(p.DeltaLogs))
		for _, v := range p.DeltaLogs {
			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THudiFileDesc) field8Length() int {
	l := 0
	if p.IsSetColumnNames() {
		l += bthrift.Binary.FieldBeginLength("column_names", thrift.LIST, 8)
		l += bthrift.Binary.ListBeginLength(thrift.STRING, len(p.ColumnNames))
		for _, v := range p.ColumnNames {
			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THudiFileDesc) field9Length() int {
	l := 0
	if p.IsSetColumnTypes() {
		l += bthrift.Binary.FieldBeginLength("column_types", thrift.LIST, 9)
		l += bthrift.Binary.ListBeginLength(thrift.STRING, len(p.ColumnTypes))
		for _, v := range p.ColumnTypes {
			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THudiFileDesc) field10Length() int {
	l := 0
	if p.IsSetNestedFields() {
		l += bthrift.Binary.FieldBeginLength("nested_fields", thrift.LIST, 10)
		l += bthrift.Binary.ListBeginLength(thrift.STRING, len(p.NestedFields))
		for _, v := range p.NestedFields {
			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TLakeSoulFileDesc) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TLakeSoulFileDesc[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TLakeSoulFileDesc) FastReadField1(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.FilePaths = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.FilePaths = append(p.FilePaths, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TLakeSoulFileDesc) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.PrimaryKeys = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.PrimaryKeys = append(p.PrimaryKeys, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TLakeSoulFileDesc) FastReadField3(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.PartitionDescs = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.PartitionDescs = append(p.PartitionDescs, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TLakeSoulFileDesc) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.TableSchema = &v

	}
	return offset, nil
}

func (p *TLakeSoulFileDesc) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Options = &v

	}
	return offset, nil
}

// for compatibility
func (p *TLakeSoulFileDesc) FastWrite(buf []byte) int {
	return 0
}

func (p *TLakeSoulFileDesc) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TLakeSoulFileDesc")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TLakeSoulFileDesc) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TLakeSoulFileDesc")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TLakeSoulFileDesc) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFilePaths() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "file_paths", thrift.LIST, 1)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRING, 0)
		var length int
		for _, v := range p.FilePaths {
			length++
			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRING, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TLakeSoulFileDesc) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPrimaryKeys() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "primary_keys", thrift.LIST, 2)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRING, 0)
		var length int
		for _, v := range p.PrimaryKeys {
			length++
			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRING, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TLakeSoulFileDesc) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPartitionDescs() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "partition_descs", thrift.LIST, 3)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRING, 0)
		var length int
		for _, v := range p.PartitionDescs {
			length++
			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRING, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TLakeSoulFileDesc) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTableSchema() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "table_schema", thrift.STRING, 4)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.TableSchema)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TLakeSoulFileDesc) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetOptions() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "options", thrift.STRING, 5)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Options)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TLakeSoulFileDesc) field1Length() int {
	l := 0
	if p.IsSetFilePaths() {
		l += bthrift.Binary.FieldBeginLength("file_paths", thrift.LIST, 1)
		l += bthrift.Binary.ListBeginLength(thrift.STRING, len(p.FilePaths))
		for _, v := range p.FilePaths {
			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TLakeSoulFileDesc) field2Length() int {
	l := 0
	if p.IsSetPrimaryKeys() {
		l += bthrift.Binary.FieldBeginLength("primary_keys", thrift.LIST, 2)
		l += bthrift.Binary.ListBeginLength(thrift.STRING, len(p.PrimaryKeys))
		for _, v := range p.PrimaryKeys {
			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TLakeSoulFileDesc) field3Length() int {
	l := 0
	if p.IsSetPartitionDescs() {
		l += bthrift.Binary.FieldBeginLength("partition_descs", thrift.LIST, 3)
		l += bthrift.Binary.ListBeginLength(thrift.STRING, len(p.PartitionDescs))
		for _, v := range p.PartitionDescs {
			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TLakeSoulFileDesc) field4Length() int {
	l := 0
	if p.IsSetTableSchema() {
		l += bthrift.Binary.FieldBeginLength("table_schema", thrift.STRING, 4)
		l += bthrift.Binary.StringLengthNocopy(*p.TableSchema)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TLakeSoulFileDesc) field5Length() int {
	l := 0
	if p.IsSetOptions() {
		l += bthrift.Binary.FieldBeginLength("options", thrift.STRING, 5)
		l += bthrift.Binary.StringLengthNocopy(*p.Options)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTransactionalHiveDeleteDeltaDesc) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TTransactionalHiveDeleteDeltaDesc[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TTransactionalHiveDeleteDeltaDesc) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.DirectoryLocation = &v

	}
	return offset, nil
}

func (p *TTransactionalHiveDeleteDeltaDesc) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.FileNames = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.FileNames = append(p.FileNames, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

// for compatibility
func (p *TTransactionalHiveDeleteDeltaDesc) FastWrite(buf []byte) int {
	return 0
}

func (p *TTransactionalHiveDeleteDeltaDesc) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TTransactionalHiveDeleteDeltaDesc")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TTransactionalHiveDeleteDeltaDesc) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TTransactionalHiveDeleteDeltaDesc")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TTransactionalHiveDeleteDeltaDesc) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDirectoryLocation() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "directory_location", thrift.STRING, 1)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.DirectoryLocation)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTransactionalHiveDeleteDeltaDesc) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFileNames() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "file_names", thrift.LIST, 2)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRING, 0)
		var length int
		for _, v := range p.FileNames {
			length++
			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRING, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTransactionalHiveDeleteDeltaDesc) field1Length() int {
	l := 0
	if p.IsSetDirectoryLocation() {
		l += bthrift.Binary.FieldBeginLength("directory_location", thrift.STRING, 1)
		l += bthrift.Binary.StringLengthNocopy(*p.DirectoryLocation)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTransactionalHiveDeleteDeltaDesc) field2Length() int {
	l := 0
	if p.IsSetFileNames() {
		l += bthrift.Binary.FieldBeginLength("file_names", thrift.LIST, 2)
		l += bthrift.Binary.ListBeginLength(thrift.STRING, len(p.FileNames))
		for _, v := range p.FileNames {
			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTransactionalHiveDesc) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TTransactionalHiveDesc[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TTransactionalHiveDesc) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Partition = &v

	}
	return offset, nil
}

func (p *TTransactionalHiveDesc) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.DeleteDeltas = make([]*TTransactionalHiveDeleteDeltaDesc, 0, size)
	for i := 0; i < size; i++ {
		_elem := NewTTransactionalHiveDeleteDeltaDesc()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.DeleteDeltas = append(p.DeleteDeltas, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

// for compatibility
func (p *TTransactionalHiveDesc) FastWrite(buf []byte) int {
	return 0
}

func (p *TTransactionalHiveDesc) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TTransactionalHiveDesc")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TTransactionalHiveDesc) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TTransactionalHiveDesc")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TTransactionalHiveDesc) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPartition() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "partition", thrift.STRING, 1)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Partition)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTransactionalHiveDesc) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDeleteDeltas() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "delete_deltas", thrift.LIST, 2)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.DeleteDeltas {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTransactionalHiveDesc) field1Length() int {
	l := 0
	if p.IsSetPartition() {
		l += bthrift.Binary.FieldBeginLength("partition", thrift.STRING, 1)
		l += bthrift.Binary.StringLengthNocopy(*p.Partition)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTransactionalHiveDesc) field2Length() int {
	l := 0
	if p.IsSetDeleteDeltas() {
		l += bthrift.Binary.FieldBeginLength("delete_deltas", thrift.LIST, 2)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.DeleteDeltas))
		for _, v := range p.DeleteDeltas {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTableFormatFileDesc) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TTableFormatFileDesc[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TTableFormatFileDesc) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.TableFormatType = &v

	}
	return offset, nil
}

func (p *TTableFormatFileDesc) FastReadField2(buf []byte) (int, error) {
	offset := 0

	tmp := NewTIcebergFileDesc()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.IcebergParams = tmp
	return offset, nil
}

func (p *TTableFormatFileDesc) FastReadField3(buf []byte) (int, error) {
	offset := 0

	tmp := NewTHudiFileDesc()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.HudiParams = tmp
	return offset, nil
}

func (p *TTableFormatFileDesc) FastReadField4(buf []byte) (int, error) {
	offset := 0

	tmp := NewTPaimonFileDesc()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.PaimonParams = tmp
	return offset, nil
}

func (p *TTableFormatFileDesc) FastReadField5(buf []byte) (int, error) {
	offset := 0

	tmp := NewTTransactionalHiveDesc()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.TransactionalHiveParams = tmp
	return offset, nil
}

func (p *TTableFormatFileDesc) FastReadField6(buf []byte) (int, error) {
	offset := 0

	tmp := NewTMaxComputeFileDesc()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.MaxComputeParams = tmp
	return offset, nil
}

func (p *TTableFormatFileDesc) FastReadField7(buf []byte) (int, error) {
	offset := 0

	tmp := NewTTrinoConnectorFileDesc()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.TrinoConnectorParams = tmp
	return offset, nil
}

func (p *TTableFormatFileDesc) FastReadField8(buf []byte) (int, error) {
	offset := 0

	tmp := NewTLakeSoulFileDesc()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.LakesoulParams = tmp
	return offset, nil
}

// for compatibility
func (p *TTableFormatFileDesc) FastWrite(buf []byte) int {
	return 0
}

func (p *TTableFormatFileDesc) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TTableFormatFileDesc")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TTableFormatFileDesc) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TTableFormatFileDesc")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TTableFormatFileDesc) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTableFormatType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "table_format_type", thrift.STRING, 1)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.TableFormatType)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTableFormatFileDesc) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIcebergParams() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "iceberg_params", thrift.STRUCT, 2)
		offset += p.IcebergParams.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTableFormatFileDesc) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetHudiParams() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "hudi_params", thrift.STRUCT, 3)
		offset += p.HudiParams.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTableFormatFileDesc) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPaimonParams() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "paimon_params", thrift.STRUCT, 4)
		offset += p.PaimonParams.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTableFormatFileDesc) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTransactionalHiveParams() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "transactional_hive_params", thrift.STRUCT, 5)
		offset += p.TransactionalHiveParams.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTableFormatFileDesc) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetMaxComputeParams() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "max_compute_params", thrift.STRUCT, 6)
		offset += p.MaxComputeParams.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTableFormatFileDesc) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTrinoConnectorParams() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "trino_connector_params", thrift.STRUCT, 7)
		offset += p.TrinoConnectorParams.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTableFormatFileDesc) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetLakesoulParams() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "lakesoul_params", thrift.STRUCT, 8)
		offset += p.LakesoulParams.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTableFormatFileDesc) field1Length() int {
	l := 0
	if p.IsSetTableFormatType() {
		l += bthrift.Binary.FieldBeginLength("table_format_type", thrift.STRING, 1)
		l += bthrift.Binary.StringLengthNocopy(*p.TableFormatType)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTableFormatFileDesc) field2Length() int {
	l := 0
	if p.IsSetIcebergParams() {
		l += bthrift.Binary.FieldBeginLength("iceberg_params", thrift.STRUCT, 2)
		l += p.IcebergParams.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTableFormatFileDesc) field3Length() int {
	l := 0
	if p.IsSetHudiParams() {
		l += bthrift.Binary.FieldBeginLength("hudi_params", thrift.STRUCT, 3)
		l += p.HudiParams.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTableFormatFileDesc) field4Length() int {
	l := 0
	if p.IsSetPaimonParams() {
		l += bthrift.Binary.FieldBeginLength("paimon_params", thrift.STRUCT, 4)
		l += p.PaimonParams.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTableFormatFileDesc) field5Length() int {
	l := 0
	if p.IsSetTransactionalHiveParams() {
		l += bthrift.Binary.FieldBeginLength("transactional_hive_params", thrift.STRUCT, 5)
		l += p.TransactionalHiveParams.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTableFormatFileDesc) field6Length() int {
	l := 0
	if p.IsSetMaxComputeParams() {
		l += bthrift.Binary.FieldBeginLength("max_compute_params", thrift.STRUCT, 6)
		l += p.MaxComputeParams.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTableFormatFileDesc) field7Length() int {
	l := 0
	if p.IsSetTrinoConnectorParams() {
		l += bthrift.Binary.FieldBeginLength("trino_connector_params", thrift.STRUCT, 7)
		l += p.TrinoConnectorParams.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTableFormatFileDesc) field8Length() int {
	l := 0
	if p.IsSetLakesoulParams() {
		l += bthrift.Binary.FieldBeginLength("lakesoul_params", thrift.STRUCT, 8)
		l += p.LakesoulParams.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileScanRangeParams) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField9(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 11:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField11(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 12:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField12(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 13:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField13(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 14:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField14(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 15:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField15(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 16:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField16(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 17:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField17(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 18:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField18(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 19:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField19(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 20:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField20(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 21:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField21(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 22:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField22(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TFileScanRangeParams[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TFileScanRangeParams) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := types.TFileType(v)
		p.FileType = &tmp

	}
	return offset, nil
}

func (p *TFileScanRangeParams) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := TFileFormatType(v)
		p.FormatType = &tmp

	}
	return offset, nil
}

func (p *TFileScanRangeParams) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := TFileCompressType(v)
		p.CompressType = &tmp

	}
	return offset, nil
}

func (p *TFileScanRangeParams) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.SrcTupleId = &v

	}
	return offset, nil
}

func (p *TFileScanRangeParams) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.DestTupleId = &v

	}
	return offset, nil
}

func (p *TFileScanRangeParams) FastReadField6(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.NumOfColumnsFromFile = &v

	}
	return offset, nil
}

func (p *TFileScanRangeParams) FastReadField7(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.RequiredSlots = make([]*TFileScanSlotInfo, 0, size)
	for i := 0; i < size; i++ {
		_elem := NewTFileScanSlotInfo()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.RequiredSlots = append(p.RequiredSlots, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TFileScanRangeParams) FastReadField8(buf []byte) (int, error) {
	offset := 0

	tmp := NewTHdfsParams()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.HdfsParams = tmp
	return offset, nil
}

func (p *TFileScanRangeParams) FastReadField9(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := bthrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Properties = make(map[string]string, size)
	for i := 0; i < size; i++ {
		var _key string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_key = v

		}

		var _val string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_val = v

		}

		p.Properties[_key] = _val
	}
	if l, err := bthrift.Binary.ReadMapEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TFileScanRangeParams) FastReadField10(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := bthrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.ExprOfDestSlot = make(map[types.TSlotId]*exprs.TExpr, size)
	for i := 0; i < size; i++ {
		var _key types.TSlotId
		if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_key = v

		}
		_val := exprs.NewTExpr()
		if l, err := _val.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.ExprOfDestSlot[_key] = _val
	}
	if l, err := bthrift.Binary.ReadMapEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TFileScanRangeParams) FastReadField11(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := bthrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.DefaultValueOfSrcSlot = make(map[types.TSlotId]*exprs.TExpr, size)
	for i := 0; i < size; i++ {
		var _key types.TSlotId
		if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_key = v

		}
		_val := exprs.NewTExpr()
		if l, err := _val.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.DefaultValueOfSrcSlot[_key] = _val
	}
	if l, err := bthrift.Binary.ReadMapEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TFileScanRangeParams) FastReadField12(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := bthrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.DestSidToSrcSidWithoutTrans = make(map[types.TSlotId]types.TSlotId, size)
	for i := 0; i < size; i++ {
		var _key types.TSlotId
		if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_key = v

		}

		var _val types.TSlotId
		if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_val = v

		}

		p.DestSidToSrcSidWithoutTrans[_key] = _val
	}
	if l, err := bthrift.Binary.ReadMapEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TFileScanRangeParams) FastReadField13(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.StrictMode = &v

	}
	return offset, nil
}

func (p *TFileScanRangeParams) FastReadField14(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.BrokerAddresses = make([]*types.TNetworkAddress, 0, size)
	for i := 0; i < size; i++ {
		_elem := types.NewTNetworkAddress()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.BrokerAddresses = append(p.BrokerAddresses, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TFileScanRangeParams) FastReadField15(buf []byte) (int, error) {
	offset := 0

	tmp := NewTFileAttributes()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.FileAttributes = tmp
	return offset, nil
}

func (p *TFileScanRangeParams) FastReadField16(buf []byte) (int, error) {
	offset := 0

	tmp := exprs.NewTExpr()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.PreFilterExprs = tmp
	return offset, nil
}

func (p *TFileScanRangeParams) FastReadField17(buf []byte) (int, error) {
	offset := 0

	tmp := NewTTableFormatFileDesc()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.TableFormatParams = tmp
	return offset, nil
}

func (p *TFileScanRangeParams) FastReadField18(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.ColumnIdxs = make([]int32, 0, size)
	for i := 0; i < size; i++ {
		var _elem int32
		if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.ColumnIdxs = append(p.ColumnIdxs, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TFileScanRangeParams) FastReadField19(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := bthrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.SlotNameToSchemaPos = make(map[string]int32, size)
	for i := 0; i < size; i++ {
		var _key string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_key = v

		}

		var _val int32
		if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_val = v

		}

		p.SlotNameToSchemaPos[_key] = _val
	}
	if l, err := bthrift.Binary.ReadMapEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TFileScanRangeParams) FastReadField20(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.PreFilterExprsList = make([]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_elem := exprs.NewTExpr()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.PreFilterExprsList = append(p.PreFilterExprsList, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TFileScanRangeParams) FastReadField21(buf []byte) (int, error) {
	offset := 0

	tmp := types.NewTUniqueId()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.LoadId = tmp
	return offset, nil
}

func (p *TFileScanRangeParams) FastReadField22(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := TTextSerdeType(v)
		p.TextSerdeType = &tmp

	}
	return offset, nil
}

// for compatibility
func (p *TFileScanRangeParams) FastWrite(buf []byte) int {
	return 0
}

func (p *TFileScanRangeParams) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TFileScanRangeParams")
	if p != nil {
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField13(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
		offset += p.fastWriteField9(buf[offset:], binaryWriter)
		offset += p.fastWriteField10(buf[offset:], binaryWriter)
		offset += p.fastWriteField11(buf[offset:], binaryWriter)
		offset += p.fastWriteField12(buf[offset:], binaryWriter)
		offset += p.fastWriteField14(buf[offset:], binaryWriter)
		offset += p.fastWriteField15(buf[offset:], binaryWriter)
		offset += p.fastWriteField16(buf[offset:], binaryWriter)
		offset += p.fastWriteField17(buf[offset:], binaryWriter)
		offset += p.fastWriteField18(buf[offset:], binaryWriter)
		offset += p.fastWriteField19(buf[offset:], binaryWriter)
		offset += p.fastWriteField20(buf[offset:], binaryWriter)
		offset += p.fastWriteField21(buf[offset:], binaryWriter)
		offset += p.fastWriteField22(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TFileScanRangeParams) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TFileScanRangeParams")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field9Length()
		l += p.field10Length()
		l += p.field11Length()
		l += p.field12Length()
		l += p.field13Length()
		l += p.field14Length()
		l += p.field15Length()
		l += p.field16Length()
		l += p.field17Length()
		l += p.field18Length()
		l += p.field19Length()
		l += p.field20Length()
		l += p.field21Length()
		l += p.field22Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TFileScanRangeParams) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFileType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "file_type", thrift.I32, 1)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.FileType))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileScanRangeParams) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFormatType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "format_type", thrift.I32, 2)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.FormatType))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileScanRangeParams) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetCompressType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "compress_type", thrift.I32, 3)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.CompressType))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileScanRangeParams) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSrcTupleId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "src_tuple_id", thrift.I32, 4)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.SrcTupleId)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileScanRangeParams) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDestTupleId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "dest_tuple_id", thrift.I32, 5)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.DestTupleId)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileScanRangeParams) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetNumOfColumnsFromFile() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "num_of_columns_from_file", thrift.I32, 6)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.NumOfColumnsFromFile)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileScanRangeParams) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetRequiredSlots() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "required_slots", thrift.LIST, 7)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.RequiredSlots {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileScanRangeParams) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetHdfsParams() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "hdfs_params", thrift.STRUCT, 8)
		offset += p.HdfsParams.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileScanRangeParams) fastWriteField9(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetProperties() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "properties", thrift.MAP, 9)
		mapBeginOffset := offset
		offset += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRING, 0)
		var length int
		for k, v := range p.Properties {
			length++

			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, k)

			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.STRING, thrift.STRING, length)
		offset += bthrift.Binary.WriteMapEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileScanRangeParams) fastWriteField10(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetExprOfDestSlot() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "expr_of_dest_slot", thrift.MAP, 10)
		mapBeginOffset := offset
		offset += bthrift.Binary.MapBeginLength(thrift.I32, thrift.STRUCT, 0)
		var length int
		for k, v := range p.ExprOfDestSlot {
			length++

			offset += bthrift.Binary.WriteI32(buf[offset:], k)

			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.I32, thrift.STRUCT, length)
		offset += bthrift.Binary.WriteMapEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileScanRangeParams) fastWriteField11(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDefaultValueOfSrcSlot() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "default_value_of_src_slot", thrift.MAP, 11)
		mapBeginOffset := offset
		offset += bthrift.Binary.MapBeginLength(thrift.I32, thrift.STRUCT, 0)
		var length int
		for k, v := range p.DefaultValueOfSrcSlot {
			length++

			offset += bthrift.Binary.WriteI32(buf[offset:], k)

			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.I32, thrift.STRUCT, length)
		offset += bthrift.Binary.WriteMapEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileScanRangeParams) fastWriteField12(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDestSidToSrcSidWithoutTrans() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "dest_sid_to_src_sid_without_trans", thrift.MAP, 12)
		mapBeginOffset := offset
		offset += bthrift.Binary.MapBeginLength(thrift.I32, thrift.I32, 0)
		var length int
		for k, v := range p.DestSidToSrcSidWithoutTrans {
			length++

			offset += bthrift.Binary.WriteI32(buf[offset:], k)

			offset += bthrift.Binary.WriteI32(buf[offset:], v)

		}
		bthrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.I32, thrift.I32, length)
		offset += bthrift.Binary.WriteMapEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileScanRangeParams) fastWriteField13(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetStrictMode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "strict_mode", thrift.BOOL, 13)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.StrictMode)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileScanRangeParams) fastWriteField14(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetBrokerAddresses() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "broker_addresses", thrift.LIST, 14)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.BrokerAddresses {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileScanRangeParams) fastWriteField15(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFileAttributes() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "file_attributes", thrift.STRUCT, 15)
		offset += p.FileAttributes.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileScanRangeParams) fastWriteField16(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPreFilterExprs() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "pre_filter_exprs", thrift.STRUCT, 16)
		offset += p.PreFilterExprs.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileScanRangeParams) fastWriteField17(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTableFormatParams() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "table_format_params", thrift.STRUCT, 17)
		offset += p.TableFormatParams.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileScanRangeParams) fastWriteField18(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetColumnIdxs() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "column_idxs", thrift.LIST, 18)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.I32, 0)
		var length int
		for _, v := range p.ColumnIdxs {
			length++
			offset += bthrift.Binary.WriteI32(buf[offset:], v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.I32, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileScanRangeParams) fastWriteField19(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSlotNameToSchemaPos() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "slot_name_to_schema_pos", thrift.MAP, 19)
		mapBeginOffset := offset
		offset += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.I32, 0)
		var length int
		for k, v := range p.SlotNameToSchemaPos {
			length++

			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, k)

			offset += bthrift.Binary.WriteI32(buf[offset:], v)

		}
		bthrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.STRING, thrift.I32, length)
		offset += bthrift.Binary.WriteMapEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileScanRangeParams) fastWriteField20(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPreFilterExprsList() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "pre_filter_exprs_list", thrift.LIST, 20)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.PreFilterExprsList {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileScanRangeParams) fastWriteField21(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetLoadId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "load_id", thrift.STRUCT, 21)
		offset += p.LoadId.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileScanRangeParams) fastWriteField22(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTextSerdeType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "text_serde_type", thrift.I32, 22)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.TextSerdeType))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileScanRangeParams) field1Length() int {
	l := 0
	if p.IsSetFileType() {
		l += bthrift.Binary.FieldBeginLength("file_type", thrift.I32, 1)
		l += bthrift.Binary.I32Length(int32(*p.FileType))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileScanRangeParams) field2Length() int {
	l := 0
	if p.IsSetFormatType() {
		l += bthrift.Binary.FieldBeginLength("format_type", thrift.I32, 2)
		l += bthrift.Binary.I32Length(int32(*p.FormatType))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileScanRangeParams) field3Length() int {
	l := 0
	if p.IsSetCompressType() {
		l += bthrift.Binary.FieldBeginLength("compress_type", thrift.I32, 3)
		l += bthrift.Binary.I32Length(int32(*p.CompressType))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileScanRangeParams) field4Length() int {
	l := 0
	if p.IsSetSrcTupleId() {
		l += bthrift.Binary.FieldBeginLength("src_tuple_id", thrift.I32, 4)
		l += bthrift.Binary.I32Length(*p.SrcTupleId)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileScanRangeParams) field5Length() int {
	l := 0
	if p.IsSetDestTupleId() {
		l += bthrift.Binary.FieldBeginLength("dest_tuple_id", thrift.I32, 5)
		l += bthrift.Binary.I32Length(*p.DestTupleId)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileScanRangeParams) field6Length() int {
	l := 0
	if p.IsSetNumOfColumnsFromFile() {
		l += bthrift.Binary.FieldBeginLength("num_of_columns_from_file", thrift.I32, 6)
		l += bthrift.Binary.I32Length(*p.NumOfColumnsFromFile)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileScanRangeParams) field7Length() int {
	l := 0
	if p.IsSetRequiredSlots() {
		l += bthrift.Binary.FieldBeginLength("required_slots", thrift.LIST, 7)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.RequiredSlots))
		for _, v := range p.RequiredSlots {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileScanRangeParams) field8Length() int {
	l := 0
	if p.IsSetHdfsParams() {
		l += bthrift.Binary.FieldBeginLength("hdfs_params", thrift.STRUCT, 8)
		l += p.HdfsParams.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileScanRangeParams) field9Length() int {
	l := 0
	if p.IsSetProperties() {
		l += bthrift.Binary.FieldBeginLength("properties", thrift.MAP, 9)
		l += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRING, len(p.Properties))
		for k, v := range p.Properties {

			l += bthrift.Binary.StringLengthNocopy(k)

			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.MapEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileScanRangeParams) field10Length() int {
	l := 0
	if p.IsSetExprOfDestSlot() {
		l += bthrift.Binary.FieldBeginLength("expr_of_dest_slot", thrift.MAP, 10)
		l += bthrift.Binary.MapBeginLength(thrift.I32, thrift.STRUCT, len(p.ExprOfDestSlot))
		for k, v := range p.ExprOfDestSlot {

			l += bthrift.Binary.I32Length(k)

			l += v.BLength()
		}
		l += bthrift.Binary.MapEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileScanRangeParams) field11Length() int {
	l := 0
	if p.IsSetDefaultValueOfSrcSlot() {
		l += bthrift.Binary.FieldBeginLength("default_value_of_src_slot", thrift.MAP, 11)
		l += bthrift.Binary.MapBeginLength(thrift.I32, thrift.STRUCT, len(p.DefaultValueOfSrcSlot))
		for k, v := range p.DefaultValueOfSrcSlot {

			l += bthrift.Binary.I32Length(k)

			l += v.BLength()
		}
		l += bthrift.Binary.MapEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileScanRangeParams) field12Length() int {
	l := 0
	if p.IsSetDestSidToSrcSidWithoutTrans() {
		l += bthrift.Binary.FieldBeginLength("dest_sid_to_src_sid_without_trans", thrift.MAP, 12)
		l += bthrift.Binary.MapBeginLength(thrift.I32, thrift.I32, len(p.DestSidToSrcSidWithoutTrans))
		var tmpK types.TSlotId
		var tmpV types.TSlotId
		l += (bthrift.Binary.I32Length(int32(tmpK)) + bthrift.Binary.I32Length(int32(tmpV))) * len(p.DestSidToSrcSidWithoutTrans)
		l += bthrift.Binary.MapEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileScanRangeParams) field13Length() int {
	l := 0
	if p.IsSetStrictMode() {
		l += bthrift.Binary.FieldBeginLength("strict_mode", thrift.BOOL, 13)
		l += bthrift.Binary.BoolLength(*p.StrictMode)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileScanRangeParams) field14Length() int {
	l := 0
	if p.IsSetBrokerAddresses() {
		l += bthrift.Binary.FieldBeginLength("broker_addresses", thrift.LIST, 14)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.BrokerAddresses))
		for _, v := range p.BrokerAddresses {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileScanRangeParams) field15Length() int {
	l := 0
	if p.IsSetFileAttributes() {
		l += bthrift.Binary.FieldBeginLength("file_attributes", thrift.STRUCT, 15)
		l += p.FileAttributes.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileScanRangeParams) field16Length() int {
	l := 0
	if p.IsSetPreFilterExprs() {
		l += bthrift.Binary.FieldBeginLength("pre_filter_exprs", thrift.STRUCT, 16)
		l += p.PreFilterExprs.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileScanRangeParams) field17Length() int {
	l := 0
	if p.IsSetTableFormatParams() {
		l += bthrift.Binary.FieldBeginLength("table_format_params", thrift.STRUCT, 17)
		l += p.TableFormatParams.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileScanRangeParams) field18Length() int {
	l := 0
	if p.IsSetColumnIdxs() {
		l += bthrift.Binary.FieldBeginLength("column_idxs", thrift.LIST, 18)
		l += bthrift.Binary.ListBeginLength(thrift.I32, len(p.ColumnIdxs))
		var tmpV int32
		l += bthrift.Binary.I32Length(int32(tmpV)) * len(p.ColumnIdxs)
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileScanRangeParams) field19Length() int {
	l := 0
	if p.IsSetSlotNameToSchemaPos() {
		l += bthrift.Binary.FieldBeginLength("slot_name_to_schema_pos", thrift.MAP, 19)
		l += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.I32, len(p.SlotNameToSchemaPos))
		for k, v := range p.SlotNameToSchemaPos {

			l += bthrift.Binary.StringLengthNocopy(k)

			l += bthrift.Binary.I32Length(v)

		}
		l += bthrift.Binary.MapEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileScanRangeParams) field20Length() int {
	l := 0
	if p.IsSetPreFilterExprsList() {
		l += bthrift.Binary.FieldBeginLength("pre_filter_exprs_list", thrift.LIST, 20)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.PreFilterExprsList))
		for _, v := range p.PreFilterExprsList {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileScanRangeParams) field21Length() int {
	l := 0
	if p.IsSetLoadId() {
		l += bthrift.Binary.FieldBeginLength("load_id", thrift.STRUCT, 21)
		l += p.LoadId.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileScanRangeParams) field22Length() int {
	l := 0
	if p.IsSetTextSerdeType() {
		l += bthrift.Binary.FieldBeginLength("text_serde_type", thrift.I32, 22)
		l += bthrift.Binary.I32Length(int32(*p.TextSerdeType))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileRangeDesc) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField9(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 11:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField11(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 12:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField12(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TFileRangeDesc[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TFileRangeDesc) FastReadField1(buf []byte) (int, error) {
	offset := 0

	tmp := types.NewTUniqueId()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.LoadId = tmp
	return offset, nil
}

func (p *TFileRangeDesc) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Path = &v

	}
	return offset, nil
}

func (p *TFileRangeDesc) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.StartOffset = &v

	}
	return offset, nil
}

func (p *TFileRangeDesc) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Size = &v

	}
	return offset, nil
}

func (p *TFileRangeDesc) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.FileSize = v

	}
	return offset, nil
}

func (p *TFileRangeDesc) FastReadField6(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.ColumnsFromPath = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.ColumnsFromPath = append(p.ColumnsFromPath, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TFileRangeDesc) FastReadField7(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.ColumnsFromPathKeys = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.ColumnsFromPathKeys = append(p.ColumnsFromPathKeys, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TFileRangeDesc) FastReadField8(buf []byte) (int, error) {
	offset := 0

	tmp := NewTTableFormatFileDesc()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.TableFormatParams = tmp
	return offset, nil
}

func (p *TFileRangeDesc) FastReadField9(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.ModificationTime = &v

	}
	return offset, nil
}

func (p *TFileRangeDesc) FastReadField10(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := types.TFileType(v)
		p.FileType = &tmp

	}
	return offset, nil
}

func (p *TFileRangeDesc) FastReadField11(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := TFileCompressType(v)
		p.CompressType = &tmp

	}
	return offset, nil
}

func (p *TFileRangeDesc) FastReadField12(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.FsName = &v

	}
	return offset, nil
}

// for compatibility
func (p *TFileRangeDesc) FastWrite(buf []byte) int {
	return 0
}

func (p *TFileRangeDesc) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TFileRangeDesc")
	if p != nil {
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField9(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
		offset += p.fastWriteField10(buf[offset:], binaryWriter)
		offset += p.fastWriteField11(buf[offset:], binaryWriter)
		offset += p.fastWriteField12(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TFileRangeDesc) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TFileRangeDesc")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field9Length()
		l += p.field10Length()
		l += p.field11Length()
		l += p.field12Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TFileRangeDesc) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetLoadId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "load_id", thrift.STRUCT, 1)
		offset += p.LoadId.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileRangeDesc) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPath() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "path", thrift.STRING, 2)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Path)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileRangeDesc) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetStartOffset() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "start_offset", thrift.I64, 3)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.StartOffset)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileRangeDesc) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSize() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "size", thrift.I64, 4)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.Size)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileRangeDesc) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFileSize() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "file_size", thrift.I64, 5)
		offset += bthrift.Binary.WriteI64(buf[offset:], p.FileSize)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileRangeDesc) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetColumnsFromPath() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "columns_from_path", thrift.LIST, 6)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRING, 0)
		var length int
		for _, v := range p.ColumnsFromPath {
			length++
			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRING, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileRangeDesc) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetColumnsFromPathKeys() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "columns_from_path_keys", thrift.LIST, 7)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRING, 0)
		var length int
		for _, v := range p.ColumnsFromPathKeys {
			length++
			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRING, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileRangeDesc) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTableFormatParams() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "table_format_params", thrift.STRUCT, 8)
		offset += p.TableFormatParams.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileRangeDesc) fastWriteField9(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetModificationTime() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "modification_time", thrift.I64, 9)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.ModificationTime)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileRangeDesc) fastWriteField10(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFileType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "file_type", thrift.I32, 10)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.FileType))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileRangeDesc) fastWriteField11(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetCompressType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "compress_type", thrift.I32, 11)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.CompressType))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileRangeDesc) fastWriteField12(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFsName() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "fs_name", thrift.STRING, 12)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.FsName)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileRangeDesc) field1Length() int {
	l := 0
	if p.IsSetLoadId() {
		l += bthrift.Binary.FieldBeginLength("load_id", thrift.STRUCT, 1)
		l += p.LoadId.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileRangeDesc) field2Length() int {
	l := 0
	if p.IsSetPath() {
		l += bthrift.Binary.FieldBeginLength("path", thrift.STRING, 2)
		l += bthrift.Binary.StringLengthNocopy(*p.Path)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileRangeDesc) field3Length() int {
	l := 0
	if p.IsSetStartOffset() {
		l += bthrift.Binary.FieldBeginLength("start_offset", thrift.I64, 3)
		l += bthrift.Binary.I64Length(*p.StartOffset)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileRangeDesc) field4Length() int {
	l := 0
	if p.IsSetSize() {
		l += bthrift.Binary.FieldBeginLength("size", thrift.I64, 4)
		l += bthrift.Binary.I64Length(*p.Size)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileRangeDesc) field5Length() int {
	l := 0
	if p.IsSetFileSize() {
		l += bthrift.Binary.FieldBeginLength("file_size", thrift.I64, 5)
		l += bthrift.Binary.I64Length(p.FileSize)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileRangeDesc) field6Length() int {
	l := 0
	if p.IsSetColumnsFromPath() {
		l += bthrift.Binary.FieldBeginLength("columns_from_path", thrift.LIST, 6)
		l += bthrift.Binary.ListBeginLength(thrift.STRING, len(p.ColumnsFromPath))
		for _, v := range p.ColumnsFromPath {
			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileRangeDesc) field7Length() int {
	l := 0
	if p.IsSetColumnsFromPathKeys() {
		l += bthrift.Binary.FieldBeginLength("columns_from_path_keys", thrift.LIST, 7)
		l += bthrift.Binary.ListBeginLength(thrift.STRING, len(p.ColumnsFromPathKeys))
		for _, v := range p.ColumnsFromPathKeys {
			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileRangeDesc) field8Length() int {
	l := 0
	if p.IsSetTableFormatParams() {
		l += bthrift.Binary.FieldBeginLength("table_format_params", thrift.STRUCT, 8)
		l += p.TableFormatParams.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileRangeDesc) field9Length() int {
	l := 0
	if p.IsSetModificationTime() {
		l += bthrift.Binary.FieldBeginLength("modification_time", thrift.I64, 9)
		l += bthrift.Binary.I64Length(*p.ModificationTime)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileRangeDesc) field10Length() int {
	l := 0
	if p.IsSetFileType() {
		l += bthrift.Binary.FieldBeginLength("file_type", thrift.I32, 10)
		l += bthrift.Binary.I32Length(int32(*p.FileType))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileRangeDesc) field11Length() int {
	l := 0
	if p.IsSetCompressType() {
		l += bthrift.Binary.FieldBeginLength("compress_type", thrift.I32, 11)
		l += bthrift.Binary.I32Length(int32(*p.CompressType))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileRangeDesc) field12Length() int {
	l := 0
	if p.IsSetFsName() {
		l += bthrift.Binary.FieldBeginLength("fs_name", thrift.STRING, 12)
		l += bthrift.Binary.StringLengthNocopy(*p.FsName)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TSplitSource) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TSplitSource[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TSplitSource) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.SplitSourceId = &v

	}
	return offset, nil
}

func (p *TSplitSource) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.NumSplits = &v

	}
	return offset, nil
}

// for compatibility
func (p *TSplitSource) FastWrite(buf []byte) int {
	return 0
}

func (p *TSplitSource) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TSplitSource")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TSplitSource) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TSplitSource")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TSplitSource) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSplitSourceId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "split_source_id", thrift.I64, 1)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.SplitSourceId)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TSplitSource) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetNumSplits() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "num_splits", thrift.I32, 2)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.NumSplits)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TSplitSource) field1Length() int {
	l := 0
	if p.IsSetSplitSourceId() {
		l += bthrift.Binary.FieldBeginLength("split_source_id", thrift.I64, 1)
		l += bthrift.Binary.I64Length(*p.SplitSourceId)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TSplitSource) field2Length() int {
	l := 0
	if p.IsSetNumSplits() {
		l += bthrift.Binary.FieldBeginLength("num_splits", thrift.I32, 2)
		l += bthrift.Binary.I32Length(*p.NumSplits)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileScanRange) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TFileScanRange[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TFileScanRange) FastReadField1(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Ranges = make([]*TFileRangeDesc, 0, size)
	for i := 0; i < size; i++ {
		_elem := NewTFileRangeDesc()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.Ranges = append(p.Ranges, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TFileScanRange) FastReadField2(buf []byte) (int, error) {
	offset := 0

	tmp := NewTFileScanRangeParams()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.Params = tmp
	return offset, nil
}

func (p *TFileScanRange) FastReadField3(buf []byte) (int, error) {
	offset := 0

	tmp := NewTSplitSource()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.SplitSource = tmp
	return offset, nil
}

// for compatibility
func (p *TFileScanRange) FastWrite(buf []byte) int {
	return 0
}

func (p *TFileScanRange) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TFileScanRange")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TFileScanRange) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TFileScanRange")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TFileScanRange) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetRanges() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "ranges", thrift.LIST, 1)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.Ranges {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileScanRange) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetParams() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "params", thrift.STRUCT, 2)
		offset += p.Params.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileScanRange) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSplitSource() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "split_source", thrift.STRUCT, 3)
		offset += p.SplitSource.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileScanRange) field1Length() int {
	l := 0
	if p.IsSetRanges() {
		l += bthrift.Binary.FieldBeginLength("ranges", thrift.LIST, 1)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.Ranges))
		for _, v := range p.Ranges {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileScanRange) field2Length() int {
	l := 0
	if p.IsSetParams() {
		l += bthrift.Binary.FieldBeginLength("params", thrift.STRUCT, 2)
		l += p.Params.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileScanRange) field3Length() int {
	l := 0
	if p.IsSetSplitSource() {
		l += bthrift.Binary.FieldBeginLength("split_source", thrift.STRUCT, 3)
		l += p.SplitSource.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TExternalScanRange) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TExternalScanRange[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TExternalScanRange) FastReadField1(buf []byte) (int, error) {
	offset := 0

	tmp := NewTFileScanRange()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.FileScanRange = tmp
	return offset, nil
}

// for compatibility
func (p *TExternalScanRange) FastWrite(buf []byte) int {
	return 0
}

func (p *TExternalScanRange) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TExternalScanRange")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TExternalScanRange) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TExternalScanRange")
	if p != nil {
		l += p.field1Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TExternalScanRange) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFileScanRange() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "file_scan_range", thrift.STRUCT, 1)
		offset += p.FileScanRange.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TExternalScanRange) field1Length() int {
	l := 0
	if p.IsSetFileScanRange() {
		l += bthrift.Binary.FieldBeginLength("file_scan_range", thrift.STRUCT, 1)
		l += p.FileScanRange.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTVFNumbersScanRange) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TTVFNumbersScanRange[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TTVFNumbersScanRange) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.TotalNumbers = &v

	}
	return offset, nil
}

func (p *TTVFNumbersScanRange) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.UseConst = &v

	}
	return offset, nil
}

func (p *TTVFNumbersScanRange) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.ConstValue = &v

	}
	return offset, nil
}

// for compatibility
func (p *TTVFNumbersScanRange) FastWrite(buf []byte) int {
	return 0
}

func (p *TTVFNumbersScanRange) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TTVFNumbersScanRange")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TTVFNumbersScanRange) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TTVFNumbersScanRange")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TTVFNumbersScanRange) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTotalNumbers() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "totalNumbers", thrift.I64, 1)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.TotalNumbers)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTVFNumbersScanRange) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetUseConst() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "useConst", thrift.BOOL, 2)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.UseConst)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTVFNumbersScanRange) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetConstValue() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "constValue", thrift.I64, 3)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.ConstValue)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTVFNumbersScanRange) field1Length() int {
	l := 0
	if p.IsSetTotalNumbers() {
		l += bthrift.Binary.FieldBeginLength("totalNumbers", thrift.I64, 1)
		l += bthrift.Binary.I64Length(*p.TotalNumbers)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTVFNumbersScanRange) field2Length() int {
	l := 0
	if p.IsSetUseConst() {
		l += bthrift.Binary.FieldBeginLength("useConst", thrift.BOOL, 2)
		l += bthrift.Binary.BoolLength(*p.UseConst)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTVFNumbersScanRange) field3Length() int {
	l := 0
	if p.IsSetConstValue() {
		l += bthrift.Binary.FieldBeginLength("constValue", thrift.I64, 3)
		l += bthrift.Binary.I64Length(*p.ConstValue)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TDataGenScanRange) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TDataGenScanRange[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TDataGenScanRange) FastReadField1(buf []byte) (int, error) {
	offset := 0

	tmp := NewTTVFNumbersScanRange()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.NumbersParams = tmp
	return offset, nil
}

// for compatibility
func (p *TDataGenScanRange) FastWrite(buf []byte) int {
	return 0
}

func (p *TDataGenScanRange) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TDataGenScanRange")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TDataGenScanRange) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TDataGenScanRange")
	if p != nil {
		l += p.field1Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TDataGenScanRange) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetNumbersParams() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "numbers_params", thrift.STRUCT, 1)
		offset += p.NumbersParams.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TDataGenScanRange) field1Length() int {
	l := 0
	if p.IsSetNumbersParams() {
		l += bthrift.Binary.FieldBeginLength("numbers_params", thrift.STRUCT, 1)
		l += p.NumbersParams.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TIcebergMetadataParams) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TIcebergMetadataParams[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TIcebergMetadataParams) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := types.TIcebergQueryType(v)
		p.IcebergQueryType = &tmp

	}
	return offset, nil
}

func (p *TIcebergMetadataParams) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Catalog = &v

	}
	return offset, nil
}

func (p *TIcebergMetadataParams) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Database = &v

	}
	return offset, nil
}

func (p *TIcebergMetadataParams) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Table = &v

	}
	return offset, nil
}

// for compatibility
func (p *TIcebergMetadataParams) FastWrite(buf []byte) int {
	return 0
}

func (p *TIcebergMetadataParams) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TIcebergMetadataParams")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TIcebergMetadataParams) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TIcebergMetadataParams")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TIcebergMetadataParams) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIcebergQueryType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "iceberg_query_type", thrift.I32, 1)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.IcebergQueryType))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TIcebergMetadataParams) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetCatalog() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "catalog", thrift.STRING, 2)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Catalog)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TIcebergMetadataParams) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDatabase() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "database", thrift.STRING, 3)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Database)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TIcebergMetadataParams) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTable() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "table", thrift.STRING, 4)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Table)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TIcebergMetadataParams) field1Length() int {
	l := 0
	if p.IsSetIcebergQueryType() {
		l += bthrift.Binary.FieldBeginLength("iceberg_query_type", thrift.I32, 1)
		l += bthrift.Binary.I32Length(int32(*p.IcebergQueryType))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TIcebergMetadataParams) field2Length() int {
	l := 0
	if p.IsSetCatalog() {
		l += bthrift.Binary.FieldBeginLength("catalog", thrift.STRING, 2)
		l += bthrift.Binary.StringLengthNocopy(*p.Catalog)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TIcebergMetadataParams) field3Length() int {
	l := 0
	if p.IsSetDatabase() {
		l += bthrift.Binary.FieldBeginLength("database", thrift.STRING, 3)
		l += bthrift.Binary.StringLengthNocopy(*p.Database)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TIcebergMetadataParams) field4Length() int {
	l := 0
	if p.IsSetTable() {
		l += bthrift.Binary.FieldBeginLength("table", thrift.STRING, 4)
		l += bthrift.Binary.StringLengthNocopy(*p.Table)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TBackendsMetadataParams) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TBackendsMetadataParams[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TBackendsMetadataParams) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.ClusterName = &v

	}
	return offset, nil
}

// for compatibility
func (p *TBackendsMetadataParams) FastWrite(buf []byte) int {
	return 0
}

func (p *TBackendsMetadataParams) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TBackendsMetadataParams")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TBackendsMetadataParams) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TBackendsMetadataParams")
	if p != nil {
		l += p.field1Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TBackendsMetadataParams) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetClusterName() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "cluster_name", thrift.STRING, 1)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.ClusterName)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TBackendsMetadataParams) field1Length() int {
	l := 0
	if p.IsSetClusterName() {
		l += bthrift.Binary.FieldBeginLength("cluster_name", thrift.STRING, 1)
		l += bthrift.Binary.StringLengthNocopy(*p.ClusterName)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFrontendsMetadataParams) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TFrontendsMetadataParams[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TFrontendsMetadataParams) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.ClusterName = &v

	}
	return offset, nil
}

// for compatibility
func (p *TFrontendsMetadataParams) FastWrite(buf []byte) int {
	return 0
}

func (p *TFrontendsMetadataParams) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TFrontendsMetadataParams")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TFrontendsMetadataParams) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TFrontendsMetadataParams")
	if p != nil {
		l += p.field1Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TFrontendsMetadataParams) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetClusterName() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "cluster_name", thrift.STRING, 1)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.ClusterName)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFrontendsMetadataParams) field1Length() int {
	l := 0
	if p.IsSetClusterName() {
		l += bthrift.Binary.FieldBeginLength("cluster_name", thrift.STRING, 1)
		l += bthrift.Binary.StringLengthNocopy(*p.ClusterName)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TMaterializedViewsMetadataParams) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TMaterializedViewsMetadataParams[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TMaterializedViewsMetadataParams) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Database = &v

	}
	return offset, nil
}

func (p *TMaterializedViewsMetadataParams) FastReadField2(buf []byte) (int, error) {
	offset := 0

	tmp := types.NewTUserIdentity()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.CurrentUserIdent = tmp
	return offset, nil
}

// for compatibility
func (p *TMaterializedViewsMetadataParams) FastWrite(buf []byte) int {
	return 0
}

func (p *TMaterializedViewsMetadataParams) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TMaterializedViewsMetadataParams")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TMaterializedViewsMetadataParams) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TMaterializedViewsMetadataParams")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TMaterializedViewsMetadataParams) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDatabase() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "database", thrift.STRING, 1)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Database)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TMaterializedViewsMetadataParams) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetCurrentUserIdent() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "current_user_ident", thrift.STRUCT, 2)
		offset += p.CurrentUserIdent.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TMaterializedViewsMetadataParams) field1Length() int {
	l := 0
	if p.IsSetDatabase() {
		l += bthrift.Binary.FieldBeginLength("database", thrift.STRING, 1)
		l += bthrift.Binary.StringLengthNocopy(*p.Database)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TMaterializedViewsMetadataParams) field2Length() int {
	l := 0
	if p.IsSetCurrentUserIdent() {
		l += bthrift.Binary.FieldBeginLength("current_user_ident", thrift.STRUCT, 2)
		l += p.CurrentUserIdent.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPartitionsMetadataParams) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TPartitionsMetadataParams[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TPartitionsMetadataParams) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Catalog = &v

	}
	return offset, nil
}

func (p *TPartitionsMetadataParams) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Database = &v

	}
	return offset, nil
}

func (p *TPartitionsMetadataParams) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Table = &v

	}
	return offset, nil
}

// for compatibility
func (p *TPartitionsMetadataParams) FastWrite(buf []byte) int {
	return 0
}

func (p *TPartitionsMetadataParams) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TPartitionsMetadataParams")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TPartitionsMetadataParams) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TPartitionsMetadataParams")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TPartitionsMetadataParams) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetCatalog() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "catalog", thrift.STRING, 1)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Catalog)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPartitionsMetadataParams) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDatabase() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "database", thrift.STRING, 2)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Database)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPartitionsMetadataParams) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTable() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "table", thrift.STRING, 3)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Table)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPartitionsMetadataParams) field1Length() int {
	l := 0
	if p.IsSetCatalog() {
		l += bthrift.Binary.FieldBeginLength("catalog", thrift.STRING, 1)
		l += bthrift.Binary.StringLengthNocopy(*p.Catalog)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPartitionsMetadataParams) field2Length() int {
	l := 0
	if p.IsSetDatabase() {
		l += bthrift.Binary.FieldBeginLength("database", thrift.STRING, 2)
		l += bthrift.Binary.StringLengthNocopy(*p.Database)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPartitionsMetadataParams) field3Length() int {
	l := 0
	if p.IsSetTable() {
		l += bthrift.Binary.FieldBeginLength("table", thrift.STRING, 3)
		l += bthrift.Binary.StringLengthNocopy(*p.Table)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TJobsMetadataParams) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TJobsMetadataParams[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TJobsMetadataParams) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Type = &v

	}
	return offset, nil
}

func (p *TJobsMetadataParams) FastReadField2(buf []byte) (int, error) {
	offset := 0

	tmp := types.NewTUserIdentity()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.CurrentUserIdent = tmp
	return offset, nil
}

// for compatibility
func (p *TJobsMetadataParams) FastWrite(buf []byte) int {
	return 0
}

func (p *TJobsMetadataParams) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TJobsMetadataParams")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TJobsMetadataParams) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TJobsMetadataParams")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TJobsMetadataParams) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "type", thrift.STRING, 1)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Type)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TJobsMetadataParams) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetCurrentUserIdent() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "current_user_ident", thrift.STRUCT, 2)
		offset += p.CurrentUserIdent.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TJobsMetadataParams) field1Length() int {
	l := 0
	if p.IsSetType() {
		l += bthrift.Binary.FieldBeginLength("type", thrift.STRING, 1)
		l += bthrift.Binary.StringLengthNocopy(*p.Type)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TJobsMetadataParams) field2Length() int {
	l := 0
	if p.IsSetCurrentUserIdent() {
		l += bthrift.Binary.FieldBeginLength("current_user_ident", thrift.STRUCT, 2)
		l += p.CurrentUserIdent.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTasksMetadataParams) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TTasksMetadataParams[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TTasksMetadataParams) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Type = &v

	}
	return offset, nil
}

func (p *TTasksMetadataParams) FastReadField2(buf []byte) (int, error) {
	offset := 0

	tmp := types.NewTUserIdentity()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.CurrentUserIdent = tmp
	return offset, nil
}

// for compatibility
func (p *TTasksMetadataParams) FastWrite(buf []byte) int {
	return 0
}

func (p *TTasksMetadataParams) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TTasksMetadataParams")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TTasksMetadataParams) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TTasksMetadataParams")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TTasksMetadataParams) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "type", thrift.STRING, 1)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Type)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTasksMetadataParams) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetCurrentUserIdent() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "current_user_ident", thrift.STRUCT, 2)
		offset += p.CurrentUserIdent.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTasksMetadataParams) field1Length() int {
	l := 0
	if p.IsSetType() {
		l += bthrift.Binary.FieldBeginLength("type", thrift.STRING, 1)
		l += bthrift.Binary.StringLengthNocopy(*p.Type)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTasksMetadataParams) field2Length() int {
	l := 0
	if p.IsSetCurrentUserIdent() {
		l += bthrift.Binary.FieldBeginLength("current_user_ident", thrift.STRUCT, 2)
		l += p.CurrentUserIdent.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TQueriesMetadataParams) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TQueriesMetadataParams[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TQueriesMetadataParams) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.ClusterName = &v

	}
	return offset, nil
}

func (p *TQueriesMetadataParams) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.RelayToOtherFe = &v

	}
	return offset, nil
}

func (p *TQueriesMetadataParams) FastReadField3(buf []byte) (int, error) {
	offset := 0

	tmp := NewTMaterializedViewsMetadataParams()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.MaterializedViewsParams = tmp
	return offset, nil
}

func (p *TQueriesMetadataParams) FastReadField4(buf []byte) (int, error) {
	offset := 0

	tmp := NewTJobsMetadataParams()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.JobsParams = tmp
	return offset, nil
}

func (p *TQueriesMetadataParams) FastReadField5(buf []byte) (int, error) {
	offset := 0

	tmp := NewTTasksMetadataParams()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.TasksParams = tmp
	return offset, nil
}

func (p *TQueriesMetadataParams) FastReadField6(buf []byte) (int, error) {
	offset := 0

	tmp := NewTPartitionsMetadataParams()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.PartitionsParams = tmp
	return offset, nil
}

// for compatibility
func (p *TQueriesMetadataParams) FastWrite(buf []byte) int {
	return 0
}

func (p *TQueriesMetadataParams) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TQueriesMetadataParams")
	if p != nil {
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TQueriesMetadataParams) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TQueriesMetadataParams")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TQueriesMetadataParams) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetClusterName() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "cluster_name", thrift.STRING, 1)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.ClusterName)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TQueriesMetadataParams) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetRelayToOtherFe() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "relay_to_other_fe", thrift.BOOL, 2)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.RelayToOtherFe)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TQueriesMetadataParams) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetMaterializedViewsParams() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "materialized_views_params", thrift.STRUCT, 3)
		offset += p.MaterializedViewsParams.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TQueriesMetadataParams) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetJobsParams() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "jobs_params", thrift.STRUCT, 4)
		offset += p.JobsParams.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TQueriesMetadataParams) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTasksParams() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tasks_params", thrift.STRUCT, 5)
		offset += p.TasksParams.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TQueriesMetadataParams) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPartitionsParams() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "partitions_params", thrift.STRUCT, 6)
		offset += p.PartitionsParams.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TQueriesMetadataParams) field1Length() int {
	l := 0
	if p.IsSetClusterName() {
		l += bthrift.Binary.FieldBeginLength("cluster_name", thrift.STRING, 1)
		l += bthrift.Binary.StringLengthNocopy(*p.ClusterName)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TQueriesMetadataParams) field2Length() int {
	l := 0
	if p.IsSetRelayToOtherFe() {
		l += bthrift.Binary.FieldBeginLength("relay_to_other_fe", thrift.BOOL, 2)
		l += bthrift.Binary.BoolLength(*p.RelayToOtherFe)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TQueriesMetadataParams) field3Length() int {
	l := 0
	if p.IsSetMaterializedViewsParams() {
		l += bthrift.Binary.FieldBeginLength("materialized_views_params", thrift.STRUCT, 3)
		l += p.MaterializedViewsParams.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TQueriesMetadataParams) field4Length() int {
	l := 0
	if p.IsSetJobsParams() {
		l += bthrift.Binary.FieldBeginLength("jobs_params", thrift.STRUCT, 4)
		l += p.JobsParams.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TQueriesMetadataParams) field5Length() int {
	l := 0
	if p.IsSetTasksParams() {
		l += bthrift.Binary.FieldBeginLength("tasks_params", thrift.STRUCT, 5)
		l += p.TasksParams.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TQueriesMetadataParams) field6Length() int {
	l := 0
	if p.IsSetPartitionsParams() {
		l += bthrift.Binary.FieldBeginLength("partitions_params", thrift.STRUCT, 6)
		l += p.PartitionsParams.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TMetaScanRange) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField9(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TMetaScanRange[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TMetaScanRange) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := types.TMetadataType(v)
		p.MetadataType = &tmp

	}
	return offset, nil
}

func (p *TMetaScanRange) FastReadField2(buf []byte) (int, error) {
	offset := 0

	tmp := NewTIcebergMetadataParams()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.IcebergParams = tmp
	return offset, nil
}

func (p *TMetaScanRange) FastReadField3(buf []byte) (int, error) {
	offset := 0

	tmp := NewTBackendsMetadataParams()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.BackendsParams = tmp
	return offset, nil
}

func (p *TMetaScanRange) FastReadField4(buf []byte) (int, error) {
	offset := 0

	tmp := NewTFrontendsMetadataParams()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.FrontendsParams = tmp
	return offset, nil
}

func (p *TMetaScanRange) FastReadField5(buf []byte) (int, error) {
	offset := 0

	tmp := NewTQueriesMetadataParams()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.QueriesParams = tmp
	return offset, nil
}

func (p *TMetaScanRange) FastReadField6(buf []byte) (int, error) {
	offset := 0

	tmp := NewTMaterializedViewsMetadataParams()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.MaterializedViewsParams = tmp
	return offset, nil
}

func (p *TMetaScanRange) FastReadField7(buf []byte) (int, error) {
	offset := 0

	tmp := NewTJobsMetadataParams()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.JobsParams = tmp
	return offset, nil
}

func (p *TMetaScanRange) FastReadField8(buf []byte) (int, error) {
	offset := 0

	tmp := NewTTasksMetadataParams()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.TasksParams = tmp
	return offset, nil
}

func (p *TMetaScanRange) FastReadField9(buf []byte) (int, error) {
	offset := 0

	tmp := NewTPartitionsMetadataParams()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.PartitionsParams = tmp
	return offset, nil
}

// for compatibility
func (p *TMetaScanRange) FastWrite(buf []byte) int {
	return 0
}

func (p *TMetaScanRange) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TMetaScanRange")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
		offset += p.fastWriteField9(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TMetaScanRange) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TMetaScanRange")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field9Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TMetaScanRange) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetMetadataType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "metadata_type", thrift.I32, 1)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.MetadataType))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TMetaScanRange) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIcebergParams() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "iceberg_params", thrift.STRUCT, 2)
		offset += p.IcebergParams.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TMetaScanRange) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetBackendsParams() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "backends_params", thrift.STRUCT, 3)
		offset += p.BackendsParams.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TMetaScanRange) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFrontendsParams() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "frontends_params", thrift.STRUCT, 4)
		offset += p.FrontendsParams.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TMetaScanRange) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetQueriesParams() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "queries_params", thrift.STRUCT, 5)
		offset += p.QueriesParams.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TMetaScanRange) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetMaterializedViewsParams() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "materialized_views_params", thrift.STRUCT, 6)
		offset += p.MaterializedViewsParams.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TMetaScanRange) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetJobsParams() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "jobs_params", thrift.STRUCT, 7)
		offset += p.JobsParams.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TMetaScanRange) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTasksParams() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tasks_params", thrift.STRUCT, 8)
		offset += p.TasksParams.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TMetaScanRange) fastWriteField9(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPartitionsParams() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "partitions_params", thrift.STRUCT, 9)
		offset += p.PartitionsParams.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TMetaScanRange) field1Length() int {
	l := 0
	if p.IsSetMetadataType() {
		l += bthrift.Binary.FieldBeginLength("metadata_type", thrift.I32, 1)
		l += bthrift.Binary.I32Length(int32(*p.MetadataType))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TMetaScanRange) field2Length() int {
	l := 0
	if p.IsSetIcebergParams() {
		l += bthrift.Binary.FieldBeginLength("iceberg_params", thrift.STRUCT, 2)
		l += p.IcebergParams.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TMetaScanRange) field3Length() int {
	l := 0
	if p.IsSetBackendsParams() {
		l += bthrift.Binary.FieldBeginLength("backends_params", thrift.STRUCT, 3)
		l += p.BackendsParams.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TMetaScanRange) field4Length() int {
	l := 0
	if p.IsSetFrontendsParams() {
		l += bthrift.Binary.FieldBeginLength("frontends_params", thrift.STRUCT, 4)
		l += p.FrontendsParams.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TMetaScanRange) field5Length() int {
	l := 0
	if p.IsSetQueriesParams() {
		l += bthrift.Binary.FieldBeginLength("queries_params", thrift.STRUCT, 5)
		l += p.QueriesParams.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TMetaScanRange) field6Length() int {
	l := 0
	if p.IsSetMaterializedViewsParams() {
		l += bthrift.Binary.FieldBeginLength("materialized_views_params", thrift.STRUCT, 6)
		l += p.MaterializedViewsParams.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TMetaScanRange) field7Length() int {
	l := 0
	if p.IsSetJobsParams() {
		l += bthrift.Binary.FieldBeginLength("jobs_params", thrift.STRUCT, 7)
		l += p.JobsParams.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TMetaScanRange) field8Length() int {
	l := 0
	if p.IsSetTasksParams() {
		l += bthrift.Binary.FieldBeginLength("tasks_params", thrift.STRUCT, 8)
		l += p.TasksParams.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TMetaScanRange) field9Length() int {
	l := 0
	if p.IsSetPartitionsParams() {
		l += bthrift.Binary.FieldBeginLength("partitions_params", thrift.STRUCT, 9)
		l += p.PartitionsParams.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TScanRange) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 4:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField9(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TScanRange[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TScanRange) FastReadField4(buf []byte) (int, error) {
	offset := 0

	tmp := NewTPaloScanRange()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.PaloScanRange = tmp
	return offset, nil
}

func (p *TScanRange) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBinary(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.KuduScanToken = []byte(v)

	}
	return offset, nil
}

func (p *TScanRange) FastReadField6(buf []byte) (int, error) {
	offset := 0

	tmp := NewTBrokerScanRange()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.BrokerScanRange = tmp
	return offset, nil
}

func (p *TScanRange) FastReadField7(buf []byte) (int, error) {
	offset := 0

	tmp := NewTEsScanRange()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.EsScanRange = tmp
	return offset, nil
}

func (p *TScanRange) FastReadField8(buf []byte) (int, error) {
	offset := 0

	tmp := NewTExternalScanRange()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.ExtScanRange = tmp
	return offset, nil
}

func (p *TScanRange) FastReadField9(buf []byte) (int, error) {
	offset := 0

	tmp := NewTDataGenScanRange()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.DataGenScanRange = tmp
	return offset, nil
}

func (p *TScanRange) FastReadField10(buf []byte) (int, error) {
	offset := 0

	tmp := NewTMetaScanRange()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.MetaScanRange = tmp
	return offset, nil
}

// for compatibility
func (p *TScanRange) FastWrite(buf []byte) int {
	return 0
}

func (p *TScanRange) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TScanRange")
	if p != nil {
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
		offset += p.fastWriteField9(buf[offset:], binaryWriter)
		offset += p.fastWriteField10(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TScanRange) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TScanRange")
	if p != nil {
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field9Length()
		l += p.field10Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TScanRange) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPaloScanRange() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "palo_scan_range", thrift.STRUCT, 4)
		offset += p.PaloScanRange.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TScanRange) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetKuduScanToken() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "kudu_scan_token", thrift.STRING, 5)
		offset += bthrift.Binary.WriteBinaryNocopy(buf[offset:], binaryWriter, []byte(p.KuduScanToken))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TScanRange) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetBrokerScanRange() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "broker_scan_range", thrift.STRUCT, 6)
		offset += p.BrokerScanRange.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TScanRange) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetEsScanRange() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "es_scan_range", thrift.STRUCT, 7)
		offset += p.EsScanRange.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TScanRange) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetExtScanRange() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "ext_scan_range", thrift.STRUCT, 8)
		offset += p.ExtScanRange.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TScanRange) fastWriteField9(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDataGenScanRange() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "data_gen_scan_range", thrift.STRUCT, 9)
		offset += p.DataGenScanRange.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TScanRange) fastWriteField10(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetMetaScanRange() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "meta_scan_range", thrift.STRUCT, 10)
		offset += p.MetaScanRange.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TScanRange) field4Length() int {
	l := 0
	if p.IsSetPaloScanRange() {
		l += bthrift.Binary.FieldBeginLength("palo_scan_range", thrift.STRUCT, 4)
		l += p.PaloScanRange.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TScanRange) field5Length() int {
	l := 0
	if p.IsSetKuduScanToken() {
		l += bthrift.Binary.FieldBeginLength("kudu_scan_token", thrift.STRING, 5)
		l += bthrift.Binary.BinaryLengthNocopy([]byte(p.KuduScanToken))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TScanRange) field6Length() int {
	l := 0
	if p.IsSetBrokerScanRange() {
		l += bthrift.Binary.FieldBeginLength("broker_scan_range", thrift.STRUCT, 6)
		l += p.BrokerScanRange.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TScanRange) field7Length() int {
	l := 0
	if p.IsSetEsScanRange() {
		l += bthrift.Binary.FieldBeginLength("es_scan_range", thrift.STRUCT, 7)
		l += p.EsScanRange.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TScanRange) field8Length() int {
	l := 0
	if p.IsSetExtScanRange() {
		l += bthrift.Binary.FieldBeginLength("ext_scan_range", thrift.STRUCT, 8)
		l += p.ExtScanRange.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TScanRange) field9Length() int {
	l := 0
	if p.IsSetDataGenScanRange() {
		l += bthrift.Binary.FieldBeginLength("data_gen_scan_range", thrift.STRUCT, 9)
		l += p.DataGenScanRange.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TScanRange) field10Length() int {
	l := 0
	if p.IsSetMetaScanRange() {
		l += bthrift.Binary.FieldBeginLength("meta_scan_range", thrift.STRUCT, 10)
		l += p.MetaScanRange.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TMySQLScanNode) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetTupleId bool = false
	var issetTableName bool = false
	var issetColumns bool = false
	var issetFilters bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetTupleId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetTableName = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetColumns = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetFilters = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetTupleId {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetTableName {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetColumns {
		fieldId = 3
		goto RequiredFieldNotSetError
	}

	if !issetFilters {
		fieldId = 4
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TMySQLScanNode[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TMySQLScanNode[fieldId]))
}

func (p *TMySQLScanNode) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.TupleId = v

	}
	return offset, nil
}

func (p *TMySQLScanNode) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.TableName = v

	}
	return offset, nil
}

func (p *TMySQLScanNode) FastReadField3(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Columns = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.Columns = append(p.Columns, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TMySQLScanNode) FastReadField4(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Filters = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.Filters = append(p.Filters, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

// for compatibility
func (p *TMySQLScanNode) FastWrite(buf []byte) int {
	return 0
}

func (p *TMySQLScanNode) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TMySQLScanNode")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TMySQLScanNode) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TMySQLScanNode")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TMySQLScanNode) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tuple_id", thrift.I32, 1)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.TupleId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TMySQLScanNode) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "table_name", thrift.STRING, 2)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.TableName)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TMySQLScanNode) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "columns", thrift.LIST, 3)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.STRING, 0)
	var length int
	for _, v := range p.Columns {
		length++
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRING, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TMySQLScanNode) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "filters", thrift.LIST, 4)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.STRING, 0)
	var length int
	for _, v := range p.Filters {
		length++
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRING, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TMySQLScanNode) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("tuple_id", thrift.I32, 1)
	l += bthrift.Binary.I32Length(p.TupleId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TMySQLScanNode) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("table_name", thrift.STRING, 2)
	l += bthrift.Binary.StringLengthNocopy(p.TableName)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TMySQLScanNode) field3Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("columns", thrift.LIST, 3)
	l += bthrift.Binary.ListBeginLength(thrift.STRING, len(p.Columns))
	for _, v := range p.Columns {
		l += bthrift.Binary.StringLengthNocopy(v)

	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TMySQLScanNode) field4Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("filters", thrift.LIST, 4)
	l += bthrift.Binary.ListBeginLength(thrift.STRING, len(p.Filters))
	for _, v := range p.Filters {
		l += bthrift.Binary.StringLengthNocopy(v)

	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOdbcScanNode) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TOdbcScanNode[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TOdbcScanNode) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.TupleId = &v

	}
	return offset, nil
}

func (p *TOdbcScanNode) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.TableName = &v

	}
	return offset, nil
}

func (p *TOdbcScanNode) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Driver = &v

	}
	return offset, nil
}

func (p *TOdbcScanNode) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := types.TOdbcTableType(v)
		p.Type = &tmp

	}
	return offset, nil
}

func (p *TOdbcScanNode) FastReadField5(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Columns = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.Columns = append(p.Columns, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TOdbcScanNode) FastReadField6(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Filters = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.Filters = append(p.Filters, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TOdbcScanNode) FastReadField7(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.ConnectString = &v

	}
	return offset, nil
}

func (p *TOdbcScanNode) FastReadField8(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.QueryString = &v

	}
	return offset, nil
}

// for compatibility
func (p *TOdbcScanNode) FastWrite(buf []byte) int {
	return 0
}

func (p *TOdbcScanNode) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TOdbcScanNode")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TOdbcScanNode) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TOdbcScanNode")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TOdbcScanNode) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTupleId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tuple_id", thrift.I32, 1)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.TupleId)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOdbcScanNode) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTableName() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "table_name", thrift.STRING, 2)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.TableName)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOdbcScanNode) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDriver() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "driver", thrift.STRING, 3)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Driver)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOdbcScanNode) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "type", thrift.I32, 4)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.Type))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOdbcScanNode) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetColumns() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "columns", thrift.LIST, 5)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRING, 0)
		var length int
		for _, v := range p.Columns {
			length++
			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRING, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOdbcScanNode) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFilters() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "filters", thrift.LIST, 6)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRING, 0)
		var length int
		for _, v := range p.Filters {
			length++
			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRING, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOdbcScanNode) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetConnectString() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "connect_string", thrift.STRING, 7)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.ConnectString)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOdbcScanNode) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetQueryString() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "query_string", thrift.STRING, 8)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.QueryString)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOdbcScanNode) field1Length() int {
	l := 0
	if p.IsSetTupleId() {
		l += bthrift.Binary.FieldBeginLength("tuple_id", thrift.I32, 1)
		l += bthrift.Binary.I32Length(*p.TupleId)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOdbcScanNode) field2Length() int {
	l := 0
	if p.IsSetTableName() {
		l += bthrift.Binary.FieldBeginLength("table_name", thrift.STRING, 2)
		l += bthrift.Binary.StringLengthNocopy(*p.TableName)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOdbcScanNode) field3Length() int {
	l := 0
	if p.IsSetDriver() {
		l += bthrift.Binary.FieldBeginLength("driver", thrift.STRING, 3)
		l += bthrift.Binary.StringLengthNocopy(*p.Driver)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOdbcScanNode) field4Length() int {
	l := 0
	if p.IsSetType() {
		l += bthrift.Binary.FieldBeginLength("type", thrift.I32, 4)
		l += bthrift.Binary.I32Length(int32(*p.Type))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOdbcScanNode) field5Length() int {
	l := 0
	if p.IsSetColumns() {
		l += bthrift.Binary.FieldBeginLength("columns", thrift.LIST, 5)
		l += bthrift.Binary.ListBeginLength(thrift.STRING, len(p.Columns))
		for _, v := range p.Columns {
			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOdbcScanNode) field6Length() int {
	l := 0
	if p.IsSetFilters() {
		l += bthrift.Binary.FieldBeginLength("filters", thrift.LIST, 6)
		l += bthrift.Binary.ListBeginLength(thrift.STRING, len(p.Filters))
		for _, v := range p.Filters {
			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOdbcScanNode) field7Length() int {
	l := 0
	if p.IsSetConnectString() {
		l += bthrift.Binary.FieldBeginLength("connect_string", thrift.STRING, 7)
		l += bthrift.Binary.StringLengthNocopy(*p.ConnectString)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOdbcScanNode) field8Length() int {
	l := 0
	if p.IsSetQueryString() {
		l += bthrift.Binary.FieldBeginLength("query_string", thrift.STRING, 8)
		l += bthrift.Binary.StringLengthNocopy(*p.QueryString)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TJdbcScanNode) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TJdbcScanNode[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TJdbcScanNode) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.TupleId = &v

	}
	return offset, nil
}

func (p *TJdbcScanNode) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.TableName = &v

	}
	return offset, nil
}

func (p *TJdbcScanNode) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.QueryString = &v

	}
	return offset, nil
}

func (p *TJdbcScanNode) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := types.TOdbcTableType(v)
		p.TableType = &tmp

	}
	return offset, nil
}

// for compatibility
func (p *TJdbcScanNode) FastWrite(buf []byte) int {
	return 0
}

func (p *TJdbcScanNode) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TJdbcScanNode")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TJdbcScanNode) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TJdbcScanNode")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TJdbcScanNode) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTupleId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tuple_id", thrift.I32, 1)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.TupleId)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TJdbcScanNode) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTableName() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "table_name", thrift.STRING, 2)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.TableName)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TJdbcScanNode) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetQueryString() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "query_string", thrift.STRING, 3)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.QueryString)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TJdbcScanNode) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTableType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "table_type", thrift.I32, 4)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.TableType))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TJdbcScanNode) field1Length() int {
	l := 0
	if p.IsSetTupleId() {
		l += bthrift.Binary.FieldBeginLength("tuple_id", thrift.I32, 1)
		l += bthrift.Binary.I32Length(*p.TupleId)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TJdbcScanNode) field2Length() int {
	l := 0
	if p.IsSetTableName() {
		l += bthrift.Binary.FieldBeginLength("table_name", thrift.STRING, 2)
		l += bthrift.Binary.StringLengthNocopy(*p.TableName)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TJdbcScanNode) field3Length() int {
	l := 0
	if p.IsSetQueryString() {
		l += bthrift.Binary.FieldBeginLength("query_string", thrift.STRING, 3)
		l += bthrift.Binary.StringLengthNocopy(*p.QueryString)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TJdbcScanNode) field4Length() int {
	l := 0
	if p.IsSetTableType() {
		l += bthrift.Binary.FieldBeginLength("table_type", thrift.I32, 4)
		l += bthrift.Binary.I32Length(int32(*p.TableType))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TBrokerScanNode) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetTupleId bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetTupleId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetTupleId {
		fieldId = 1
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TBrokerScanNode[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TBrokerScanNode[fieldId]))
}

func (p *TBrokerScanNode) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.TupleId = v

	}
	return offset, nil
}

func (p *TBrokerScanNode) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.PartitionExprs = make([]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_elem := exprs.NewTExpr()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.PartitionExprs = append(p.PartitionExprs, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TBrokerScanNode) FastReadField3(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.PartitionInfos = make([]*partitions.TRangePartition, 0, size)
	for i := 0; i < size; i++ {
		_elem := partitions.NewTRangePartition()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.PartitionInfos = append(p.PartitionInfos, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TBrokerScanNode) FastReadField4(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.PreFilterExprs = make([]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_elem := exprs.NewTExpr()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.PreFilterExprs = append(p.PreFilterExprs, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

// for compatibility
func (p *TBrokerScanNode) FastWrite(buf []byte) int {
	return 0
}

func (p *TBrokerScanNode) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TBrokerScanNode")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TBrokerScanNode) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TBrokerScanNode")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TBrokerScanNode) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tuple_id", thrift.I32, 1)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.TupleId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TBrokerScanNode) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPartitionExprs() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "partition_exprs", thrift.LIST, 2)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.PartitionExprs {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TBrokerScanNode) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPartitionInfos() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "partition_infos", thrift.LIST, 3)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.PartitionInfos {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TBrokerScanNode) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPreFilterExprs() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "pre_filter_exprs", thrift.LIST, 4)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.PreFilterExprs {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TBrokerScanNode) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("tuple_id", thrift.I32, 1)
	l += bthrift.Binary.I32Length(p.TupleId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TBrokerScanNode) field2Length() int {
	l := 0
	if p.IsSetPartitionExprs() {
		l += bthrift.Binary.FieldBeginLength("partition_exprs", thrift.LIST, 2)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.PartitionExprs))
		for _, v := range p.PartitionExprs {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TBrokerScanNode) field3Length() int {
	l := 0
	if p.IsSetPartitionInfos() {
		l += bthrift.Binary.FieldBeginLength("partition_infos", thrift.LIST, 3)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.PartitionInfos))
		for _, v := range p.PartitionInfos {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TBrokerScanNode) field4Length() int {
	l := 0
	if p.IsSetPreFilterExprs() {
		l += bthrift.Binary.FieldBeginLength("pre_filter_exprs", thrift.LIST, 4)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.PreFilterExprs))
		for _, v := range p.PreFilterExprs {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileScanNode) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TFileScanNode[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TFileScanNode) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.TupleId = &v

	}
	return offset, nil
}

func (p *TFileScanNode) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.TableName = &v

	}
	return offset, nil
}

// for compatibility
func (p *TFileScanNode) FastWrite(buf []byte) int {
	return 0
}

func (p *TFileScanNode) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TFileScanNode")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TFileScanNode) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TFileScanNode")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TFileScanNode) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTupleId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tuple_id", thrift.I32, 1)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.TupleId)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileScanNode) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTableName() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "table_name", thrift.STRING, 2)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.TableName)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TFileScanNode) field1Length() int {
	l := 0
	if p.IsSetTupleId() {
		l += bthrift.Binary.FieldBeginLength("tuple_id", thrift.I32, 1)
		l += bthrift.Binary.I32Length(*p.TupleId)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TFileScanNode) field2Length() int {
	l := 0
	if p.IsSetTableName() {
		l += bthrift.Binary.FieldBeginLength("table_name", thrift.STRING, 2)
		l += bthrift.Binary.StringLengthNocopy(*p.TableName)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TEsScanNode) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetTupleId bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetTupleId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetTupleId {
		fieldId = 1
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TEsScanNode[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TEsScanNode[fieldId]))
}

func (p *TEsScanNode) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.TupleId = v

	}
	return offset, nil
}

func (p *TEsScanNode) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := bthrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Properties = make(map[string]string, size)
	for i := 0; i < size; i++ {
		var _key string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_key = v

		}

		var _val string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_val = v

		}

		p.Properties[_key] = _val
	}
	if l, err := bthrift.Binary.ReadMapEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TEsScanNode) FastReadField3(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := bthrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.DocvalueContext = make(map[string]string, size)
	for i := 0; i < size; i++ {
		var _key string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_key = v

		}

		var _val string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_val = v

		}

		p.DocvalueContext[_key] = _val
	}
	if l, err := bthrift.Binary.ReadMapEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TEsScanNode) FastReadField4(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := bthrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.FieldsContext = make(map[string]string, size)
	for i := 0; i < size; i++ {
		var _key string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_key = v

		}

		var _val string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_val = v

		}

		p.FieldsContext[_key] = _val
	}
	if l, err := bthrift.Binary.ReadMapEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

// for compatibility
func (p *TEsScanNode) FastWrite(buf []byte) int {
	return 0
}

func (p *TEsScanNode) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TEsScanNode")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TEsScanNode) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TEsScanNode")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TEsScanNode) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tuple_id", thrift.I32, 1)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.TupleId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TEsScanNode) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetProperties() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "properties", thrift.MAP, 2)
		mapBeginOffset := offset
		offset += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRING, 0)
		var length int
		for k, v := range p.Properties {
			length++

			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, k)

			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.STRING, thrift.STRING, length)
		offset += bthrift.Binary.WriteMapEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TEsScanNode) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDocvalueContext() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "docvalue_context", thrift.MAP, 3)
		mapBeginOffset := offset
		offset += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRING, 0)
		var length int
		for k, v := range p.DocvalueContext {
			length++

			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, k)

			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.STRING, thrift.STRING, length)
		offset += bthrift.Binary.WriteMapEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TEsScanNode) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFieldsContext() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "fields_context", thrift.MAP, 4)
		mapBeginOffset := offset
		offset += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRING, 0)
		var length int
		for k, v := range p.FieldsContext {
			length++

			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, k)

			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.STRING, thrift.STRING, length)
		offset += bthrift.Binary.WriteMapEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TEsScanNode) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("tuple_id", thrift.I32, 1)
	l += bthrift.Binary.I32Length(p.TupleId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TEsScanNode) field2Length() int {
	l := 0
	if p.IsSetProperties() {
		l += bthrift.Binary.FieldBeginLength("properties", thrift.MAP, 2)
		l += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRING, len(p.Properties))
		for k, v := range p.Properties {

			l += bthrift.Binary.StringLengthNocopy(k)

			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.MapEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TEsScanNode) field3Length() int {
	l := 0
	if p.IsSetDocvalueContext() {
		l += bthrift.Binary.FieldBeginLength("docvalue_context", thrift.MAP, 3)
		l += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRING, len(p.DocvalueContext))
		for k, v := range p.DocvalueContext {

			l += bthrift.Binary.StringLengthNocopy(k)

			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.MapEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TEsScanNode) field4Length() int {
	l := 0
	if p.IsSetFieldsContext() {
		l += bthrift.Binary.FieldBeginLength("fields_context", thrift.MAP, 4)
		l += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRING, len(p.FieldsContext))
		for k, v := range p.FieldsContext {

			l += bthrift.Binary.StringLengthNocopy(k)

			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.MapEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TMiniLoadEtlFunction) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetFunctionName bool = false
	var issetParamColumnIndex bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetFunctionName = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetParamColumnIndex = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetFunctionName {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetParamColumnIndex {
		fieldId = 2
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TMiniLoadEtlFunction[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TMiniLoadEtlFunction[fieldId]))
}

func (p *TMiniLoadEtlFunction) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.FunctionName = v

	}
	return offset, nil
}

func (p *TMiniLoadEtlFunction) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.ParamColumnIndex = v

	}
	return offset, nil
}

// for compatibility
func (p *TMiniLoadEtlFunction) FastWrite(buf []byte) int {
	return 0
}

func (p *TMiniLoadEtlFunction) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TMiniLoadEtlFunction")
	if p != nil {
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TMiniLoadEtlFunction) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TMiniLoadEtlFunction")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TMiniLoadEtlFunction) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "function_name", thrift.STRING, 1)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.FunctionName)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TMiniLoadEtlFunction) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "param_column_index", thrift.I32, 2)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.ParamColumnIndex)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TMiniLoadEtlFunction) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("function_name", thrift.STRING, 1)
	l += bthrift.Binary.StringLengthNocopy(p.FunctionName)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TMiniLoadEtlFunction) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("param_column_index", thrift.I32, 2)
	l += bthrift.Binary.I32Length(p.ParamColumnIndex)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TCsvScanNode) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetTupleId bool = false
	var issetFilePaths bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetTupleId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetFilePaths = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.DOUBLE {
				l, err = p.FastReadField9(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetTupleId {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetFilePaths {
		fieldId = 2
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TCsvScanNode[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TCsvScanNode[fieldId]))
}

func (p *TCsvScanNode) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.TupleId = v

	}
	return offset, nil
}

func (p *TCsvScanNode) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.FilePaths = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.FilePaths = append(p.FilePaths, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TCsvScanNode) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.ColumnSeparator = &v

	}
	return offset, nil
}

func (p *TCsvScanNode) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.LineDelimiter = &v

	}
	return offset, nil
}

func (p *TCsvScanNode) FastReadField5(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := bthrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.ColumnTypeMapping = make(map[string]*types.TColumnType, size)
	for i := 0; i < size; i++ {
		var _key string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_key = v

		}
		_val := types.NewTColumnType()
		if l, err := _val.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.ColumnTypeMapping[_key] = _val
	}
	if l, err := bthrift.Binary.ReadMapEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TCsvScanNode) FastReadField6(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Columns = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.Columns = append(p.Columns, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TCsvScanNode) FastReadField7(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.UnspecifiedColumns = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.UnspecifiedColumns = append(p.UnspecifiedColumns, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TCsvScanNode) FastReadField8(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.DefaultValues = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.DefaultValues = append(p.DefaultValues, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TCsvScanNode) FastReadField9(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadDouble(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.MaxFilterRatio = &v

	}
	return offset, nil
}

func (p *TCsvScanNode) FastReadField10(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := bthrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.ColumnFunctionMapping = make(map[string]*TMiniLoadEtlFunction, size)
	for i := 0; i < size; i++ {
		var _key string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_key = v

		}
		_val := NewTMiniLoadEtlFunction()
		if l, err := _val.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.ColumnFunctionMapping[_key] = _val
	}
	if l, err := bthrift.Binary.ReadMapEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

// for compatibility
func (p *TCsvScanNode) FastWrite(buf []byte) int {
	return 0
}

func (p *TCsvScanNode) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TCsvScanNode")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField9(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
		offset += p.fastWriteField10(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TCsvScanNode) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TCsvScanNode")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field9Length()
		l += p.field10Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TCsvScanNode) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tuple_id", thrift.I32, 1)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.TupleId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TCsvScanNode) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "file_paths", thrift.LIST, 2)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.STRING, 0)
	var length int
	for _, v := range p.FilePaths {
		length++
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRING, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TCsvScanNode) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetColumnSeparator() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "column_separator", thrift.STRING, 3)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.ColumnSeparator)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TCsvScanNode) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetLineDelimiter() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "line_delimiter", thrift.STRING, 4)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.LineDelimiter)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TCsvScanNode) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetColumnTypeMapping() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "column_type_mapping", thrift.MAP, 5)
		mapBeginOffset := offset
		offset += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRUCT, 0)
		var length int
		for k, v := range p.ColumnTypeMapping {
			length++

			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, k)

			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.STRING, thrift.STRUCT, length)
		offset += bthrift.Binary.WriteMapEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TCsvScanNode) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetColumns() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "columns", thrift.LIST, 6)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRING, 0)
		var length int
		for _, v := range p.Columns {
			length++
			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRING, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TCsvScanNode) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetUnspecifiedColumns() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "unspecified_columns", thrift.LIST, 7)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRING, 0)
		var length int
		for _, v := range p.UnspecifiedColumns {
			length++
			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRING, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TCsvScanNode) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDefaultValues() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "default_values", thrift.LIST, 8)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRING, 0)
		var length int
		for _, v := range p.DefaultValues {
			length++
			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRING, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TCsvScanNode) fastWriteField9(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetMaxFilterRatio() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "max_filter_ratio", thrift.DOUBLE, 9)
		offset += bthrift.Binary.WriteDouble(buf[offset:], *p.MaxFilterRatio)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TCsvScanNode) fastWriteField10(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetColumnFunctionMapping() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "column_function_mapping", thrift.MAP, 10)
		mapBeginOffset := offset
		offset += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRUCT, 0)
		var length int
		for k, v := range p.ColumnFunctionMapping {
			length++

			offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, k)

			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.STRING, thrift.STRUCT, length)
		offset += bthrift.Binary.WriteMapEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TCsvScanNode) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("tuple_id", thrift.I32, 1)
	l += bthrift.Binary.I32Length(p.TupleId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TCsvScanNode) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("file_paths", thrift.LIST, 2)
	l += bthrift.Binary.ListBeginLength(thrift.STRING, len(p.FilePaths))
	for _, v := range p.FilePaths {
		l += bthrift.Binary.StringLengthNocopy(v)

	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TCsvScanNode) field3Length() int {
	l := 0
	if p.IsSetColumnSeparator() {
		l += bthrift.Binary.FieldBeginLength("column_separator", thrift.STRING, 3)
		l += bthrift.Binary.StringLengthNocopy(*p.ColumnSeparator)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TCsvScanNode) field4Length() int {
	l := 0
	if p.IsSetLineDelimiter() {
		l += bthrift.Binary.FieldBeginLength("line_delimiter", thrift.STRING, 4)
		l += bthrift.Binary.StringLengthNocopy(*p.LineDelimiter)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TCsvScanNode) field5Length() int {
	l := 0
	if p.IsSetColumnTypeMapping() {
		l += bthrift.Binary.FieldBeginLength("column_type_mapping", thrift.MAP, 5)
		l += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRUCT, len(p.ColumnTypeMapping))
		for k, v := range p.ColumnTypeMapping {

			l += bthrift.Binary.StringLengthNocopy(k)

			l += v.BLength()
		}
		l += bthrift.Binary.MapEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TCsvScanNode) field6Length() int {
	l := 0
	if p.IsSetColumns() {
		l += bthrift.Binary.FieldBeginLength("columns", thrift.LIST, 6)
		l += bthrift.Binary.ListBeginLength(thrift.STRING, len(p.Columns))
		for _, v := range p.Columns {
			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TCsvScanNode) field7Length() int {
	l := 0
	if p.IsSetUnspecifiedColumns() {
		l += bthrift.Binary.FieldBeginLength("unspecified_columns", thrift.LIST, 7)
		l += bthrift.Binary.ListBeginLength(thrift.STRING, len(p.UnspecifiedColumns))
		for _, v := range p.UnspecifiedColumns {
			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TCsvScanNode) field8Length() int {
	l := 0
	if p.IsSetDefaultValues() {
		l += bthrift.Binary.FieldBeginLength("default_values", thrift.LIST, 8)
		l += bthrift.Binary.ListBeginLength(thrift.STRING, len(p.DefaultValues))
		for _, v := range p.DefaultValues {
			l += bthrift.Binary.StringLengthNocopy(v)

		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TCsvScanNode) field9Length() int {
	l := 0
	if p.IsSetMaxFilterRatio() {
		l += bthrift.Binary.FieldBeginLength("max_filter_ratio", thrift.DOUBLE, 9)
		l += bthrift.Binary.DoubleLength(*p.MaxFilterRatio)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TCsvScanNode) field10Length() int {
	l := 0
	if p.IsSetColumnFunctionMapping() {
		l += bthrift.Binary.FieldBeginLength("column_function_mapping", thrift.MAP, 10)
		l += bthrift.Binary.MapBeginLength(thrift.STRING, thrift.STRUCT, len(p.ColumnFunctionMapping))
		for k, v := range p.ColumnFunctionMapping {

			l += bthrift.Binary.StringLengthNocopy(k)

			l += v.BLength()
		}
		l += bthrift.Binary.MapEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TSchemaScanNode) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetTupleId bool = false
	var issetTableName bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetTupleId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetTableName = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField9(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 11:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField11(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 12:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField12(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 14:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField14(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 15:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField15(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetTupleId {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetTableName {
		fieldId = 2
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TSchemaScanNode[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TSchemaScanNode[fieldId]))
}

func (p *TSchemaScanNode) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.TupleId = v

	}
	return offset, nil
}

func (p *TSchemaScanNode) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.TableName = v

	}
	return offset, nil
}

func (p *TSchemaScanNode) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Db = &v

	}
	return offset, nil
}

func (p *TSchemaScanNode) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Table = &v

	}
	return offset, nil
}

func (p *TSchemaScanNode) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Wild = &v

	}
	return offset, nil
}

func (p *TSchemaScanNode) FastReadField6(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.User = &v

	}
	return offset, nil
}

func (p *TSchemaScanNode) FastReadField7(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Ip = &v

	}
	return offset, nil
}

func (p *TSchemaScanNode) FastReadField8(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Port = &v

	}
	return offset, nil
}

func (p *TSchemaScanNode) FastReadField9(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.ThreadId = &v

	}
	return offset, nil
}

func (p *TSchemaScanNode) FastReadField10(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.UserIp = &v

	}
	return offset, nil
}

func (p *TSchemaScanNode) FastReadField11(buf []byte) (int, error) {
	offset := 0

	tmp := types.NewTUserIdentity()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.CurrentUserIdent = tmp
	return offset, nil
}

func (p *TSchemaScanNode) FastReadField12(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.ShowHiddenCloumns = v

	}
	return offset, nil
}

func (p *TSchemaScanNode) FastReadField14(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Catalog = &v

	}
	return offset, nil
}

func (p *TSchemaScanNode) FastReadField15(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.FeAddrList = make([]*types.TNetworkAddress, 0, size)
	for i := 0; i < size; i++ {
		_elem := types.NewTNetworkAddress()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.FeAddrList = append(p.FeAddrList, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

// for compatibility
func (p *TSchemaScanNode) FastWrite(buf []byte) int {
	return 0
}

func (p *TSchemaScanNode) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TSchemaScanNode")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
		offset += p.fastWriteField9(buf[offset:], binaryWriter)
		offset += p.fastWriteField12(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField10(buf[offset:], binaryWriter)
		offset += p.fastWriteField11(buf[offset:], binaryWriter)
		offset += p.fastWriteField14(buf[offset:], binaryWriter)
		offset += p.fastWriteField15(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TSchemaScanNode) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TSchemaScanNode")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field9Length()
		l += p.field10Length()
		l += p.field11Length()
		l += p.field12Length()
		l += p.field14Length()
		l += p.field15Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TSchemaScanNode) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tuple_id", thrift.I32, 1)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.TupleId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TSchemaScanNode) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "table_name", thrift.STRING, 2)
	offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, p.TableName)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TSchemaScanNode) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDb() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "db", thrift.STRING, 3)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Db)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TSchemaScanNode) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTable() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "table", thrift.STRING, 4)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Table)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TSchemaScanNode) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetWild() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "wild", thrift.STRING, 5)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Wild)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TSchemaScanNode) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetUser() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "user", thrift.STRING, 6)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.User)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TSchemaScanNode) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIp() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "ip", thrift.STRING, 7)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Ip)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TSchemaScanNode) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPort() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "port", thrift.I32, 8)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.Port)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TSchemaScanNode) fastWriteField9(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetThreadId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "thread_id", thrift.I64, 9)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.ThreadId)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TSchemaScanNode) fastWriteField10(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetUserIp() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "user_ip", thrift.STRING, 10)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.UserIp)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TSchemaScanNode) fastWriteField11(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetCurrentUserIdent() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "current_user_ident", thrift.STRUCT, 11)
		offset += p.CurrentUserIdent.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TSchemaScanNode) fastWriteField12(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetShowHiddenCloumns() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "show_hidden_cloumns", thrift.BOOL, 12)
		offset += bthrift.Binary.WriteBool(buf[offset:], p.ShowHiddenCloumns)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TSchemaScanNode) fastWriteField14(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetCatalog() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "catalog", thrift.STRING, 14)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.Catalog)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TSchemaScanNode) fastWriteField15(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFeAddrList() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "fe_addr_list", thrift.LIST, 15)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.FeAddrList {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TSchemaScanNode) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("tuple_id", thrift.I32, 1)
	l += bthrift.Binary.I32Length(p.TupleId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TSchemaScanNode) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("table_name", thrift.STRING, 2)
	l += bthrift.Binary.StringLengthNocopy(p.TableName)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TSchemaScanNode) field3Length() int {
	l := 0
	if p.IsSetDb() {
		l += bthrift.Binary.FieldBeginLength("db", thrift.STRING, 3)
		l += bthrift.Binary.StringLengthNocopy(*p.Db)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TSchemaScanNode) field4Length() int {
	l := 0
	if p.IsSetTable() {
		l += bthrift.Binary.FieldBeginLength("table", thrift.STRING, 4)
		l += bthrift.Binary.StringLengthNocopy(*p.Table)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TSchemaScanNode) field5Length() int {
	l := 0
	if p.IsSetWild() {
		l += bthrift.Binary.FieldBeginLength("wild", thrift.STRING, 5)
		l += bthrift.Binary.StringLengthNocopy(*p.Wild)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TSchemaScanNode) field6Length() int {
	l := 0
	if p.IsSetUser() {
		l += bthrift.Binary.FieldBeginLength("user", thrift.STRING, 6)
		l += bthrift.Binary.StringLengthNocopy(*p.User)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TSchemaScanNode) field7Length() int {
	l := 0
	if p.IsSetIp() {
		l += bthrift.Binary.FieldBeginLength("ip", thrift.STRING, 7)
		l += bthrift.Binary.StringLengthNocopy(*p.Ip)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TSchemaScanNode) field8Length() int {
	l := 0
	if p.IsSetPort() {
		l += bthrift.Binary.FieldBeginLength("port", thrift.I32, 8)
		l += bthrift.Binary.I32Length(*p.Port)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TSchemaScanNode) field9Length() int {
	l := 0
	if p.IsSetThreadId() {
		l += bthrift.Binary.FieldBeginLength("thread_id", thrift.I64, 9)
		l += bthrift.Binary.I64Length(*p.ThreadId)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TSchemaScanNode) field10Length() int {
	l := 0
	if p.IsSetUserIp() {
		l += bthrift.Binary.FieldBeginLength("user_ip", thrift.STRING, 10)
		l += bthrift.Binary.StringLengthNocopy(*p.UserIp)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TSchemaScanNode) field11Length() int {
	l := 0
	if p.IsSetCurrentUserIdent() {
		l += bthrift.Binary.FieldBeginLength("current_user_ident", thrift.STRUCT, 11)
		l += p.CurrentUserIdent.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TSchemaScanNode) field12Length() int {
	l := 0
	if p.IsSetShowHiddenCloumns() {
		l += bthrift.Binary.FieldBeginLength("show_hidden_cloumns", thrift.BOOL, 12)
		l += bthrift.Binary.BoolLength(p.ShowHiddenCloumns)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TSchemaScanNode) field14Length() int {
	l := 0
	if p.IsSetCatalog() {
		l += bthrift.Binary.FieldBeginLength("catalog", thrift.STRING, 14)
		l += bthrift.Binary.StringLengthNocopy(*p.Catalog)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TSchemaScanNode) field15Length() int {
	l := 0
	if p.IsSetFeAddrList() {
		l += bthrift.Binary.FieldBeginLength("fe_addr_list", thrift.LIST, 15)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.FeAddrList))
		for _, v := range p.FeAddrList {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TMetaScanNode) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetTupleId bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetTupleId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetTupleId {
		fieldId = 1
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TMetaScanNode[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TMetaScanNode[fieldId]))
}

func (p *TMetaScanNode) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.TupleId = v

	}
	return offset, nil
}

func (p *TMetaScanNode) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := types.TMetadataType(v)
		p.MetadataType = &tmp

	}
	return offset, nil
}

func (p *TMetaScanNode) FastReadField3(buf []byte) (int, error) {
	offset := 0

	tmp := types.NewTUserIdentity()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.CurrentUserIdent = tmp
	return offset, nil
}

// for compatibility
func (p *TMetaScanNode) FastWrite(buf []byte) int {
	return 0
}

func (p *TMetaScanNode) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TMetaScanNode")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TMetaScanNode) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TMetaScanNode")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TMetaScanNode) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tuple_id", thrift.I32, 1)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.TupleId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TMetaScanNode) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetMetadataType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "metadata_type", thrift.I32, 2)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.MetadataType))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TMetaScanNode) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetCurrentUserIdent() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "current_user_ident", thrift.STRUCT, 3)
		offset += p.CurrentUserIdent.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TMetaScanNode) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("tuple_id", thrift.I32, 1)
	l += bthrift.Binary.I32Length(p.TupleId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TMetaScanNode) field2Length() int {
	l := 0
	if p.IsSetMetadataType() {
		l += bthrift.Binary.FieldBeginLength("metadata_type", thrift.I32, 2)
		l += bthrift.Binary.I32Length(int32(*p.MetadataType))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TMetaScanNode) field3Length() int {
	l := 0
	if p.IsSetCurrentUserIdent() {
		l += bthrift.Binary.FieldBeginLength("current_user_ident", thrift.STRUCT, 3)
		l += p.CurrentUserIdent.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTestExternalScanNode) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TTestExternalScanNode[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TTestExternalScanNode) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.TupleId = &v

	}
	return offset, nil
}

func (p *TTestExternalScanNode) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.TableName = &v

	}
	return offset, nil
}

// for compatibility
func (p *TTestExternalScanNode) FastWrite(buf []byte) int {
	return 0
}

func (p *TTestExternalScanNode) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TTestExternalScanNode")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TTestExternalScanNode) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TTestExternalScanNode")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TTestExternalScanNode) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTupleId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tuple_id", thrift.I32, 1)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.TupleId)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTestExternalScanNode) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTableName() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "table_name", thrift.STRING, 2)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.TableName)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTestExternalScanNode) field1Length() int {
	l := 0
	if p.IsSetTupleId() {
		l += bthrift.Binary.FieldBeginLength("tuple_id", thrift.I32, 1)
		l += bthrift.Binary.I32Length(*p.TupleId)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTestExternalScanNode) field2Length() int {
	l := 0
	if p.IsSetTableName() {
		l += bthrift.Binary.FieldBeginLength("table_name", thrift.STRING, 2)
		l += bthrift.Binary.StringLengthNocopy(*p.TableName)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TSortInfo) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetOrderingExprs bool = false
	var issetIsAscOrder bool = false
	var issetNullsFirst bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetOrderingExprs = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetIsAscOrder = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetNullsFirst = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetOrderingExprs {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetIsAscOrder {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetNullsFirst {
		fieldId = 3
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TSortInfo[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TSortInfo[fieldId]))
}

func (p *TSortInfo) FastReadField1(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.OrderingExprs = make([]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_elem := exprs.NewTExpr()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.OrderingExprs = append(p.OrderingExprs, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TSortInfo) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.IsAscOrder = make([]bool, 0, size)
	for i := 0; i < size; i++ {
		var _elem bool
		if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.IsAscOrder = append(p.IsAscOrder, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TSortInfo) FastReadField3(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.NullsFirst = make([]bool, 0, size)
	for i := 0; i < size; i++ {
		var _elem bool
		if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.NullsFirst = append(p.NullsFirst, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TSortInfo) FastReadField4(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.SortTupleSlotExprs = make([]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_elem := exprs.NewTExpr()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.SortTupleSlotExprs = append(p.SortTupleSlotExprs, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TSortInfo) FastReadField5(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.SlotExprsNullabilityChangedFlags = make([]bool, 0, size)
	for i := 0; i < size; i++ {
		var _elem bool
		if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.SlotExprsNullabilityChangedFlags = append(p.SlotExprsNullabilityChangedFlags, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TSortInfo) FastReadField6(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.UseTwoPhaseRead = &v

	}
	return offset, nil
}

// for compatibility
func (p *TSortInfo) FastWrite(buf []byte) int {
	return 0
}

func (p *TSortInfo) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TSortInfo")
	if p != nil {
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TSortInfo) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TSortInfo")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TSortInfo) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "ordering_exprs", thrift.LIST, 1)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
	var length int
	for _, v := range p.OrderingExprs {
		length++
		offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TSortInfo) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "is_asc_order", thrift.LIST, 2)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.BOOL, 0)
	var length int
	for _, v := range p.IsAscOrder {
		length++
		offset += bthrift.Binary.WriteBool(buf[offset:], v)

	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.BOOL, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TSortInfo) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "nulls_first", thrift.LIST, 3)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.BOOL, 0)
	var length int
	for _, v := range p.NullsFirst {
		length++
		offset += bthrift.Binary.WriteBool(buf[offset:], v)

	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.BOOL, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TSortInfo) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSortTupleSlotExprs() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "sort_tuple_slot_exprs", thrift.LIST, 4)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.SortTupleSlotExprs {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TSortInfo) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSlotExprsNullabilityChangedFlags() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "slot_exprs_nullability_changed_flags", thrift.LIST, 5)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.BOOL, 0)
		var length int
		for _, v := range p.SlotExprsNullabilityChangedFlags {
			length++
			offset += bthrift.Binary.WriteBool(buf[offset:], v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.BOOL, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TSortInfo) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetUseTwoPhaseRead() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "use_two_phase_read", thrift.BOOL, 6)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.UseTwoPhaseRead)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TSortInfo) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("ordering_exprs", thrift.LIST, 1)
	l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.OrderingExprs))
	for _, v := range p.OrderingExprs {
		l += v.BLength()
	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TSortInfo) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("is_asc_order", thrift.LIST, 2)
	l += bthrift.Binary.ListBeginLength(thrift.BOOL, len(p.IsAscOrder))
	var tmpV bool
	l += bthrift.Binary.BoolLength(bool(tmpV)) * len(p.IsAscOrder)
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TSortInfo) field3Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("nulls_first", thrift.LIST, 3)
	l += bthrift.Binary.ListBeginLength(thrift.BOOL, len(p.NullsFirst))
	var tmpV bool
	l += bthrift.Binary.BoolLength(bool(tmpV)) * len(p.NullsFirst)
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TSortInfo) field4Length() int {
	l := 0
	if p.IsSetSortTupleSlotExprs() {
		l += bthrift.Binary.FieldBeginLength("sort_tuple_slot_exprs", thrift.LIST, 4)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.SortTupleSlotExprs))
		for _, v := range p.SortTupleSlotExprs {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TSortInfo) field5Length() int {
	l := 0
	if p.IsSetSlotExprsNullabilityChangedFlags() {
		l += bthrift.Binary.FieldBeginLength("slot_exprs_nullability_changed_flags", thrift.LIST, 5)
		l += bthrift.Binary.ListBeginLength(thrift.BOOL, len(p.SlotExprsNullabilityChangedFlags))
		var tmpV bool
		l += bthrift.Binary.BoolLength(bool(tmpV)) * len(p.SlotExprsNullabilityChangedFlags)
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TSortInfo) field6Length() int {
	l := 0
	if p.IsSetUseTwoPhaseRead() {
		l += bthrift.Binary.FieldBeginLength("use_two_phase_read", thrift.BOOL, 6)
		l += bthrift.Binary.BoolLength(*p.UseTwoPhaseRead)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapScanNode) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetTupleId bool = false
	var issetKeyColumnName bool = false
	var issetKeyColumnType bool = false
	var issetIsPreaggregation bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetTupleId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetKeyColumnName = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetKeyColumnType = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetIsPreaggregation = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField9(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 11:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField11(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 12:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField12(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 13:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField13(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 14:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField14(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 15:
			if fieldTypeId == thrift.SET {
				l, err = p.FastReadField15(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 16:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField16(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 17:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField17(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 18:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField18(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetTupleId {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetKeyColumnName {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetKeyColumnType {
		fieldId = 3
		goto RequiredFieldNotSetError
	}

	if !issetIsPreaggregation {
		fieldId = 4
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TOlapScanNode[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TOlapScanNode[fieldId]))
}

func (p *TOlapScanNode) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.TupleId = v

	}
	return offset, nil
}

func (p *TOlapScanNode) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.KeyColumnName = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem string
		if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.KeyColumnName = append(p.KeyColumnName, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TOlapScanNode) FastReadField3(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.KeyColumnType = make([]types.TPrimitiveType, 0, size)
	for i := 0; i < size; i++ {
		var _elem types.TPrimitiveType
		if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = types.TPrimitiveType(v)

		}

		p.KeyColumnType = append(p.KeyColumnType, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TOlapScanNode) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.IsPreaggregation = v

	}
	return offset, nil
}

func (p *TOlapScanNode) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.SortColumn = &v

	}
	return offset, nil
}

func (p *TOlapScanNode) FastReadField6(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := types.TKeysType(v)
		p.KeyType = &tmp

	}
	return offset, nil
}

func (p *TOlapScanNode) FastReadField7(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.TableName = &v

	}
	return offset, nil
}

func (p *TOlapScanNode) FastReadField8(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.ColumnsDesc = make([]*descriptors.TColumn, 0, size)
	for i := 0; i < size; i++ {
		_elem := descriptors.NewTColumn()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.ColumnsDesc = append(p.ColumnsDesc, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TOlapScanNode) FastReadField9(buf []byte) (int, error) {
	offset := 0

	tmp := NewTSortInfo()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.SortInfo = tmp
	return offset, nil
}

func (p *TOlapScanNode) FastReadField10(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.SortLimit = &v

	}
	return offset, nil
}

func (p *TOlapScanNode) FastReadField11(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.EnableUniqueKeyMergeOnWrite = &v

	}
	return offset, nil
}

func (p *TOlapScanNode) FastReadField12(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := TPushAggOp(v)
		p.PushDownAggTypeOpt = &tmp

	}
	return offset, nil
}

func (p *TOlapScanNode) FastReadField13(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.UseTopnOpt = &v

	}
	return offset, nil
}

func (p *TOlapScanNode) FastReadField14(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.IndexesDesc = make([]*descriptors.TOlapTableIndex, 0, size)
	for i := 0; i < size; i++ {
		_elem := descriptors.NewTOlapTableIndex()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.IndexesDesc = append(p.IndexesDesc, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TOlapScanNode) FastReadField15(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadSetBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.OutputColumnUniqueIds = make([]int32, 0, size)
	for i := 0; i < size; i++ {
		var _elem int32
		if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.OutputColumnUniqueIds = append(p.OutputColumnUniqueIds, _elem)
	}
	if l, err := bthrift.Binary.ReadSetEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TOlapScanNode) FastReadField16(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.DistributeColumnIds = make([]int32, 0, size)
	for i := 0; i < size; i++ {
		var _elem int32
		if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.DistributeColumnIds = append(p.DistributeColumnIds, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TOlapScanNode) FastReadField17(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.SchemaVersion = &v

	}
	return offset, nil
}

func (p *TOlapScanNode) FastReadField18(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.TopnFilterSourceNodeIds = make([]int32, 0, size)
	for i := 0; i < size; i++ {
		var _elem int32
		if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.TopnFilterSourceNodeIds = append(p.TopnFilterSourceNodeIds, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

// for compatibility
func (p *TOlapScanNode) FastWrite(buf []byte) int {
	return 0
}

func (p *TOlapScanNode) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TOlapScanNode")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField10(buf[offset:], binaryWriter)
		offset += p.fastWriteField11(buf[offset:], binaryWriter)
		offset += p.fastWriteField13(buf[offset:], binaryWriter)
		offset += p.fastWriteField17(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
		offset += p.fastWriteField9(buf[offset:], binaryWriter)
		offset += p.fastWriteField12(buf[offset:], binaryWriter)
		offset += p.fastWriteField14(buf[offset:], binaryWriter)
		offset += p.fastWriteField15(buf[offset:], binaryWriter)
		offset += p.fastWriteField16(buf[offset:], binaryWriter)
		offset += p.fastWriteField18(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TOlapScanNode) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TOlapScanNode")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field9Length()
		l += p.field10Length()
		l += p.field11Length()
		l += p.field12Length()
		l += p.field13Length()
		l += p.field14Length()
		l += p.field15Length()
		l += p.field16Length()
		l += p.field17Length()
		l += p.field18Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TOlapScanNode) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tuple_id", thrift.I32, 1)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.TupleId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapScanNode) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "key_column_name", thrift.LIST, 2)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.STRING, 0)
	var length int
	for _, v := range p.KeyColumnName {
		length++
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, v)

	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRING, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapScanNode) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "key_column_type", thrift.LIST, 3)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.I32, 0)
	var length int
	for _, v := range p.KeyColumnType {
		length++
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(v))

	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.I32, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapScanNode) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "is_preaggregation", thrift.BOOL, 4)
	offset += bthrift.Binary.WriteBool(buf[offset:], p.IsPreaggregation)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapScanNode) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSortColumn() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "sort_column", thrift.STRING, 5)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.SortColumn)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapScanNode) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetKeyType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "keyType", thrift.I32, 6)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.KeyType))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapScanNode) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTableName() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "table_name", thrift.STRING, 7)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.TableName)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapScanNode) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetColumnsDesc() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "columns_desc", thrift.LIST, 8)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.ColumnsDesc {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapScanNode) fastWriteField9(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSortInfo() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "sort_info", thrift.STRUCT, 9)
		offset += p.SortInfo.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapScanNode) fastWriteField10(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSortLimit() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "sort_limit", thrift.I64, 10)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.SortLimit)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapScanNode) fastWriteField11(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetEnableUniqueKeyMergeOnWrite() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "enable_unique_key_merge_on_write", thrift.BOOL, 11)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.EnableUniqueKeyMergeOnWrite)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapScanNode) fastWriteField12(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPushDownAggTypeOpt() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "push_down_agg_type_opt", thrift.I32, 12)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.PushDownAggTypeOpt))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapScanNode) fastWriteField13(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetUseTopnOpt() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "use_topn_opt", thrift.BOOL, 13)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.UseTopnOpt)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapScanNode) fastWriteField14(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIndexesDesc() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "indexes_desc", thrift.LIST, 14)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.IndexesDesc {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapScanNode) fastWriteField15(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetOutputColumnUniqueIds() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "output_column_unique_ids", thrift.SET, 15)
		setBeginOffset := offset
		offset += bthrift.Binary.SetBeginLength(thrift.I32, 0)

		for i := 0; i < len(p.OutputColumnUniqueIds); i++ {
			for j := i + 1; j < len(p.OutputColumnUniqueIds); j++ {
				if func(tgt, src int32) bool {
					if tgt != src {
						return false
					}
					return true
				}(p.OutputColumnUniqueIds[i], p.OutputColumnUniqueIds[j]) {
					panic(fmt.Errorf("%T error writing set field: slice is not unique", p.OutputColumnUniqueIds[i]))
				}
			}
		}
		var length int
		for _, v := range p.OutputColumnUniqueIds {
			length++
			offset += bthrift.Binary.WriteI32(buf[offset:], v)

		}
		bthrift.Binary.WriteSetBegin(buf[setBeginOffset:], thrift.I32, length)
		offset += bthrift.Binary.WriteSetEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapScanNode) fastWriteField16(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDistributeColumnIds() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "distribute_column_ids", thrift.LIST, 16)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.I32, 0)
		var length int
		for _, v := range p.DistributeColumnIds {
			length++
			offset += bthrift.Binary.WriteI32(buf[offset:], v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.I32, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapScanNode) fastWriteField17(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSchemaVersion() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "schema_version", thrift.I32, 17)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.SchemaVersion)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapScanNode) fastWriteField18(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTopnFilterSourceNodeIds() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "topn_filter_source_node_ids", thrift.LIST, 18)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.I32, 0)
		var length int
		for _, v := range p.TopnFilterSourceNodeIds {
			length++
			offset += bthrift.Binary.WriteI32(buf[offset:], v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.I32, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TOlapScanNode) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("tuple_id", thrift.I32, 1)
	l += bthrift.Binary.I32Length(p.TupleId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapScanNode) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("key_column_name", thrift.LIST, 2)
	l += bthrift.Binary.ListBeginLength(thrift.STRING, len(p.KeyColumnName))
	for _, v := range p.KeyColumnName {
		l += bthrift.Binary.StringLengthNocopy(v)

	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapScanNode) field3Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("key_column_type", thrift.LIST, 3)
	l += bthrift.Binary.ListBeginLength(thrift.I32, len(p.KeyColumnType))
	for _, v := range p.KeyColumnType {
		l += bthrift.Binary.I32Length(int32(v))

	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapScanNode) field4Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("is_preaggregation", thrift.BOOL, 4)
	l += bthrift.Binary.BoolLength(p.IsPreaggregation)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapScanNode) field5Length() int {
	l := 0
	if p.IsSetSortColumn() {
		l += bthrift.Binary.FieldBeginLength("sort_column", thrift.STRING, 5)
		l += bthrift.Binary.StringLengthNocopy(*p.SortColumn)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapScanNode) field6Length() int {
	l := 0
	if p.IsSetKeyType() {
		l += bthrift.Binary.FieldBeginLength("keyType", thrift.I32, 6)
		l += bthrift.Binary.I32Length(int32(*p.KeyType))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapScanNode) field7Length() int {
	l := 0
	if p.IsSetTableName() {
		l += bthrift.Binary.FieldBeginLength("table_name", thrift.STRING, 7)
		l += bthrift.Binary.StringLengthNocopy(*p.TableName)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapScanNode) field8Length() int {
	l := 0
	if p.IsSetColumnsDesc() {
		l += bthrift.Binary.FieldBeginLength("columns_desc", thrift.LIST, 8)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.ColumnsDesc))
		for _, v := range p.ColumnsDesc {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapScanNode) field9Length() int {
	l := 0
	if p.IsSetSortInfo() {
		l += bthrift.Binary.FieldBeginLength("sort_info", thrift.STRUCT, 9)
		l += p.SortInfo.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapScanNode) field10Length() int {
	l := 0
	if p.IsSetSortLimit() {
		l += bthrift.Binary.FieldBeginLength("sort_limit", thrift.I64, 10)
		l += bthrift.Binary.I64Length(*p.SortLimit)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapScanNode) field11Length() int {
	l := 0
	if p.IsSetEnableUniqueKeyMergeOnWrite() {
		l += bthrift.Binary.FieldBeginLength("enable_unique_key_merge_on_write", thrift.BOOL, 11)
		l += bthrift.Binary.BoolLength(*p.EnableUniqueKeyMergeOnWrite)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapScanNode) field12Length() int {
	l := 0
	if p.IsSetPushDownAggTypeOpt() {
		l += bthrift.Binary.FieldBeginLength("push_down_agg_type_opt", thrift.I32, 12)
		l += bthrift.Binary.I32Length(int32(*p.PushDownAggTypeOpt))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapScanNode) field13Length() int {
	l := 0
	if p.IsSetUseTopnOpt() {
		l += bthrift.Binary.FieldBeginLength("use_topn_opt", thrift.BOOL, 13)
		l += bthrift.Binary.BoolLength(*p.UseTopnOpt)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapScanNode) field14Length() int {
	l := 0
	if p.IsSetIndexesDesc() {
		l += bthrift.Binary.FieldBeginLength("indexes_desc", thrift.LIST, 14)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.IndexesDesc))
		for _, v := range p.IndexesDesc {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapScanNode) field15Length() int {
	l := 0
	if p.IsSetOutputColumnUniqueIds() {
		l += bthrift.Binary.FieldBeginLength("output_column_unique_ids", thrift.SET, 15)
		l += bthrift.Binary.SetBeginLength(thrift.I32, len(p.OutputColumnUniqueIds))

		for i := 0; i < len(p.OutputColumnUniqueIds); i++ {
			for j := i + 1; j < len(p.OutputColumnUniqueIds); j++ {
				if func(tgt, src int32) bool {
					if tgt != src {
						return false
					}
					return true
				}(p.OutputColumnUniqueIds[i], p.OutputColumnUniqueIds[j]) {
					panic(fmt.Errorf("%T error writing set field: slice is not unique", p.OutputColumnUniqueIds[i]))
				}
			}
		}
		var tmpV int32
		l += bthrift.Binary.I32Length(int32(tmpV)) * len(p.OutputColumnUniqueIds)
		l += bthrift.Binary.SetEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapScanNode) field16Length() int {
	l := 0
	if p.IsSetDistributeColumnIds() {
		l += bthrift.Binary.FieldBeginLength("distribute_column_ids", thrift.LIST, 16)
		l += bthrift.Binary.ListBeginLength(thrift.I32, len(p.DistributeColumnIds))
		var tmpV int32
		l += bthrift.Binary.I32Length(int32(tmpV)) * len(p.DistributeColumnIds)
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapScanNode) field17Length() int {
	l := 0
	if p.IsSetSchemaVersion() {
		l += bthrift.Binary.FieldBeginLength("schema_version", thrift.I32, 17)
		l += bthrift.Binary.I32Length(*p.SchemaVersion)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapScanNode) field18Length() int {
	l := 0
	if p.IsSetTopnFilterSourceNodeIds() {
		l += bthrift.Binary.FieldBeginLength("topn_filter_source_node_ids", thrift.LIST, 18)
		l += bthrift.Binary.ListBeginLength(thrift.I32, len(p.TopnFilterSourceNodeIds))
		var tmpV int32
		l += bthrift.Binary.I32Length(int32(tmpV)) * len(p.TopnFilterSourceNodeIds)
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TEqJoinCondition) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetLeft bool = false
	var issetRight bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetLeft = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetRight = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetLeft {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetRight {
		fieldId = 2
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TEqJoinCondition[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TEqJoinCondition[fieldId]))
}

func (p *TEqJoinCondition) FastReadField1(buf []byte) (int, error) {
	offset := 0

	tmp := exprs.NewTExpr()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.Left = tmp
	return offset, nil
}

func (p *TEqJoinCondition) FastReadField2(buf []byte) (int, error) {
	offset := 0

	tmp := exprs.NewTExpr()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.Right = tmp
	return offset, nil
}

func (p *TEqJoinCondition) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := opcodes.TExprOpcode(v)
		p.Opcode = &tmp

	}
	return offset, nil
}

// for compatibility
func (p *TEqJoinCondition) FastWrite(buf []byte) int {
	return 0
}

func (p *TEqJoinCondition) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TEqJoinCondition")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TEqJoinCondition) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TEqJoinCondition")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TEqJoinCondition) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "left", thrift.STRUCT, 1)
	offset += p.Left.FastWriteNocopy(buf[offset:], binaryWriter)
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TEqJoinCondition) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "right", thrift.STRUCT, 2)
	offset += p.Right.FastWriteNocopy(buf[offset:], binaryWriter)
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TEqJoinCondition) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetOpcode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "opcode", thrift.I32, 3)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.Opcode))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TEqJoinCondition) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("left", thrift.STRUCT, 1)
	l += p.Left.BLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TEqJoinCondition) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("right", thrift.STRUCT, 2)
	l += p.Right.BLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TEqJoinCondition) field3Length() int {
	l := 0
	if p.IsSetOpcode() {
		l += bthrift.Binary.FieldBeginLength("opcode", thrift.I32, 3)
		l += bthrift.Binary.I32Length(int32(*p.Opcode))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THashJoinNode) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetJoinOp bool = false
	var issetEqJoinConjuncts bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetJoinOp = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetEqJoinConjuncts = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField9(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 11:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField11(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 12:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField12(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 13:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField13(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 14:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField14(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetJoinOp {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetEqJoinConjuncts {
		fieldId = 2
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_THashJoinNode[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_THashJoinNode[fieldId]))
}

func (p *THashJoinNode) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.JoinOp = TJoinOp(v)

	}
	return offset, nil
}

func (p *THashJoinNode) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.EqJoinConjuncts = make([]*TEqJoinCondition, 0, size)
	for i := 0; i < size; i++ {
		_elem := NewTEqJoinCondition()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.EqJoinConjuncts = append(p.EqJoinConjuncts, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *THashJoinNode) FastReadField3(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.OtherJoinConjuncts = make([]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_elem := exprs.NewTExpr()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.OtherJoinConjuncts = append(p.OtherJoinConjuncts, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *THashJoinNode) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.AddProbeFilters = &v

	}
	return offset, nil
}

func (p *THashJoinNode) FastReadField5(buf []byte) (int, error) {
	offset := 0

	tmp := exprs.NewTExpr()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.VotherJoinConjunct = tmp
	return offset, nil
}

func (p *THashJoinNode) FastReadField6(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.HashOutputSlotIds = make([]types.TSlotId, 0, size)
	for i := 0; i < size; i++ {
		var _elem types.TSlotId
		if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.HashOutputSlotIds = append(p.HashOutputSlotIds, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *THashJoinNode) FastReadField7(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.SrcExprList = make([]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_elem := exprs.NewTExpr()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.SrcExprList = append(p.SrcExprList, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *THashJoinNode) FastReadField8(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.VoutputTupleId = &v

	}
	return offset, nil
}

func (p *THashJoinNode) FastReadField9(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.VintermediateTupleIdList = make([]types.TTupleId, 0, size)
	for i := 0; i < size; i++ {
		var _elem types.TTupleId
		if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.VintermediateTupleIdList = append(p.VintermediateTupleIdList, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *THashJoinNode) FastReadField10(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.IsBroadcastJoin = &v

	}
	return offset, nil
}

func (p *THashJoinNode) FastReadField11(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.IsMark = &v

	}
	return offset, nil
}

func (p *THashJoinNode) FastReadField12(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := TJoinDistributionType(v)
		p.DistType = &tmp

	}
	return offset, nil
}

func (p *THashJoinNode) FastReadField13(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.MarkJoinConjuncts = make([]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_elem := exprs.NewTExpr()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.MarkJoinConjuncts = append(p.MarkJoinConjuncts, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *THashJoinNode) FastReadField14(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.UseSpecificProjections = &v

	}
	return offset, nil
}

// for compatibility
func (p *THashJoinNode) FastWrite(buf []byte) int {
	return 0
}

func (p *THashJoinNode) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "THashJoinNode")
	if p != nil {
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
		offset += p.fastWriteField10(buf[offset:], binaryWriter)
		offset += p.fastWriteField11(buf[offset:], binaryWriter)
		offset += p.fastWriteField14(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField9(buf[offset:], binaryWriter)
		offset += p.fastWriteField12(buf[offset:], binaryWriter)
		offset += p.fastWriteField13(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *THashJoinNode) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("THashJoinNode")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field9Length()
		l += p.field10Length()
		l += p.field11Length()
		l += p.field12Length()
		l += p.field13Length()
		l += p.field14Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *THashJoinNode) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "join_op", thrift.I32, 1)
	offset += bthrift.Binary.WriteI32(buf[offset:], int32(p.JoinOp))

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *THashJoinNode) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "eq_join_conjuncts", thrift.LIST, 2)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
	var length int
	for _, v := range p.EqJoinConjuncts {
		length++
		offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *THashJoinNode) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetOtherJoinConjuncts() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "other_join_conjuncts", thrift.LIST, 3)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.OtherJoinConjuncts {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THashJoinNode) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetAddProbeFilters() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "add_probe_filters", thrift.BOOL, 4)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.AddProbeFilters)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THashJoinNode) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetVotherJoinConjunct() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "vother_join_conjunct", thrift.STRUCT, 5)
		offset += p.VotherJoinConjunct.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THashJoinNode) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetHashOutputSlotIds() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "hash_output_slot_ids", thrift.LIST, 6)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.I32, 0)
		var length int
		for _, v := range p.HashOutputSlotIds {
			length++
			offset += bthrift.Binary.WriteI32(buf[offset:], v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.I32, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THashJoinNode) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSrcExprList() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "srcExprList", thrift.LIST, 7)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.SrcExprList {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THashJoinNode) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetVoutputTupleId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "voutput_tuple_id", thrift.I32, 8)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.VoutputTupleId)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THashJoinNode) fastWriteField9(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetVintermediateTupleIdList() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "vintermediate_tuple_id_list", thrift.LIST, 9)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.I32, 0)
		var length int
		for _, v := range p.VintermediateTupleIdList {
			length++
			offset += bthrift.Binary.WriteI32(buf[offset:], v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.I32, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THashJoinNode) fastWriteField10(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIsBroadcastJoin() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "is_broadcast_join", thrift.BOOL, 10)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.IsBroadcastJoin)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THashJoinNode) fastWriteField11(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIsMark() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "is_mark", thrift.BOOL, 11)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.IsMark)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THashJoinNode) fastWriteField12(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDistType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "dist_type", thrift.I32, 12)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.DistType))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THashJoinNode) fastWriteField13(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetMarkJoinConjuncts() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "mark_join_conjuncts", thrift.LIST, 13)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.MarkJoinConjuncts {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THashJoinNode) fastWriteField14(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetUseSpecificProjections() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "use_specific_projections", thrift.BOOL, 14)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.UseSpecificProjections)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *THashJoinNode) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("join_op", thrift.I32, 1)
	l += bthrift.Binary.I32Length(int32(p.JoinOp))

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *THashJoinNode) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("eq_join_conjuncts", thrift.LIST, 2)
	l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.EqJoinConjuncts))
	for _, v := range p.EqJoinConjuncts {
		l += v.BLength()
	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *THashJoinNode) field3Length() int {
	l := 0
	if p.IsSetOtherJoinConjuncts() {
		l += bthrift.Binary.FieldBeginLength("other_join_conjuncts", thrift.LIST, 3)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.OtherJoinConjuncts))
		for _, v := range p.OtherJoinConjuncts {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THashJoinNode) field4Length() int {
	l := 0
	if p.IsSetAddProbeFilters() {
		l += bthrift.Binary.FieldBeginLength("add_probe_filters", thrift.BOOL, 4)
		l += bthrift.Binary.BoolLength(*p.AddProbeFilters)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THashJoinNode) field5Length() int {
	l := 0
	if p.IsSetVotherJoinConjunct() {
		l += bthrift.Binary.FieldBeginLength("vother_join_conjunct", thrift.STRUCT, 5)
		l += p.VotherJoinConjunct.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THashJoinNode) field6Length() int {
	l := 0
	if p.IsSetHashOutputSlotIds() {
		l += bthrift.Binary.FieldBeginLength("hash_output_slot_ids", thrift.LIST, 6)
		l += bthrift.Binary.ListBeginLength(thrift.I32, len(p.HashOutputSlotIds))
		var tmpV types.TSlotId
		l += bthrift.Binary.I32Length(int32(tmpV)) * len(p.HashOutputSlotIds)
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THashJoinNode) field7Length() int {
	l := 0
	if p.IsSetSrcExprList() {
		l += bthrift.Binary.FieldBeginLength("srcExprList", thrift.LIST, 7)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.SrcExprList))
		for _, v := range p.SrcExprList {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THashJoinNode) field8Length() int {
	l := 0
	if p.IsSetVoutputTupleId() {
		l += bthrift.Binary.FieldBeginLength("voutput_tuple_id", thrift.I32, 8)
		l += bthrift.Binary.I32Length(*p.VoutputTupleId)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THashJoinNode) field9Length() int {
	l := 0
	if p.IsSetVintermediateTupleIdList() {
		l += bthrift.Binary.FieldBeginLength("vintermediate_tuple_id_list", thrift.LIST, 9)
		l += bthrift.Binary.ListBeginLength(thrift.I32, len(p.VintermediateTupleIdList))
		var tmpV types.TTupleId
		l += bthrift.Binary.I32Length(int32(tmpV)) * len(p.VintermediateTupleIdList)
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THashJoinNode) field10Length() int {
	l := 0
	if p.IsSetIsBroadcastJoin() {
		l += bthrift.Binary.FieldBeginLength("is_broadcast_join", thrift.BOOL, 10)
		l += bthrift.Binary.BoolLength(*p.IsBroadcastJoin)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THashJoinNode) field11Length() int {
	l := 0
	if p.IsSetIsMark() {
		l += bthrift.Binary.FieldBeginLength("is_mark", thrift.BOOL, 11)
		l += bthrift.Binary.BoolLength(*p.IsMark)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THashJoinNode) field12Length() int {
	l := 0
	if p.IsSetDistType() {
		l += bthrift.Binary.FieldBeginLength("dist_type", thrift.I32, 12)
		l += bthrift.Binary.I32Length(int32(*p.DistType))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THashJoinNode) field13Length() int {
	l := 0
	if p.IsSetMarkJoinConjuncts() {
		l += bthrift.Binary.FieldBeginLength("mark_join_conjuncts", thrift.LIST, 13)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.MarkJoinConjuncts))
		for _, v := range p.MarkJoinConjuncts {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *THashJoinNode) field14Length() int {
	l := 0
	if p.IsSetUseSpecificProjections() {
		l += bthrift.Binary.FieldBeginLength("use_specific_projections", thrift.BOOL, 14)
		l += bthrift.Binary.BoolLength(*p.UseSpecificProjections)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TNestedLoopJoinNode) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetJoinOp bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetJoinOp = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField9(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetJoinOp {
		fieldId = 1
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TNestedLoopJoinNode[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TNestedLoopJoinNode[fieldId]))
}

func (p *TNestedLoopJoinNode) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.JoinOp = TJoinOp(v)

	}
	return offset, nil
}

func (p *TNestedLoopJoinNode) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.SrcExprList = make([]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_elem := exprs.NewTExpr()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.SrcExprList = append(p.SrcExprList, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TNestedLoopJoinNode) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.VoutputTupleId = &v

	}
	return offset, nil
}

func (p *TNestedLoopJoinNode) FastReadField4(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.VintermediateTupleIdList = make([]types.TTupleId, 0, size)
	for i := 0; i < size; i++ {
		var _elem types.TTupleId
		if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.VintermediateTupleIdList = append(p.VintermediateTupleIdList, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TNestedLoopJoinNode) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.IsOutputLeftSideOnly = &v

	}
	return offset, nil
}

func (p *TNestedLoopJoinNode) FastReadField6(buf []byte) (int, error) {
	offset := 0

	tmp := exprs.NewTExpr()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.VjoinConjunct = tmp
	return offset, nil
}

func (p *TNestedLoopJoinNode) FastReadField7(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.IsMark = &v

	}
	return offset, nil
}

func (p *TNestedLoopJoinNode) FastReadField8(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.JoinConjuncts = make([]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_elem := exprs.NewTExpr()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.JoinConjuncts = append(p.JoinConjuncts, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TNestedLoopJoinNode) FastReadField9(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.MarkJoinConjuncts = make([]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_elem := exprs.NewTExpr()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.MarkJoinConjuncts = append(p.MarkJoinConjuncts, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TNestedLoopJoinNode) FastReadField10(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.UseSpecificProjections = &v

	}
	return offset, nil
}

// for compatibility
func (p *TNestedLoopJoinNode) FastWrite(buf []byte) int {
	return 0
}

func (p *TNestedLoopJoinNode) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TNestedLoopJoinNode")
	if p != nil {
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField10(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
		offset += p.fastWriteField9(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TNestedLoopJoinNode) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TNestedLoopJoinNode")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field9Length()
		l += p.field10Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TNestedLoopJoinNode) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "join_op", thrift.I32, 1)
	offset += bthrift.Binary.WriteI32(buf[offset:], int32(p.JoinOp))

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TNestedLoopJoinNode) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSrcExprList() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "srcExprList", thrift.LIST, 2)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.SrcExprList {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TNestedLoopJoinNode) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetVoutputTupleId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "voutput_tuple_id", thrift.I32, 3)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.VoutputTupleId)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TNestedLoopJoinNode) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetVintermediateTupleIdList() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "vintermediate_tuple_id_list", thrift.LIST, 4)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.I32, 0)
		var length int
		for _, v := range p.VintermediateTupleIdList {
			length++
			offset += bthrift.Binary.WriteI32(buf[offset:], v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.I32, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TNestedLoopJoinNode) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIsOutputLeftSideOnly() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "is_output_left_side_only", thrift.BOOL, 5)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.IsOutputLeftSideOnly)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TNestedLoopJoinNode) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetVjoinConjunct() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "vjoin_conjunct", thrift.STRUCT, 6)
		offset += p.VjoinConjunct.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TNestedLoopJoinNode) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIsMark() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "is_mark", thrift.BOOL, 7)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.IsMark)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TNestedLoopJoinNode) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetJoinConjuncts() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "join_conjuncts", thrift.LIST, 8)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.JoinConjuncts {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TNestedLoopJoinNode) fastWriteField9(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetMarkJoinConjuncts() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "mark_join_conjuncts", thrift.LIST, 9)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.MarkJoinConjuncts {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TNestedLoopJoinNode) fastWriteField10(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetUseSpecificProjections() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "use_specific_projections", thrift.BOOL, 10)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.UseSpecificProjections)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TNestedLoopJoinNode) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("join_op", thrift.I32, 1)
	l += bthrift.Binary.I32Length(int32(p.JoinOp))

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TNestedLoopJoinNode) field2Length() int {
	l := 0
	if p.IsSetSrcExprList() {
		l += bthrift.Binary.FieldBeginLength("srcExprList", thrift.LIST, 2)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.SrcExprList))
		for _, v := range p.SrcExprList {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TNestedLoopJoinNode) field3Length() int {
	l := 0
	if p.IsSetVoutputTupleId() {
		l += bthrift.Binary.FieldBeginLength("voutput_tuple_id", thrift.I32, 3)
		l += bthrift.Binary.I32Length(*p.VoutputTupleId)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TNestedLoopJoinNode) field4Length() int {
	l := 0
	if p.IsSetVintermediateTupleIdList() {
		l += bthrift.Binary.FieldBeginLength("vintermediate_tuple_id_list", thrift.LIST, 4)
		l += bthrift.Binary.ListBeginLength(thrift.I32, len(p.VintermediateTupleIdList))
		var tmpV types.TTupleId
		l += bthrift.Binary.I32Length(int32(tmpV)) * len(p.VintermediateTupleIdList)
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TNestedLoopJoinNode) field5Length() int {
	l := 0
	if p.IsSetIsOutputLeftSideOnly() {
		l += bthrift.Binary.FieldBeginLength("is_output_left_side_only", thrift.BOOL, 5)
		l += bthrift.Binary.BoolLength(*p.IsOutputLeftSideOnly)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TNestedLoopJoinNode) field6Length() int {
	l := 0
	if p.IsSetVjoinConjunct() {
		l += bthrift.Binary.FieldBeginLength("vjoin_conjunct", thrift.STRUCT, 6)
		l += p.VjoinConjunct.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TNestedLoopJoinNode) field7Length() int {
	l := 0
	if p.IsSetIsMark() {
		l += bthrift.Binary.FieldBeginLength("is_mark", thrift.BOOL, 7)
		l += bthrift.Binary.BoolLength(*p.IsMark)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TNestedLoopJoinNode) field8Length() int {
	l := 0
	if p.IsSetJoinConjuncts() {
		l += bthrift.Binary.FieldBeginLength("join_conjuncts", thrift.LIST, 8)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.JoinConjuncts))
		for _, v := range p.JoinConjuncts {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TNestedLoopJoinNode) field9Length() int {
	l := 0
	if p.IsSetMarkJoinConjuncts() {
		l += bthrift.Binary.FieldBeginLength("mark_join_conjuncts", thrift.LIST, 9)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.MarkJoinConjuncts))
		for _, v := range p.MarkJoinConjuncts {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TNestedLoopJoinNode) field10Length() int {
	l := 0
	if p.IsSetUseSpecificProjections() {
		l += bthrift.Binary.FieldBeginLength("use_specific_projections", thrift.BOOL, 10)
		l += bthrift.Binary.BoolLength(*p.UseSpecificProjections)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TMergeJoinNode) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetCmpConjuncts bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetCmpConjuncts = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetCmpConjuncts {
		fieldId = 1
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TMergeJoinNode[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TMergeJoinNode[fieldId]))
}

func (p *TMergeJoinNode) FastReadField1(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.CmpConjuncts = make([]*TEqJoinCondition, 0, size)
	for i := 0; i < size; i++ {
		_elem := NewTEqJoinCondition()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.CmpConjuncts = append(p.CmpConjuncts, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TMergeJoinNode) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.OtherJoinConjuncts = make([]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_elem := exprs.NewTExpr()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.OtherJoinConjuncts = append(p.OtherJoinConjuncts, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

// for compatibility
func (p *TMergeJoinNode) FastWrite(buf []byte) int {
	return 0
}

func (p *TMergeJoinNode) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TMergeJoinNode")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TMergeJoinNode) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TMergeJoinNode")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TMergeJoinNode) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "cmp_conjuncts", thrift.LIST, 1)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
	var length int
	for _, v := range p.CmpConjuncts {
		length++
		offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TMergeJoinNode) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetOtherJoinConjuncts() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "other_join_conjuncts", thrift.LIST, 2)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.OtherJoinConjuncts {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TMergeJoinNode) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("cmp_conjuncts", thrift.LIST, 1)
	l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.CmpConjuncts))
	for _, v := range p.CmpConjuncts {
		l += v.BLength()
	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TMergeJoinNode) field2Length() int {
	l := 0
	if p.IsSetOtherJoinConjuncts() {
		l += bthrift.Binary.FieldBeginLength("other_join_conjuncts", thrift.LIST, 2)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.OtherJoinConjuncts))
		for _, v := range p.OtherJoinConjuncts {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TAggregationNode) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetAggregateFunctions bool = false
	var issetIntermediateTupleId bool = false
	var issetOutputTupleId bool = false
	var issetNeedFinalize bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetAggregateFunctions = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetIntermediateTupleId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetOutputTupleId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetNeedFinalize = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField9(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetAggregateFunctions {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetIntermediateTupleId {
		fieldId = 3
		goto RequiredFieldNotSetError
	}

	if !issetOutputTupleId {
		fieldId = 4
		goto RequiredFieldNotSetError
	}

	if !issetNeedFinalize {
		fieldId = 5
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TAggregationNode[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TAggregationNode[fieldId]))
}

func (p *TAggregationNode) FastReadField1(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.GroupingExprs = make([]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_elem := exprs.NewTExpr()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.GroupingExprs = append(p.GroupingExprs, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TAggregationNode) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.AggregateFunctions = make([]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_elem := exprs.NewTExpr()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.AggregateFunctions = append(p.AggregateFunctions, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TAggregationNode) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.IntermediateTupleId = v

	}
	return offset, nil
}

func (p *TAggregationNode) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.OutputTupleId = v

	}
	return offset, nil
}

func (p *TAggregationNode) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.NeedFinalize = v

	}
	return offset, nil
}

func (p *TAggregationNode) FastReadField6(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.UseStreamingPreaggregation = &v

	}
	return offset, nil
}

func (p *TAggregationNode) FastReadField7(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.AggSortInfos = make([]*TSortInfo, 0, size)
	for i := 0; i < size; i++ {
		_elem := NewTSortInfo()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.AggSortInfos = append(p.AggSortInfos, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TAggregationNode) FastReadField8(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.IsFirstPhase = &v

	}
	return offset, nil
}

func (p *TAggregationNode) FastReadField9(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.IsColocate = &v

	}
	return offset, nil
}

func (p *TAggregationNode) FastReadField10(buf []byte) (int, error) {
	offset := 0

	tmp := NewTSortInfo()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.AggSortInfoByGroupKey = tmp
	return offset, nil
}

// for compatibility
func (p *TAggregationNode) FastWrite(buf []byte) int {
	return 0
}

func (p *TAggregationNode) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TAggregationNode")
	if p != nil {
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
		offset += p.fastWriteField9(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField10(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TAggregationNode) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TAggregationNode")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field9Length()
		l += p.field10Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TAggregationNode) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetGroupingExprs() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "grouping_exprs", thrift.LIST, 1)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.GroupingExprs {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TAggregationNode) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "aggregate_functions", thrift.LIST, 2)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
	var length int
	for _, v := range p.AggregateFunctions {
		length++
		offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TAggregationNode) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "intermediate_tuple_id", thrift.I32, 3)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.IntermediateTupleId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TAggregationNode) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "output_tuple_id", thrift.I32, 4)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.OutputTupleId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TAggregationNode) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "need_finalize", thrift.BOOL, 5)
	offset += bthrift.Binary.WriteBool(buf[offset:], p.NeedFinalize)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TAggregationNode) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetUseStreamingPreaggregation() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "use_streaming_preaggregation", thrift.BOOL, 6)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.UseStreamingPreaggregation)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TAggregationNode) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetAggSortInfos() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "agg_sort_infos", thrift.LIST, 7)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.AggSortInfos {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TAggregationNode) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIsFirstPhase() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "is_first_phase", thrift.BOOL, 8)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.IsFirstPhase)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TAggregationNode) fastWriteField9(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIsColocate() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "is_colocate", thrift.BOOL, 9)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.IsColocate)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TAggregationNode) fastWriteField10(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetAggSortInfoByGroupKey() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "agg_sort_info_by_group_key", thrift.STRUCT, 10)
		offset += p.AggSortInfoByGroupKey.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TAggregationNode) field1Length() int {
	l := 0
	if p.IsSetGroupingExprs() {
		l += bthrift.Binary.FieldBeginLength("grouping_exprs", thrift.LIST, 1)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.GroupingExprs))
		for _, v := range p.GroupingExprs {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TAggregationNode) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("aggregate_functions", thrift.LIST, 2)
	l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.AggregateFunctions))
	for _, v := range p.AggregateFunctions {
		l += v.BLength()
	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TAggregationNode) field3Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("intermediate_tuple_id", thrift.I32, 3)
	l += bthrift.Binary.I32Length(p.IntermediateTupleId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TAggregationNode) field4Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("output_tuple_id", thrift.I32, 4)
	l += bthrift.Binary.I32Length(p.OutputTupleId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TAggregationNode) field5Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("need_finalize", thrift.BOOL, 5)
	l += bthrift.Binary.BoolLength(p.NeedFinalize)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TAggregationNode) field6Length() int {
	l := 0
	if p.IsSetUseStreamingPreaggregation() {
		l += bthrift.Binary.FieldBeginLength("use_streaming_preaggregation", thrift.BOOL, 6)
		l += bthrift.Binary.BoolLength(*p.UseStreamingPreaggregation)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TAggregationNode) field7Length() int {
	l := 0
	if p.IsSetAggSortInfos() {
		l += bthrift.Binary.FieldBeginLength("agg_sort_infos", thrift.LIST, 7)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.AggSortInfos))
		for _, v := range p.AggSortInfos {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TAggregationNode) field8Length() int {
	l := 0
	if p.IsSetIsFirstPhase() {
		l += bthrift.Binary.FieldBeginLength("is_first_phase", thrift.BOOL, 8)
		l += bthrift.Binary.BoolLength(*p.IsFirstPhase)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TAggregationNode) field9Length() int {
	l := 0
	if p.IsSetIsColocate() {
		l += bthrift.Binary.FieldBeginLength("is_colocate", thrift.BOOL, 9)
		l += bthrift.Binary.BoolLength(*p.IsColocate)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TAggregationNode) field10Length() int {
	l := 0
	if p.IsSetAggSortInfoByGroupKey() {
		l += bthrift.Binary.FieldBeginLength("agg_sort_info_by_group_key", thrift.STRUCT, 10)
		l += p.AggSortInfoByGroupKey.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TRepeatNode) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetOutputTupleId bool = false
	var issetSlotIdSetList bool = false
	var issetRepeatIdList bool = false
	var issetGroupingList bool = false
	var issetAllSlotIds bool = false
	var issetExprs bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetOutputTupleId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetSlotIdSetList = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetRepeatIdList = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetGroupingList = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.SET {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetAllSlotIds = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetExprs = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetOutputTupleId {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetSlotIdSetList {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetRepeatIdList {
		fieldId = 3
		goto RequiredFieldNotSetError
	}

	if !issetGroupingList {
		fieldId = 4
		goto RequiredFieldNotSetError
	}

	if !issetAllSlotIds {
		fieldId = 5
		goto RequiredFieldNotSetError
	}

	if !issetExprs {
		fieldId = 6
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TRepeatNode[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TRepeatNode[fieldId]))
}

func (p *TRepeatNode) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.OutputTupleId = v

	}
	return offset, nil
}

func (p *TRepeatNode) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.SlotIdSetList = make([][]types.TSlotId, 0, size)
	for i := 0; i < size; i++ {
		_, size, l, err := bthrift.Binary.ReadSetBegin(buf[offset:])
		offset += l
		if err != nil {
			return offset, err
		}
		_elem := make([]types.TSlotId, 0, size)
		for i := 0; i < size; i++ {
			var _elem1 types.TSlotId
			if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
				return offset, err
			} else {
				offset += l

				_elem1 = v

			}

			_elem = append(_elem, _elem1)
		}
		if l, err := bthrift.Binary.ReadSetEnd(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.SlotIdSetList = append(p.SlotIdSetList, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TRepeatNode) FastReadField3(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.RepeatIdList = make([]int64, 0, size)
	for i := 0; i < size; i++ {
		var _elem int64
		if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.RepeatIdList = append(p.RepeatIdList, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TRepeatNode) FastReadField4(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.GroupingList = make([][]int64, 0, size)
	for i := 0; i < size; i++ {
		_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
		offset += l
		if err != nil {
			return offset, err
		}
		_elem := make([]int64, 0, size)
		for i := 0; i < size; i++ {
			var _elem1 int64
			if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
				return offset, err
			} else {
				offset += l

				_elem1 = v

			}

			_elem = append(_elem, _elem1)
		}
		if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.GroupingList = append(p.GroupingList, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TRepeatNode) FastReadField5(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadSetBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.AllSlotIds = make([]types.TSlotId, 0, size)
	for i := 0; i < size; i++ {
		var _elem types.TSlotId
		if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.AllSlotIds = append(p.AllSlotIds, _elem)
	}
	if l, err := bthrift.Binary.ReadSetEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TRepeatNode) FastReadField6(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Exprs = make([]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_elem := exprs.NewTExpr()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.Exprs = append(p.Exprs, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

// for compatibility
func (p *TRepeatNode) FastWrite(buf []byte) int {
	return 0
}

func (p *TRepeatNode) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TRepeatNode")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TRepeatNode) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TRepeatNode")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TRepeatNode) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "output_tuple_id", thrift.I32, 1)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.OutputTupleId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TRepeatNode) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "slot_id_set_list", thrift.LIST, 2)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.SET, 0)
	var length int
	for _, v := range p.SlotIdSetList {
		length++
		setBeginOffset := offset
		offset += bthrift.Binary.SetBeginLength(thrift.I32, 0)

		for i := 0; i < len(v); i++ {
			for j := i + 1; j < len(v); j++ {
				if func(tgt, src types.TSlotId) bool {
					if tgt != src {
						return false
					}
					return true
				}(v[i], v[j]) {
					panic(fmt.Errorf("%T error writing set field: slice is not unique", v[i]))
				}
			}
		}
		var length int
		for _, v := range v {
			length++
			offset += bthrift.Binary.WriteI32(buf[offset:], v)

		}
		bthrift.Binary.WriteSetBegin(buf[setBeginOffset:], thrift.I32, length)
		offset += bthrift.Binary.WriteSetEnd(buf[offset:])
	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.SET, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TRepeatNode) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "repeat_id_list", thrift.LIST, 3)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.I64, 0)
	var length int
	for _, v := range p.RepeatIdList {
		length++
		offset += bthrift.Binary.WriteI64(buf[offset:], v)

	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.I64, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TRepeatNode) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "grouping_list", thrift.LIST, 4)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.LIST, 0)
	var length int
	for _, v := range p.GroupingList {
		length++
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.I64, 0)
		var length int
		for _, v := range v {
			length++
			offset += bthrift.Binary.WriteI64(buf[offset:], v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.I64, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.LIST, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TRepeatNode) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "all_slot_ids", thrift.SET, 5)
	setBeginOffset := offset
	offset += bthrift.Binary.SetBeginLength(thrift.I32, 0)

	for i := 0; i < len(p.AllSlotIds); i++ {
		for j := i + 1; j < len(p.AllSlotIds); j++ {
			if func(tgt, src types.TSlotId) bool {
				if tgt != src {
					return false
				}
				return true
			}(p.AllSlotIds[i], p.AllSlotIds[j]) {
				panic(fmt.Errorf("%T error writing set field: slice is not unique", p.AllSlotIds[i]))
			}
		}
	}
	var length int
	for _, v := range p.AllSlotIds {
		length++
		offset += bthrift.Binary.WriteI32(buf[offset:], v)

	}
	bthrift.Binary.WriteSetBegin(buf[setBeginOffset:], thrift.I32, length)
	offset += bthrift.Binary.WriteSetEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TRepeatNode) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "exprs", thrift.LIST, 6)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
	var length int
	for _, v := range p.Exprs {
		length++
		offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TRepeatNode) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("output_tuple_id", thrift.I32, 1)
	l += bthrift.Binary.I32Length(p.OutputTupleId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TRepeatNode) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("slot_id_set_list", thrift.LIST, 2)
	l += bthrift.Binary.ListBeginLength(thrift.SET, len(p.SlotIdSetList))
	for _, v := range p.SlotIdSetList {
		l += bthrift.Binary.SetBeginLength(thrift.I32, len(v))

		for i := 0; i < len(v); i++ {
			for j := i + 1; j < len(v); j++ {
				if func(tgt, src types.TSlotId) bool {
					if tgt != src {
						return false
					}
					return true
				}(v[i], v[j]) {
					panic(fmt.Errorf("%T error writing set field: slice is not unique", v[i]))
				}
			}
		}
		var tmpV types.TSlotId
		l += bthrift.Binary.I32Length(int32(tmpV)) * len(v)
		l += bthrift.Binary.SetEndLength()
	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TRepeatNode) field3Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("repeat_id_list", thrift.LIST, 3)
	l += bthrift.Binary.ListBeginLength(thrift.I64, len(p.RepeatIdList))
	var tmpV int64
	l += bthrift.Binary.I64Length(int64(tmpV)) * len(p.RepeatIdList)
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TRepeatNode) field4Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("grouping_list", thrift.LIST, 4)
	l += bthrift.Binary.ListBeginLength(thrift.LIST, len(p.GroupingList))
	for _, v := range p.GroupingList {
		l += bthrift.Binary.ListBeginLength(thrift.I64, len(v))
		var tmpV int64
		l += bthrift.Binary.I64Length(int64(tmpV)) * len(v)
		l += bthrift.Binary.ListEndLength()
	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TRepeatNode) field5Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("all_slot_ids", thrift.SET, 5)
	l += bthrift.Binary.SetBeginLength(thrift.I32, len(p.AllSlotIds))

	for i := 0; i < len(p.AllSlotIds); i++ {
		for j := i + 1; j < len(p.AllSlotIds); j++ {
			if func(tgt, src types.TSlotId) bool {
				if tgt != src {
					return false
				}
				return true
			}(p.AllSlotIds[i], p.AllSlotIds[j]) {
				panic(fmt.Errorf("%T error writing set field: slice is not unique", p.AllSlotIds[i]))
			}
		}
	}
	var tmpV types.TSlotId
	l += bthrift.Binary.I32Length(int32(tmpV)) * len(p.AllSlotIds)
	l += bthrift.Binary.SetEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TRepeatNode) field6Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("exprs", thrift.LIST, 6)
	l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.Exprs))
	for _, v := range p.Exprs {
		l += v.BLength()
	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TPreAggregationNode) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetGroupExprs bool = false
	var issetAggregateExprs bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetGroupExprs = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetAggregateExprs = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetGroupExprs {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetAggregateExprs {
		fieldId = 2
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TPreAggregationNode[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TPreAggregationNode[fieldId]))
}

func (p *TPreAggregationNode) FastReadField1(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.GroupExprs = make([]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_elem := exprs.NewTExpr()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.GroupExprs = append(p.GroupExprs, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TPreAggregationNode) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.AggregateExprs = make([]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_elem := exprs.NewTExpr()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.AggregateExprs = append(p.AggregateExprs, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

// for compatibility
func (p *TPreAggregationNode) FastWrite(buf []byte) int {
	return 0
}

func (p *TPreAggregationNode) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TPreAggregationNode")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TPreAggregationNode) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TPreAggregationNode")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TPreAggregationNode) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "group_exprs", thrift.LIST, 1)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
	var length int
	for _, v := range p.GroupExprs {
		length++
		offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TPreAggregationNode) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "aggregate_exprs", thrift.LIST, 2)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
	var length int
	for _, v := range p.AggregateExprs {
		length++
		offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TPreAggregationNode) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("group_exprs", thrift.LIST, 1)
	l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.GroupExprs))
	for _, v := range p.GroupExprs {
		l += v.BLength()
	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TPreAggregationNode) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("aggregate_exprs", thrift.LIST, 2)
	l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.AggregateExprs))
	for _, v := range p.AggregateExprs {
		l += v.BLength()
	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TSortNode) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetSortInfo bool = false
	var issetUseTopN bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetSortInfo = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetUseTopN = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField9(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 11:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField11(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetSortInfo {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetUseTopN {
		fieldId = 2
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TSortNode[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TSortNode[fieldId]))
}

func (p *TSortNode) FastReadField1(buf []byte) (int, error) {
	offset := 0

	tmp := NewTSortInfo()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.SortInfo = tmp
	return offset, nil
}

func (p *TSortNode) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.UseTopN = v

	}
	return offset, nil
}

func (p *TSortNode) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Offset = &v

	}
	return offset, nil
}

func (p *TSortNode) FastReadField6(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.IsDefaultLimit = &v

	}
	return offset, nil
}

func (p *TSortNode) FastReadField7(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.UseTopnOpt = &v

	}
	return offset, nil
}

func (p *TSortNode) FastReadField8(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.MergeByExchange = &v

	}
	return offset, nil
}

func (p *TSortNode) FastReadField9(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.IsAnalyticSort = &v

	}
	return offset, nil
}

func (p *TSortNode) FastReadField10(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.IsColocate = &v

	}
	return offset, nil
}

func (p *TSortNode) FastReadField11(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := TSortAlgorithm(v)
		p.Algorithm = &tmp

	}
	return offset, nil
}

// for compatibility
func (p *TSortNode) FastWrite(buf []byte) int {
	return 0
}

func (p *TSortNode) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TSortNode")
	if p != nil {
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
		offset += p.fastWriteField9(buf[offset:], binaryWriter)
		offset += p.fastWriteField10(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField11(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TSortNode) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TSortNode")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field9Length()
		l += p.field10Length()
		l += p.field11Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TSortNode) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "sort_info", thrift.STRUCT, 1)
	offset += p.SortInfo.FastWriteNocopy(buf[offset:], binaryWriter)
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TSortNode) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "use_top_n", thrift.BOOL, 2)
	offset += bthrift.Binary.WriteBool(buf[offset:], p.UseTopN)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TSortNode) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetOffset() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "offset", thrift.I64, 3)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.Offset)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TSortNode) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIsDefaultLimit() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "is_default_limit", thrift.BOOL, 6)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.IsDefaultLimit)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TSortNode) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetUseTopnOpt() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "use_topn_opt", thrift.BOOL, 7)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.UseTopnOpt)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TSortNode) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetMergeByExchange() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "merge_by_exchange", thrift.BOOL, 8)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.MergeByExchange)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TSortNode) fastWriteField9(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIsAnalyticSort() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "is_analytic_sort", thrift.BOOL, 9)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.IsAnalyticSort)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TSortNode) fastWriteField10(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIsColocate() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "is_colocate", thrift.BOOL, 10)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.IsColocate)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TSortNode) fastWriteField11(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetAlgorithm() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "algorithm", thrift.I32, 11)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.Algorithm))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TSortNode) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("sort_info", thrift.STRUCT, 1)
	l += p.SortInfo.BLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TSortNode) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("use_top_n", thrift.BOOL, 2)
	l += bthrift.Binary.BoolLength(p.UseTopN)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TSortNode) field3Length() int {
	l := 0
	if p.IsSetOffset() {
		l += bthrift.Binary.FieldBeginLength("offset", thrift.I64, 3)
		l += bthrift.Binary.I64Length(*p.Offset)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TSortNode) field6Length() int {
	l := 0
	if p.IsSetIsDefaultLimit() {
		l += bthrift.Binary.FieldBeginLength("is_default_limit", thrift.BOOL, 6)
		l += bthrift.Binary.BoolLength(*p.IsDefaultLimit)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TSortNode) field7Length() int {
	l := 0
	if p.IsSetUseTopnOpt() {
		l += bthrift.Binary.FieldBeginLength("use_topn_opt", thrift.BOOL, 7)
		l += bthrift.Binary.BoolLength(*p.UseTopnOpt)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TSortNode) field8Length() int {
	l := 0
	if p.IsSetMergeByExchange() {
		l += bthrift.Binary.FieldBeginLength("merge_by_exchange", thrift.BOOL, 8)
		l += bthrift.Binary.BoolLength(*p.MergeByExchange)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TSortNode) field9Length() int {
	l := 0
	if p.IsSetIsAnalyticSort() {
		l += bthrift.Binary.FieldBeginLength("is_analytic_sort", thrift.BOOL, 9)
		l += bthrift.Binary.BoolLength(*p.IsAnalyticSort)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TSortNode) field10Length() int {
	l := 0
	if p.IsSetIsColocate() {
		l += bthrift.Binary.FieldBeginLength("is_colocate", thrift.BOOL, 10)
		l += bthrift.Binary.BoolLength(*p.IsColocate)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TSortNode) field11Length() int {
	l := 0
	if p.IsSetAlgorithm() {
		l += bthrift.Binary.FieldBeginLength("algorithm", thrift.I32, 11)
		l += bthrift.Binary.I32Length(int32(*p.Algorithm))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPartitionSortNode) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TPartitionSortNode[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TPartitionSortNode) FastReadField1(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.PartitionExprs = make([]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_elem := exprs.NewTExpr()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.PartitionExprs = append(p.PartitionExprs, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TPartitionSortNode) FastReadField2(buf []byte) (int, error) {
	offset := 0

	tmp := NewTSortInfo()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.SortInfo = tmp
	return offset, nil
}

func (p *TPartitionSortNode) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.HasGlobalLimit = &v

	}
	return offset, nil
}

func (p *TPartitionSortNode) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := TopNAlgorithm(v)
		p.TopNAlgorithm = &tmp

	}
	return offset, nil
}

func (p *TPartitionSortNode) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.PartitionInnerLimit = &v

	}
	return offset, nil
}

func (p *TPartitionSortNode) FastReadField6(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := TPartTopNPhase(v)
		p.PtopnPhase = &tmp

	}
	return offset, nil
}

// for compatibility
func (p *TPartitionSortNode) FastWrite(buf []byte) int {
	return 0
}

func (p *TPartitionSortNode) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TPartitionSortNode")
	if p != nil {
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TPartitionSortNode) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TPartitionSortNode")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TPartitionSortNode) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPartitionExprs() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "partition_exprs", thrift.LIST, 1)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.PartitionExprs {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPartitionSortNode) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSortInfo() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "sort_info", thrift.STRUCT, 2)
		offset += p.SortInfo.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPartitionSortNode) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetHasGlobalLimit() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "has_global_limit", thrift.BOOL, 3)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.HasGlobalLimit)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPartitionSortNode) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTopNAlgorithm() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "top_n_algorithm", thrift.I32, 4)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.TopNAlgorithm))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPartitionSortNode) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPartitionInnerLimit() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "partition_inner_limit", thrift.I64, 5)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.PartitionInnerLimit)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPartitionSortNode) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPtopnPhase() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "ptopn_phase", thrift.I32, 6)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.PtopnPhase))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPartitionSortNode) field1Length() int {
	l := 0
	if p.IsSetPartitionExprs() {
		l += bthrift.Binary.FieldBeginLength("partition_exprs", thrift.LIST, 1)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.PartitionExprs))
		for _, v := range p.PartitionExprs {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPartitionSortNode) field2Length() int {
	l := 0
	if p.IsSetSortInfo() {
		l += bthrift.Binary.FieldBeginLength("sort_info", thrift.STRUCT, 2)
		l += p.SortInfo.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPartitionSortNode) field3Length() int {
	l := 0
	if p.IsSetHasGlobalLimit() {
		l += bthrift.Binary.FieldBeginLength("has_global_limit", thrift.BOOL, 3)
		l += bthrift.Binary.BoolLength(*p.HasGlobalLimit)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPartitionSortNode) field4Length() int {
	l := 0
	if p.IsSetTopNAlgorithm() {
		l += bthrift.Binary.FieldBeginLength("top_n_algorithm", thrift.I32, 4)
		l += bthrift.Binary.I32Length(int32(*p.TopNAlgorithm))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPartitionSortNode) field5Length() int {
	l := 0
	if p.IsSetPartitionInnerLimit() {
		l += bthrift.Binary.FieldBeginLength("partition_inner_limit", thrift.I64, 5)
		l += bthrift.Binary.I64Length(*p.PartitionInnerLimit)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPartitionSortNode) field6Length() int {
	l := 0
	if p.IsSetPtopnPhase() {
		l += bthrift.Binary.FieldBeginLength("ptopn_phase", thrift.I32, 6)
		l += bthrift.Binary.I32Length(int32(*p.PtopnPhase))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TAnalyticWindowBoundary) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetType bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetType = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetType {
		fieldId = 1
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TAnalyticWindowBoundary[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TAnalyticWindowBoundary[fieldId]))
}

func (p *TAnalyticWindowBoundary) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Type = TAnalyticWindowBoundaryType(v)

	}
	return offset, nil
}

func (p *TAnalyticWindowBoundary) FastReadField2(buf []byte) (int, error) {
	offset := 0

	tmp := exprs.NewTExpr()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.RangeOffsetPredicate = tmp
	return offset, nil
}

func (p *TAnalyticWindowBoundary) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.RowsOffsetValue = &v

	}
	return offset, nil
}

// for compatibility
func (p *TAnalyticWindowBoundary) FastWrite(buf []byte) int {
	return 0
}

func (p *TAnalyticWindowBoundary) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TAnalyticWindowBoundary")
	if p != nil {
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TAnalyticWindowBoundary) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TAnalyticWindowBoundary")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TAnalyticWindowBoundary) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "type", thrift.I32, 1)
	offset += bthrift.Binary.WriteI32(buf[offset:], int32(p.Type))

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TAnalyticWindowBoundary) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetRangeOffsetPredicate() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "range_offset_predicate", thrift.STRUCT, 2)
		offset += p.RangeOffsetPredicate.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TAnalyticWindowBoundary) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetRowsOffsetValue() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "rows_offset_value", thrift.I64, 3)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.RowsOffsetValue)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TAnalyticWindowBoundary) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("type", thrift.I32, 1)
	l += bthrift.Binary.I32Length(int32(p.Type))

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TAnalyticWindowBoundary) field2Length() int {
	l := 0
	if p.IsSetRangeOffsetPredicate() {
		l += bthrift.Binary.FieldBeginLength("range_offset_predicate", thrift.STRUCT, 2)
		l += p.RangeOffsetPredicate.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TAnalyticWindowBoundary) field3Length() int {
	l := 0
	if p.IsSetRowsOffsetValue() {
		l += bthrift.Binary.FieldBeginLength("rows_offset_value", thrift.I64, 3)
		l += bthrift.Binary.I64Length(*p.RowsOffsetValue)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TAnalyticWindow) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetType bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetType = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetType {
		fieldId = 1
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TAnalyticWindow[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TAnalyticWindow[fieldId]))
}

func (p *TAnalyticWindow) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Type = TAnalyticWindowType(v)

	}
	return offset, nil
}

func (p *TAnalyticWindow) FastReadField2(buf []byte) (int, error) {
	offset := 0

	tmp := NewTAnalyticWindowBoundary()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.WindowStart = tmp
	return offset, nil
}

func (p *TAnalyticWindow) FastReadField3(buf []byte) (int, error) {
	offset := 0

	tmp := NewTAnalyticWindowBoundary()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.WindowEnd = tmp
	return offset, nil
}

// for compatibility
func (p *TAnalyticWindow) FastWrite(buf []byte) int {
	return 0
}

func (p *TAnalyticWindow) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TAnalyticWindow")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TAnalyticWindow) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TAnalyticWindow")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TAnalyticWindow) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "type", thrift.I32, 1)
	offset += bthrift.Binary.WriteI32(buf[offset:], int32(p.Type))

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TAnalyticWindow) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetWindowStart() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "window_start", thrift.STRUCT, 2)
		offset += p.WindowStart.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TAnalyticWindow) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetWindowEnd() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "window_end", thrift.STRUCT, 3)
		offset += p.WindowEnd.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TAnalyticWindow) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("type", thrift.I32, 1)
	l += bthrift.Binary.I32Length(int32(p.Type))

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TAnalyticWindow) field2Length() int {
	l := 0
	if p.IsSetWindowStart() {
		l += bthrift.Binary.FieldBeginLength("window_start", thrift.STRUCT, 2)
		l += p.WindowStart.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TAnalyticWindow) field3Length() int {
	l := 0
	if p.IsSetWindowEnd() {
		l += bthrift.Binary.FieldBeginLength("window_end", thrift.STRUCT, 3)
		l += p.WindowEnd.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TAnalyticNode) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetPartitionExprs bool = false
	var issetOrderByExprs bool = false
	var issetAnalyticFunctions bool = false
	var issetIntermediateTupleId bool = false
	var issetOutputTupleId bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetPartitionExprs = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetOrderByExprs = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetAnalyticFunctions = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetIntermediateTupleId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetOutputTupleId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField9(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetPartitionExprs {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetOrderByExprs {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetAnalyticFunctions {
		fieldId = 3
		goto RequiredFieldNotSetError
	}

	if !issetIntermediateTupleId {
		fieldId = 5
		goto RequiredFieldNotSetError
	}

	if !issetOutputTupleId {
		fieldId = 6
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TAnalyticNode[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TAnalyticNode[fieldId]))
}

func (p *TAnalyticNode) FastReadField1(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.PartitionExprs = make([]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_elem := exprs.NewTExpr()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.PartitionExprs = append(p.PartitionExprs, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TAnalyticNode) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.OrderByExprs = make([]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_elem := exprs.NewTExpr()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.OrderByExprs = append(p.OrderByExprs, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TAnalyticNode) FastReadField3(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.AnalyticFunctions = make([]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_elem := exprs.NewTExpr()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.AnalyticFunctions = append(p.AnalyticFunctions, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TAnalyticNode) FastReadField4(buf []byte) (int, error) {
	offset := 0

	tmp := NewTAnalyticWindow()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.Window = tmp
	return offset, nil
}

func (p *TAnalyticNode) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.IntermediateTupleId = v

	}
	return offset, nil
}

func (p *TAnalyticNode) FastReadField6(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.OutputTupleId = v

	}
	return offset, nil
}

func (p *TAnalyticNode) FastReadField7(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.BufferedTupleId = &v

	}
	return offset, nil
}

func (p *TAnalyticNode) FastReadField8(buf []byte) (int, error) {
	offset := 0

	tmp := exprs.NewTExpr()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.PartitionByEq = tmp
	return offset, nil
}

func (p *TAnalyticNode) FastReadField9(buf []byte) (int, error) {
	offset := 0

	tmp := exprs.NewTExpr()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.OrderByEq = tmp
	return offset, nil
}

func (p *TAnalyticNode) FastReadField10(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.IsColocate = &v

	}
	return offset, nil
}

// for compatibility
func (p *TAnalyticNode) FastWrite(buf []byte) int {
	return 0
}

func (p *TAnalyticNode) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TAnalyticNode")
	if p != nil {
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField10(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
		offset += p.fastWriteField9(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TAnalyticNode) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TAnalyticNode")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field9Length()
		l += p.field10Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TAnalyticNode) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "partition_exprs", thrift.LIST, 1)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
	var length int
	for _, v := range p.PartitionExprs {
		length++
		offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TAnalyticNode) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "order_by_exprs", thrift.LIST, 2)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
	var length int
	for _, v := range p.OrderByExprs {
		length++
		offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TAnalyticNode) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "analytic_functions", thrift.LIST, 3)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
	var length int
	for _, v := range p.AnalyticFunctions {
		length++
		offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TAnalyticNode) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetWindow() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "window", thrift.STRUCT, 4)
		offset += p.Window.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TAnalyticNode) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "intermediate_tuple_id", thrift.I32, 5)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.IntermediateTupleId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TAnalyticNode) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "output_tuple_id", thrift.I32, 6)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.OutputTupleId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TAnalyticNode) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetBufferedTupleId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "buffered_tuple_id", thrift.I32, 7)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.BufferedTupleId)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TAnalyticNode) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPartitionByEq() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "partition_by_eq", thrift.STRUCT, 8)
		offset += p.PartitionByEq.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TAnalyticNode) fastWriteField9(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetOrderByEq() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "order_by_eq", thrift.STRUCT, 9)
		offset += p.OrderByEq.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TAnalyticNode) fastWriteField10(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIsColocate() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "is_colocate", thrift.BOOL, 10)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.IsColocate)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TAnalyticNode) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("partition_exprs", thrift.LIST, 1)
	l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.PartitionExprs))
	for _, v := range p.PartitionExprs {
		l += v.BLength()
	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TAnalyticNode) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("order_by_exprs", thrift.LIST, 2)
	l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.OrderByExprs))
	for _, v := range p.OrderByExprs {
		l += v.BLength()
	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TAnalyticNode) field3Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("analytic_functions", thrift.LIST, 3)
	l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.AnalyticFunctions))
	for _, v := range p.AnalyticFunctions {
		l += v.BLength()
	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TAnalyticNode) field4Length() int {
	l := 0
	if p.IsSetWindow() {
		l += bthrift.Binary.FieldBeginLength("window", thrift.STRUCT, 4)
		l += p.Window.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TAnalyticNode) field5Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("intermediate_tuple_id", thrift.I32, 5)
	l += bthrift.Binary.I32Length(p.IntermediateTupleId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TAnalyticNode) field6Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("output_tuple_id", thrift.I32, 6)
	l += bthrift.Binary.I32Length(p.OutputTupleId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TAnalyticNode) field7Length() int {
	l := 0
	if p.IsSetBufferedTupleId() {
		l += bthrift.Binary.FieldBeginLength("buffered_tuple_id", thrift.I32, 7)
		l += bthrift.Binary.I32Length(*p.BufferedTupleId)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TAnalyticNode) field8Length() int {
	l := 0
	if p.IsSetPartitionByEq() {
		l += bthrift.Binary.FieldBeginLength("partition_by_eq", thrift.STRUCT, 8)
		l += p.PartitionByEq.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TAnalyticNode) field9Length() int {
	l := 0
	if p.IsSetOrderByEq() {
		l += bthrift.Binary.FieldBeginLength("order_by_eq", thrift.STRUCT, 9)
		l += p.OrderByEq.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TAnalyticNode) field10Length() int {
	l := 0
	if p.IsSetIsColocate() {
		l += bthrift.Binary.FieldBeginLength("is_colocate", thrift.BOOL, 10)
		l += bthrift.Binary.BoolLength(*p.IsColocate)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TMergeNode) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetTupleId bool = false
	var issetResultExprLists bool = false
	var issetConstExprLists bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetTupleId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetResultExprLists = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetConstExprLists = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetTupleId {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetResultExprLists {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetConstExprLists {
		fieldId = 3
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TMergeNode[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TMergeNode[fieldId]))
}

func (p *TMergeNode) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.TupleId = v

	}
	return offset, nil
}

func (p *TMergeNode) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.ResultExprLists = make([][]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
		offset += l
		if err != nil {
			return offset, err
		}
		_elem := make([]*exprs.TExpr, 0, size)
		for i := 0; i < size; i++ {
			_elem1 := exprs.NewTExpr()
			if l, err := _elem1.FastRead(buf[offset:]); err != nil {
				return offset, err
			} else {
				offset += l
			}

			_elem = append(_elem, _elem1)
		}
		if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.ResultExprLists = append(p.ResultExprLists, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TMergeNode) FastReadField3(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.ConstExprLists = make([][]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
		offset += l
		if err != nil {
			return offset, err
		}
		_elem := make([]*exprs.TExpr, 0, size)
		for i := 0; i < size; i++ {
			_elem1 := exprs.NewTExpr()
			if l, err := _elem1.FastRead(buf[offset:]); err != nil {
				return offset, err
			} else {
				offset += l
			}

			_elem = append(_elem, _elem1)
		}
		if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.ConstExprLists = append(p.ConstExprLists, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

// for compatibility
func (p *TMergeNode) FastWrite(buf []byte) int {
	return 0
}

func (p *TMergeNode) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TMergeNode")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TMergeNode) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TMergeNode")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TMergeNode) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tuple_id", thrift.I32, 1)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.TupleId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TMergeNode) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "result_expr_lists", thrift.LIST, 2)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.LIST, 0)
	var length int
	for _, v := range p.ResultExprLists {
		length++
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range v {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.LIST, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TMergeNode) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "const_expr_lists", thrift.LIST, 3)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.LIST, 0)
	var length int
	for _, v := range p.ConstExprLists {
		length++
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range v {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.LIST, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TMergeNode) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("tuple_id", thrift.I32, 1)
	l += bthrift.Binary.I32Length(p.TupleId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TMergeNode) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("result_expr_lists", thrift.LIST, 2)
	l += bthrift.Binary.ListBeginLength(thrift.LIST, len(p.ResultExprLists))
	for _, v := range p.ResultExprLists {
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(v))
		for _, v := range v {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TMergeNode) field3Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("const_expr_lists", thrift.LIST, 3)
	l += bthrift.Binary.ListBeginLength(thrift.LIST, len(p.ConstExprLists))
	for _, v := range p.ConstExprLists {
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(v))
		for _, v := range v {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TUnionNode) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetTupleId bool = false
	var issetResultExprLists bool = false
	var issetConstExprLists bool = false
	var issetFirstMaterializedChildIdx bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetTupleId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetResultExprLists = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetConstExprLists = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetFirstMaterializedChildIdx = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetTupleId {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetResultExprLists {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetConstExprLists {
		fieldId = 3
		goto RequiredFieldNotSetError
	}

	if !issetFirstMaterializedChildIdx {
		fieldId = 4
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TUnionNode[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TUnionNode[fieldId]))
}

func (p *TUnionNode) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.TupleId = v

	}
	return offset, nil
}

func (p *TUnionNode) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.ResultExprLists = make([][]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
		offset += l
		if err != nil {
			return offset, err
		}
		_elem := make([]*exprs.TExpr, 0, size)
		for i := 0; i < size; i++ {
			_elem1 := exprs.NewTExpr()
			if l, err := _elem1.FastRead(buf[offset:]); err != nil {
				return offset, err
			} else {
				offset += l
			}

			_elem = append(_elem, _elem1)
		}
		if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.ResultExprLists = append(p.ResultExprLists, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TUnionNode) FastReadField3(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.ConstExprLists = make([][]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
		offset += l
		if err != nil {
			return offset, err
		}
		_elem := make([]*exprs.TExpr, 0, size)
		for i := 0; i < size; i++ {
			_elem1 := exprs.NewTExpr()
			if l, err := _elem1.FastRead(buf[offset:]); err != nil {
				return offset, err
			} else {
				offset += l
			}

			_elem = append(_elem, _elem1)
		}
		if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.ConstExprLists = append(p.ConstExprLists, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TUnionNode) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.FirstMaterializedChildIdx = v

	}
	return offset, nil
}

// for compatibility
func (p *TUnionNode) FastWrite(buf []byte) int {
	return 0
}

func (p *TUnionNode) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TUnionNode")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TUnionNode) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TUnionNode")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TUnionNode) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tuple_id", thrift.I32, 1)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.TupleId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TUnionNode) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "result_expr_lists", thrift.LIST, 2)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.LIST, 0)
	var length int
	for _, v := range p.ResultExprLists {
		length++
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range v {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.LIST, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TUnionNode) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "const_expr_lists", thrift.LIST, 3)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.LIST, 0)
	var length int
	for _, v := range p.ConstExprLists {
		length++
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range v {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.LIST, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TUnionNode) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "first_materialized_child_idx", thrift.I64, 4)
	offset += bthrift.Binary.WriteI64(buf[offset:], p.FirstMaterializedChildIdx)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TUnionNode) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("tuple_id", thrift.I32, 1)
	l += bthrift.Binary.I32Length(p.TupleId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TUnionNode) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("result_expr_lists", thrift.LIST, 2)
	l += bthrift.Binary.ListBeginLength(thrift.LIST, len(p.ResultExprLists))
	for _, v := range p.ResultExprLists {
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(v))
		for _, v := range v {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TUnionNode) field3Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("const_expr_lists", thrift.LIST, 3)
	l += bthrift.Binary.ListBeginLength(thrift.LIST, len(p.ConstExprLists))
	for _, v := range p.ConstExprLists {
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(v))
		for _, v := range v {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TUnionNode) field4Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("first_materialized_child_idx", thrift.I64, 4)
	l += bthrift.Binary.I64Length(p.FirstMaterializedChildIdx)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TIntersectNode) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetTupleId bool = false
	var issetResultExprLists bool = false
	var issetConstExprLists bool = false
	var issetFirstMaterializedChildIdx bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetTupleId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetResultExprLists = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetConstExprLists = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetFirstMaterializedChildIdx = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetTupleId {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetResultExprLists {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetConstExprLists {
		fieldId = 3
		goto RequiredFieldNotSetError
	}

	if !issetFirstMaterializedChildIdx {
		fieldId = 4
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TIntersectNode[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TIntersectNode[fieldId]))
}

func (p *TIntersectNode) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.TupleId = v

	}
	return offset, nil
}

func (p *TIntersectNode) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.ResultExprLists = make([][]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
		offset += l
		if err != nil {
			return offset, err
		}
		_elem := make([]*exprs.TExpr, 0, size)
		for i := 0; i < size; i++ {
			_elem1 := exprs.NewTExpr()
			if l, err := _elem1.FastRead(buf[offset:]); err != nil {
				return offset, err
			} else {
				offset += l
			}

			_elem = append(_elem, _elem1)
		}
		if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.ResultExprLists = append(p.ResultExprLists, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TIntersectNode) FastReadField3(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.ConstExprLists = make([][]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
		offset += l
		if err != nil {
			return offset, err
		}
		_elem := make([]*exprs.TExpr, 0, size)
		for i := 0; i < size; i++ {
			_elem1 := exprs.NewTExpr()
			if l, err := _elem1.FastRead(buf[offset:]); err != nil {
				return offset, err
			} else {
				offset += l
			}

			_elem = append(_elem, _elem1)
		}
		if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.ConstExprLists = append(p.ConstExprLists, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TIntersectNode) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.FirstMaterializedChildIdx = v

	}
	return offset, nil
}

func (p *TIntersectNode) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.IsColocate = &v

	}
	return offset, nil
}

// for compatibility
func (p *TIntersectNode) FastWrite(buf []byte) int {
	return 0
}

func (p *TIntersectNode) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TIntersectNode")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TIntersectNode) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TIntersectNode")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TIntersectNode) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tuple_id", thrift.I32, 1)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.TupleId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TIntersectNode) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "result_expr_lists", thrift.LIST, 2)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.LIST, 0)
	var length int
	for _, v := range p.ResultExprLists {
		length++
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range v {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.LIST, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TIntersectNode) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "const_expr_lists", thrift.LIST, 3)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.LIST, 0)
	var length int
	for _, v := range p.ConstExprLists {
		length++
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range v {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.LIST, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TIntersectNode) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "first_materialized_child_idx", thrift.I64, 4)
	offset += bthrift.Binary.WriteI64(buf[offset:], p.FirstMaterializedChildIdx)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TIntersectNode) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIsColocate() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "is_colocate", thrift.BOOL, 5)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.IsColocate)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TIntersectNode) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("tuple_id", thrift.I32, 1)
	l += bthrift.Binary.I32Length(p.TupleId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TIntersectNode) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("result_expr_lists", thrift.LIST, 2)
	l += bthrift.Binary.ListBeginLength(thrift.LIST, len(p.ResultExprLists))
	for _, v := range p.ResultExprLists {
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(v))
		for _, v := range v {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TIntersectNode) field3Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("const_expr_lists", thrift.LIST, 3)
	l += bthrift.Binary.ListBeginLength(thrift.LIST, len(p.ConstExprLists))
	for _, v := range p.ConstExprLists {
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(v))
		for _, v := range v {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TIntersectNode) field4Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("first_materialized_child_idx", thrift.I64, 4)
	l += bthrift.Binary.I64Length(p.FirstMaterializedChildIdx)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TIntersectNode) field5Length() int {
	l := 0
	if p.IsSetIsColocate() {
		l += bthrift.Binary.FieldBeginLength("is_colocate", thrift.BOOL, 5)
		l += bthrift.Binary.BoolLength(*p.IsColocate)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TExceptNode) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetTupleId bool = false
	var issetResultExprLists bool = false
	var issetConstExprLists bool = false
	var issetFirstMaterializedChildIdx bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetTupleId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetResultExprLists = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetConstExprLists = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetFirstMaterializedChildIdx = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetTupleId {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetResultExprLists {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetConstExprLists {
		fieldId = 3
		goto RequiredFieldNotSetError
	}

	if !issetFirstMaterializedChildIdx {
		fieldId = 4
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TExceptNode[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TExceptNode[fieldId]))
}

func (p *TExceptNode) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.TupleId = v

	}
	return offset, nil
}

func (p *TExceptNode) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.ResultExprLists = make([][]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
		offset += l
		if err != nil {
			return offset, err
		}
		_elem := make([]*exprs.TExpr, 0, size)
		for i := 0; i < size; i++ {
			_elem1 := exprs.NewTExpr()
			if l, err := _elem1.FastRead(buf[offset:]); err != nil {
				return offset, err
			} else {
				offset += l
			}

			_elem = append(_elem, _elem1)
		}
		if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.ResultExprLists = append(p.ResultExprLists, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TExceptNode) FastReadField3(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.ConstExprLists = make([][]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
		offset += l
		if err != nil {
			return offset, err
		}
		_elem := make([]*exprs.TExpr, 0, size)
		for i := 0; i < size; i++ {
			_elem1 := exprs.NewTExpr()
			if l, err := _elem1.FastRead(buf[offset:]); err != nil {
				return offset, err
			} else {
				offset += l
			}

			_elem = append(_elem, _elem1)
		}
		if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.ConstExprLists = append(p.ConstExprLists, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TExceptNode) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.FirstMaterializedChildIdx = v

	}
	return offset, nil
}

func (p *TExceptNode) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.IsColocate = &v

	}
	return offset, nil
}

// for compatibility
func (p *TExceptNode) FastWrite(buf []byte) int {
	return 0
}

func (p *TExceptNode) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TExceptNode")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TExceptNode) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TExceptNode")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TExceptNode) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tuple_id", thrift.I32, 1)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.TupleId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TExceptNode) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "result_expr_lists", thrift.LIST, 2)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.LIST, 0)
	var length int
	for _, v := range p.ResultExprLists {
		length++
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range v {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.LIST, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TExceptNode) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "const_expr_lists", thrift.LIST, 3)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.LIST, 0)
	var length int
	for _, v := range p.ConstExprLists {
		length++
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range v {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.LIST, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TExceptNode) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "first_materialized_child_idx", thrift.I64, 4)
	offset += bthrift.Binary.WriteI64(buf[offset:], p.FirstMaterializedChildIdx)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TExceptNode) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIsColocate() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "is_colocate", thrift.BOOL, 5)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.IsColocate)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TExceptNode) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("tuple_id", thrift.I32, 1)
	l += bthrift.Binary.I32Length(p.TupleId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TExceptNode) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("result_expr_lists", thrift.LIST, 2)
	l += bthrift.Binary.ListBeginLength(thrift.LIST, len(p.ResultExprLists))
	for _, v := range p.ResultExprLists {
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(v))
		for _, v := range v {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TExceptNode) field3Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("const_expr_lists", thrift.LIST, 3)
	l += bthrift.Binary.ListBeginLength(thrift.LIST, len(p.ConstExprLists))
	for _, v := range p.ConstExprLists {
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(v))
		for _, v := range v {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TExceptNode) field4Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("first_materialized_child_idx", thrift.I64, 4)
	l += bthrift.Binary.I64Length(p.FirstMaterializedChildIdx)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TExceptNode) field5Length() int {
	l := 0
	if p.IsSetIsColocate() {
		l += bthrift.Binary.FieldBeginLength("is_colocate", thrift.BOOL, 5)
		l += bthrift.Binary.BoolLength(*p.IsColocate)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TExchangeNode) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetInputRowTuples bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetInputRowTuples = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetInputRowTuples {
		fieldId = 1
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TExchangeNode[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TExchangeNode[fieldId]))
}

func (p *TExchangeNode) FastReadField1(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.InputRowTuples = make([]types.TTupleId, 0, size)
	for i := 0; i < size; i++ {
		var _elem types.TTupleId
		if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.InputRowTuples = append(p.InputRowTuples, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TExchangeNode) FastReadField2(buf []byte) (int, error) {
	offset := 0

	tmp := NewTSortInfo()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.SortInfo = tmp
	return offset, nil
}

func (p *TExchangeNode) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.Offset = &v

	}
	return offset, nil
}

func (p *TExchangeNode) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := partitions.TPartitionType(v)
		p.PartitionType = &tmp

	}
	return offset, nil
}

// for compatibility
func (p *TExchangeNode) FastWrite(buf []byte) int {
	return 0
}

func (p *TExchangeNode) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TExchangeNode")
	if p != nil {
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TExchangeNode) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TExchangeNode")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TExchangeNode) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "input_row_tuples", thrift.LIST, 1)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.I32, 0)
	var length int
	for _, v := range p.InputRowTuples {
		length++
		offset += bthrift.Binary.WriteI32(buf[offset:], v)

	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.I32, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TExchangeNode) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSortInfo() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "sort_info", thrift.STRUCT, 2)
		offset += p.SortInfo.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TExchangeNode) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetOffset() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "offset", thrift.I64, 3)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.Offset)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TExchangeNode) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPartitionType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "partition_type", thrift.I32, 4)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.PartitionType))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TExchangeNode) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("input_row_tuples", thrift.LIST, 1)
	l += bthrift.Binary.ListBeginLength(thrift.I32, len(p.InputRowTuples))
	var tmpV types.TTupleId
	l += bthrift.Binary.I32Length(int32(tmpV)) * len(p.InputRowTuples)
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TExchangeNode) field2Length() int {
	l := 0
	if p.IsSetSortInfo() {
		l += bthrift.Binary.FieldBeginLength("sort_info", thrift.STRUCT, 2)
		l += p.SortInfo.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TExchangeNode) field3Length() int {
	l := 0
	if p.IsSetOffset() {
		l += bthrift.Binary.FieldBeginLength("offset", thrift.I64, 3)
		l += bthrift.Binary.I64Length(*p.Offset)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TExchangeNode) field4Length() int {
	l := 0
	if p.IsSetPartitionType() {
		l += bthrift.Binary.FieldBeginLength("partition_type", thrift.I32, 4)
		l += bthrift.Binary.I32Length(int32(*p.PartitionType))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TOlapRewriteNode) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetColumns bool = false
	var issetColumnTypes bool = false
	var issetOutputTupleId bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetColumns = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetColumnTypes = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetOutputTupleId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetColumns {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetColumnTypes {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetOutputTupleId {
		fieldId = 3
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TOlapRewriteNode[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TOlapRewriteNode[fieldId]))
}

func (p *TOlapRewriteNode) FastReadField1(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Columns = make([]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_elem := exprs.NewTExpr()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.Columns = append(p.Columns, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TOlapRewriteNode) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.ColumnTypes = make([]*types.TColumnType, 0, size)
	for i := 0; i < size; i++ {
		_elem := types.NewTColumnType()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.ColumnTypes = append(p.ColumnTypes, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TOlapRewriteNode) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.OutputTupleId = v

	}
	return offset, nil
}

// for compatibility
func (p *TOlapRewriteNode) FastWrite(buf []byte) int {
	return 0
}

func (p *TOlapRewriteNode) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TOlapRewriteNode")
	if p != nil {
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TOlapRewriteNode) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TOlapRewriteNode")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TOlapRewriteNode) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "columns", thrift.LIST, 1)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
	var length int
	for _, v := range p.Columns {
		length++
		offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapRewriteNode) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "column_types", thrift.LIST, 2)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
	var length int
	for _, v := range p.ColumnTypes {
		length++
		offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapRewriteNode) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "output_tuple_id", thrift.I32, 3)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.OutputTupleId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TOlapRewriteNode) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("columns", thrift.LIST, 1)
	l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.Columns))
	for _, v := range p.Columns {
		l += v.BLength()
	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapRewriteNode) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("column_types", thrift.LIST, 2)
	l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.ColumnTypes))
	for _, v := range p.ColumnTypes {
		l += v.BLength()
	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TOlapRewriteNode) field3Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("output_tuple_id", thrift.I32, 3)
	l += bthrift.Binary.I32Length(p.OutputTupleId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TTableFunctionNode) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TTableFunctionNode[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TTableFunctionNode) FastReadField1(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.FnCallExprList = make([]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_elem := exprs.NewTExpr()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.FnCallExprList = append(p.FnCallExprList, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TTableFunctionNode) FastReadField2(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.OutputSlotIds = make([]types.TSlotId, 0, size)
	for i := 0; i < size; i++ {
		var _elem types.TSlotId
		if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.OutputSlotIds = append(p.OutputSlotIds, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

// for compatibility
func (p *TTableFunctionNode) FastWrite(buf []byte) int {
	return 0
}

func (p *TTableFunctionNode) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TTableFunctionNode")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TTableFunctionNode) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TTableFunctionNode")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TTableFunctionNode) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFnCallExprList() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "fnCallExprList", thrift.LIST, 1)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.FnCallExprList {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTableFunctionNode) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetOutputSlotIds() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "outputSlotIds", thrift.LIST, 2)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.I32, 0)
		var length int
		for _, v := range p.OutputSlotIds {
			length++
			offset += bthrift.Binary.WriteI32(buf[offset:], v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.I32, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TTableFunctionNode) field1Length() int {
	l := 0
	if p.IsSetFnCallExprList() {
		l += bthrift.Binary.FieldBeginLength("fnCallExprList", thrift.LIST, 1)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.FnCallExprList))
		for _, v := range p.FnCallExprList {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTableFunctionNode) field2Length() int {
	l := 0
	if p.IsSetOutputSlotIds() {
		l += bthrift.Binary.FieldBeginLength("outputSlotIds", thrift.LIST, 2)
		l += bthrift.Binary.ListBeginLength(thrift.I32, len(p.OutputSlotIds))
		var tmpV types.TSlotId
		l += bthrift.Binary.I32Length(int32(tmpV)) * len(p.OutputSlotIds)
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TBackendResourceProfile) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetMinReservation bool = false
	var issetMaxReservation bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetMinReservation = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetMaxReservation = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetMinReservation {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetMaxReservation {
		fieldId = 2
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TBackendResourceProfile[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TBackendResourceProfile[fieldId]))
}

func (p *TBackendResourceProfile) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.MinReservation = v

	}
	return offset, nil
}

func (p *TBackendResourceProfile) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.MaxReservation = v

	}
	return offset, nil
}

func (p *TBackendResourceProfile) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.SpillableBufferSize = v

	}
	return offset, nil
}

func (p *TBackendResourceProfile) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.MaxRowBufferSize = v

	}
	return offset, nil
}

// for compatibility
func (p *TBackendResourceProfile) FastWrite(buf []byte) int {
	return 0
}

func (p *TBackendResourceProfile) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TBackendResourceProfile")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TBackendResourceProfile) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TBackendResourceProfile")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TBackendResourceProfile) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "min_reservation", thrift.I64, 1)
	offset += bthrift.Binary.WriteI64(buf[offset:], p.MinReservation)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TBackendResourceProfile) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "max_reservation", thrift.I64, 2)
	offset += bthrift.Binary.WriteI64(buf[offset:], p.MaxReservation)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TBackendResourceProfile) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSpillableBufferSize() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "spillable_buffer_size", thrift.I64, 3)
		offset += bthrift.Binary.WriteI64(buf[offset:], p.SpillableBufferSize)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TBackendResourceProfile) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetMaxRowBufferSize() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "max_row_buffer_size", thrift.I64, 4)
		offset += bthrift.Binary.WriteI64(buf[offset:], p.MaxRowBufferSize)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TBackendResourceProfile) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("min_reservation", thrift.I64, 1)
	l += bthrift.Binary.I64Length(p.MinReservation)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TBackendResourceProfile) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("max_reservation", thrift.I64, 2)
	l += bthrift.Binary.I64Length(p.MaxReservation)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TBackendResourceProfile) field3Length() int {
	l := 0
	if p.IsSetSpillableBufferSize() {
		l += bthrift.Binary.FieldBeginLength("spillable_buffer_size", thrift.I64, 3)
		l += bthrift.Binary.I64Length(p.SpillableBufferSize)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TBackendResourceProfile) field4Length() int {
	l := 0
	if p.IsSetMaxRowBufferSize() {
		l += bthrift.Binary.FieldBeginLength("max_row_buffer_size", thrift.I64, 4)
		l += bthrift.Binary.I64Length(p.MaxRowBufferSize)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TAssertNumRowsNode) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TAssertNumRowsNode[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TAssertNumRowsNode) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.DesiredNumRows = &v

	}
	return offset, nil
}

func (p *TAssertNumRowsNode) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadString(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.SubqueryString = &v

	}
	return offset, nil
}

func (p *TAssertNumRowsNode) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := TAssertion(v)
		p.Assertion = &tmp

	}
	return offset, nil
}

func (p *TAssertNumRowsNode) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.ShouldConvertOutputToNullable = &v

	}
	return offset, nil
}

// for compatibility
func (p *TAssertNumRowsNode) FastWrite(buf []byte) int {
	return 0
}

func (p *TAssertNumRowsNode) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TAssertNumRowsNode")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TAssertNumRowsNode) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TAssertNumRowsNode")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TAssertNumRowsNode) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDesiredNumRows() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "desired_num_rows", thrift.I64, 1)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.DesiredNumRows)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TAssertNumRowsNode) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSubqueryString() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "subquery_string", thrift.STRING, 2)
		offset += bthrift.Binary.WriteStringNocopy(buf[offset:], binaryWriter, *p.SubqueryString)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TAssertNumRowsNode) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetAssertion() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "assertion", thrift.I32, 3)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.Assertion))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TAssertNumRowsNode) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetShouldConvertOutputToNullable() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "should_convert_output_to_nullable", thrift.BOOL, 4)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.ShouldConvertOutputToNullable)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TAssertNumRowsNode) field1Length() int {
	l := 0
	if p.IsSetDesiredNumRows() {
		l += bthrift.Binary.FieldBeginLength("desired_num_rows", thrift.I64, 1)
		l += bthrift.Binary.I64Length(*p.DesiredNumRows)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TAssertNumRowsNode) field2Length() int {
	l := 0
	if p.IsSetSubqueryString() {
		l += bthrift.Binary.FieldBeginLength("subquery_string", thrift.STRING, 2)
		l += bthrift.Binary.StringLengthNocopy(*p.SubqueryString)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TAssertNumRowsNode) field3Length() int {
	l := 0
	if p.IsSetAssertion() {
		l += bthrift.Binary.FieldBeginLength("assertion", thrift.I32, 3)
		l += bthrift.Binary.I32Length(int32(*p.Assertion))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TAssertNumRowsNode) field4Length() int {
	l := 0
	if p.IsSetShouldConvertOutputToNullable() {
		l += bthrift.Binary.FieldBeginLength("should_convert_output_to_nullable", thrift.BOOL, 4)
		l += bthrift.Binary.BoolLength(*p.ShouldConvertOutputToNullable)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TTopnFilterDesc) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetSourceNodeId bool = false
	var issetIsAsc bool = false
	var issetNullFirst bool = false
	var issetTargetNodeIdToTargetExpr bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetSourceNodeId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetIsAsc = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetNullFirst = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetTargetNodeIdToTargetExpr = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetSourceNodeId {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetIsAsc {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetNullFirst {
		fieldId = 3
		goto RequiredFieldNotSetError
	}

	if !issetTargetNodeIdToTargetExpr {
		fieldId = 4
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TTopnFilterDesc[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TTopnFilterDesc[fieldId]))
}

func (p *TTopnFilterDesc) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.SourceNodeId = v

	}
	return offset, nil
}

func (p *TTopnFilterDesc) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.IsAsc = v

	}
	return offset, nil
}

func (p *TTopnFilterDesc) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.NullFirst = v

	}
	return offset, nil
}

func (p *TTopnFilterDesc) FastReadField4(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := bthrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.TargetNodeIdToTargetExpr = make(map[types.TPlanNodeId]*exprs.TExpr, size)
	for i := 0; i < size; i++ {
		var _key types.TPlanNodeId
		if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_key = v

		}
		_val := exprs.NewTExpr()
		if l, err := _val.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.TargetNodeIdToTargetExpr[_key] = _val
	}
	if l, err := bthrift.Binary.ReadMapEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

// for compatibility
func (p *TTopnFilterDesc) FastWrite(buf []byte) int {
	return 0
}

func (p *TTopnFilterDesc) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TTopnFilterDesc")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TTopnFilterDesc) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TTopnFilterDesc")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TTopnFilterDesc) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "source_node_id", thrift.I32, 1)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.SourceNodeId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TTopnFilterDesc) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "is_asc", thrift.BOOL, 2)
	offset += bthrift.Binary.WriteBool(buf[offset:], p.IsAsc)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TTopnFilterDesc) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "null_first", thrift.BOOL, 3)
	offset += bthrift.Binary.WriteBool(buf[offset:], p.NullFirst)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TTopnFilterDesc) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "target_node_id_to_target_expr", thrift.MAP, 4)
	mapBeginOffset := offset
	offset += bthrift.Binary.MapBeginLength(thrift.I32, thrift.STRUCT, 0)
	var length int
	for k, v := range p.TargetNodeIdToTargetExpr {
		length++

		offset += bthrift.Binary.WriteI32(buf[offset:], k)

		offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
	}
	bthrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.I32, thrift.STRUCT, length)
	offset += bthrift.Binary.WriteMapEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TTopnFilterDesc) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("source_node_id", thrift.I32, 1)
	l += bthrift.Binary.I32Length(p.SourceNodeId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TTopnFilterDesc) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("is_asc", thrift.BOOL, 2)
	l += bthrift.Binary.BoolLength(p.IsAsc)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TTopnFilterDesc) field3Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("null_first", thrift.BOOL, 3)
	l += bthrift.Binary.BoolLength(p.NullFirst)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TTopnFilterDesc) field4Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("target_node_id_to_target_expr", thrift.MAP, 4)
	l += bthrift.Binary.MapBeginLength(thrift.I32, thrift.STRUCT, len(p.TargetNodeIdToTargetExpr))
	for k, v := range p.TargetNodeIdToTargetExpr {

		l += bthrift.Binary.I32Length(k)

		l += v.BLength()
	}
	l += bthrift.Binary.MapEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TRuntimeFilterDesc) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetFilterId bool = false
	var issetSrcExpr bool = false
	var issetExprOrder bool = false
	var issetPlanIdToTargetExpr bool = false
	var issetIsBroadcastJoin bool = false
	var issetHasLocalTargets bool = false
	var issetHasRemoteTargets bool = false
	var issetType bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetFilterId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetSrcExpr = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetExprOrder = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.MAP {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetPlanIdToTargetExpr = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetIsBroadcastJoin = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetHasLocalTargets = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetHasRemoteTargets = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetType = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 9:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField9(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 10:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField10(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 11:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField11(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 12:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField12(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 13:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField13(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 14:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField14(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 15:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField15(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 16:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField16(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetFilterId {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetSrcExpr {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetExprOrder {
		fieldId = 3
		goto RequiredFieldNotSetError
	}

	if !issetPlanIdToTargetExpr {
		fieldId = 4
		goto RequiredFieldNotSetError
	}

	if !issetIsBroadcastJoin {
		fieldId = 5
		goto RequiredFieldNotSetError
	}

	if !issetHasLocalTargets {
		fieldId = 6
		goto RequiredFieldNotSetError
	}

	if !issetHasRemoteTargets {
		fieldId = 7
		goto RequiredFieldNotSetError
	}

	if !issetType {
		fieldId = 8
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TRuntimeFilterDesc[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TRuntimeFilterDesc[fieldId]))
}

func (p *TRuntimeFilterDesc) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.FilterId = v

	}
	return offset, nil
}

func (p *TRuntimeFilterDesc) FastReadField2(buf []byte) (int, error) {
	offset := 0

	tmp := exprs.NewTExpr()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.SrcExpr = tmp
	return offset, nil
}

func (p *TRuntimeFilterDesc) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.ExprOrder = v

	}
	return offset, nil
}

func (p *TRuntimeFilterDesc) FastReadField4(buf []byte) (int, error) {
	offset := 0

	_, _, size, l, err := bthrift.Binary.ReadMapBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.PlanIdToTargetExpr = make(map[types.TPlanNodeId]*exprs.TExpr, size)
	for i := 0; i < size; i++ {
		var _key types.TPlanNodeId
		if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_key = v

		}
		_val := exprs.NewTExpr()
		if l, err := _val.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.PlanIdToTargetExpr[_key] = _val
	}
	if l, err := bthrift.Binary.ReadMapEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TRuntimeFilterDesc) FastReadField5(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.IsBroadcastJoin = v

	}
	return offset, nil
}

func (p *TRuntimeFilterDesc) FastReadField6(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.HasLocalTargets = v

	}
	return offset, nil
}

func (p *TRuntimeFilterDesc) FastReadField7(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.HasRemoteTargets = v

	}
	return offset, nil
}

func (p *TRuntimeFilterDesc) FastReadField8(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Type = TRuntimeFilterType(v)

	}
	return offset, nil
}

func (p *TRuntimeFilterDesc) FastReadField9(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.BloomFilterSizeBytes = &v

	}
	return offset, nil
}

func (p *TRuntimeFilterDesc) FastReadField10(buf []byte) (int, error) {
	offset := 0

	tmp := exprs.NewTExpr()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.BitmapTargetExpr = tmp
	return offset, nil
}

func (p *TRuntimeFilterDesc) FastReadField11(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.BitmapFilterNotIn = &v

	}
	return offset, nil
}

func (p *TRuntimeFilterDesc) FastReadField12(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.OptRemoteRf = &v

	}
	return offset, nil
}

func (p *TRuntimeFilterDesc) FastReadField13(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := TMinMaxRuntimeFilterType(v)
		p.MinMaxType = &tmp

	}
	return offset, nil
}

func (p *TRuntimeFilterDesc) FastReadField14(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.BloomFilterSizeCalculatedByNdv = &v

	}
	return offset, nil
}

func (p *TRuntimeFilterDesc) FastReadField15(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.NullAware = &v

	}
	return offset, nil
}

func (p *TRuntimeFilterDesc) FastReadField16(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.SyncFilterSize = &v

	}
	return offset, nil
}

// for compatibility
func (p *TRuntimeFilterDesc) FastWrite(buf []byte) int {
	return 0
}

func (p *TRuntimeFilterDesc) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TRuntimeFilterDesc")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField9(buf[offset:], binaryWriter)
		offset += p.fastWriteField11(buf[offset:], binaryWriter)
		offset += p.fastWriteField12(buf[offset:], binaryWriter)
		offset += p.fastWriteField14(buf[offset:], binaryWriter)
		offset += p.fastWriteField15(buf[offset:], binaryWriter)
		offset += p.fastWriteField16(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
		offset += p.fastWriteField10(buf[offset:], binaryWriter)
		offset += p.fastWriteField13(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TRuntimeFilterDesc) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TRuntimeFilterDesc")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field9Length()
		l += p.field10Length()
		l += p.field11Length()
		l += p.field12Length()
		l += p.field13Length()
		l += p.field14Length()
		l += p.field15Length()
		l += p.field16Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TRuntimeFilterDesc) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "filter_id", thrift.I32, 1)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.FilterId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TRuntimeFilterDesc) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "src_expr", thrift.STRUCT, 2)
	offset += p.SrcExpr.FastWriteNocopy(buf[offset:], binaryWriter)
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TRuntimeFilterDesc) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "expr_order", thrift.I32, 3)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.ExprOrder)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TRuntimeFilterDesc) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "planId_to_target_expr", thrift.MAP, 4)
	mapBeginOffset := offset
	offset += bthrift.Binary.MapBeginLength(thrift.I32, thrift.STRUCT, 0)
	var length int
	for k, v := range p.PlanIdToTargetExpr {
		length++

		offset += bthrift.Binary.WriteI32(buf[offset:], k)

		offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
	}
	bthrift.Binary.WriteMapBegin(buf[mapBeginOffset:], thrift.I32, thrift.STRUCT, length)
	offset += bthrift.Binary.WriteMapEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TRuntimeFilterDesc) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "is_broadcast_join", thrift.BOOL, 5)
	offset += bthrift.Binary.WriteBool(buf[offset:], p.IsBroadcastJoin)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TRuntimeFilterDesc) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "has_local_targets", thrift.BOOL, 6)
	offset += bthrift.Binary.WriteBool(buf[offset:], p.HasLocalTargets)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TRuntimeFilterDesc) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "has_remote_targets", thrift.BOOL, 7)
	offset += bthrift.Binary.WriteBool(buf[offset:], p.HasRemoteTargets)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TRuntimeFilterDesc) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "type", thrift.I32, 8)
	offset += bthrift.Binary.WriteI32(buf[offset:], int32(p.Type))

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TRuntimeFilterDesc) fastWriteField9(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetBloomFilterSizeBytes() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "bloom_filter_size_bytes", thrift.I64, 9)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.BloomFilterSizeBytes)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TRuntimeFilterDesc) fastWriteField10(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetBitmapTargetExpr() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "bitmap_target_expr", thrift.STRUCT, 10)
		offset += p.BitmapTargetExpr.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TRuntimeFilterDesc) fastWriteField11(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetBitmapFilterNotIn() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "bitmap_filter_not_in", thrift.BOOL, 11)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.BitmapFilterNotIn)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TRuntimeFilterDesc) fastWriteField12(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetOptRemoteRf() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "opt_remote_rf", thrift.BOOL, 12)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.OptRemoteRf)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TRuntimeFilterDesc) fastWriteField13(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetMinMaxType() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "min_max_type", thrift.I32, 13)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.MinMaxType))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TRuntimeFilterDesc) fastWriteField14(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetBloomFilterSizeCalculatedByNdv() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "bloom_filter_size_calculated_by_ndv", thrift.BOOL, 14)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.BloomFilterSizeCalculatedByNdv)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TRuntimeFilterDesc) fastWriteField15(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetNullAware() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "null_aware", thrift.BOOL, 15)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.NullAware)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TRuntimeFilterDesc) fastWriteField16(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSyncFilterSize() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "sync_filter_size", thrift.BOOL, 16)
		offset += bthrift.Binary.WriteBool(buf[offset:], *p.SyncFilterSize)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TRuntimeFilterDesc) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("filter_id", thrift.I32, 1)
	l += bthrift.Binary.I32Length(p.FilterId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TRuntimeFilterDesc) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("src_expr", thrift.STRUCT, 2)
	l += p.SrcExpr.BLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TRuntimeFilterDesc) field3Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("expr_order", thrift.I32, 3)
	l += bthrift.Binary.I32Length(p.ExprOrder)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TRuntimeFilterDesc) field4Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("planId_to_target_expr", thrift.MAP, 4)
	l += bthrift.Binary.MapBeginLength(thrift.I32, thrift.STRUCT, len(p.PlanIdToTargetExpr))
	for k, v := range p.PlanIdToTargetExpr {

		l += bthrift.Binary.I32Length(k)

		l += v.BLength()
	}
	l += bthrift.Binary.MapEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TRuntimeFilterDesc) field5Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("is_broadcast_join", thrift.BOOL, 5)
	l += bthrift.Binary.BoolLength(p.IsBroadcastJoin)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TRuntimeFilterDesc) field6Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("has_local_targets", thrift.BOOL, 6)
	l += bthrift.Binary.BoolLength(p.HasLocalTargets)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TRuntimeFilterDesc) field7Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("has_remote_targets", thrift.BOOL, 7)
	l += bthrift.Binary.BoolLength(p.HasRemoteTargets)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TRuntimeFilterDesc) field8Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("type", thrift.I32, 8)
	l += bthrift.Binary.I32Length(int32(p.Type))

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TRuntimeFilterDesc) field9Length() int {
	l := 0
	if p.IsSetBloomFilterSizeBytes() {
		l += bthrift.Binary.FieldBeginLength("bloom_filter_size_bytes", thrift.I64, 9)
		l += bthrift.Binary.I64Length(*p.BloomFilterSizeBytes)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TRuntimeFilterDesc) field10Length() int {
	l := 0
	if p.IsSetBitmapTargetExpr() {
		l += bthrift.Binary.FieldBeginLength("bitmap_target_expr", thrift.STRUCT, 10)
		l += p.BitmapTargetExpr.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TRuntimeFilterDesc) field11Length() int {
	l := 0
	if p.IsSetBitmapFilterNotIn() {
		l += bthrift.Binary.FieldBeginLength("bitmap_filter_not_in", thrift.BOOL, 11)
		l += bthrift.Binary.BoolLength(*p.BitmapFilterNotIn)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TRuntimeFilterDesc) field12Length() int {
	l := 0
	if p.IsSetOptRemoteRf() {
		l += bthrift.Binary.FieldBeginLength("opt_remote_rf", thrift.BOOL, 12)
		l += bthrift.Binary.BoolLength(*p.OptRemoteRf)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TRuntimeFilterDesc) field13Length() int {
	l := 0
	if p.IsSetMinMaxType() {
		l += bthrift.Binary.FieldBeginLength("min_max_type", thrift.I32, 13)
		l += bthrift.Binary.I32Length(int32(*p.MinMaxType))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TRuntimeFilterDesc) field14Length() int {
	l := 0
	if p.IsSetBloomFilterSizeCalculatedByNdv() {
		l += bthrift.Binary.FieldBeginLength("bloom_filter_size_calculated_by_ndv", thrift.BOOL, 14)
		l += bthrift.Binary.BoolLength(*p.BloomFilterSizeCalculatedByNdv)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TRuntimeFilterDesc) field15Length() int {
	l := 0
	if p.IsSetNullAware() {
		l += bthrift.Binary.FieldBeginLength("null_aware", thrift.BOOL, 15)
		l += bthrift.Binary.BoolLength(*p.NullAware)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TRuntimeFilterDesc) field16Length() int {
	l := 0
	if p.IsSetSyncFilterSize() {
		l += bthrift.Binary.FieldBeginLength("sync_filter_size", thrift.BOOL, 16)
		l += bthrift.Binary.BoolLength(*p.SyncFilterSize)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TDataGenScanNode) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TDataGenScanNode[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TDataGenScanNode) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.TupleId = &v

	}
	return offset, nil
}

func (p *TDataGenScanNode) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := TDataGenFunctionName(v)
		p.FuncName = &tmp

	}
	return offset, nil
}

// for compatibility
func (p *TDataGenScanNode) FastWrite(buf []byte) int {
	return 0
}

func (p *TDataGenScanNode) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TDataGenScanNode")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TDataGenScanNode) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TDataGenScanNode")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TDataGenScanNode) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTupleId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "tuple_id", thrift.I32, 1)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.TupleId)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TDataGenScanNode) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFuncName() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "func_name", thrift.I32, 2)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.FuncName))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TDataGenScanNode) field1Length() int {
	l := 0
	if p.IsSetTupleId() {
		l += bthrift.Binary.FieldBeginLength("tuple_id", thrift.I32, 1)
		l += bthrift.Binary.I32Length(*p.TupleId)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TDataGenScanNode) field2Length() int {
	l := 0
	if p.IsSetFuncName() {
		l += bthrift.Binary.FieldBeginLength("func_name", thrift.I32, 2)
		l += bthrift.Binary.I32Length(int32(*p.FuncName))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TGroupCommitScanNode) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TGroupCommitScanNode[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
}

func (p *TGroupCommitScanNode) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.TableId = &v

	}
	return offset, nil
}

// for compatibility
func (p *TGroupCommitScanNode) FastWrite(buf []byte) int {
	return 0
}

func (p *TGroupCommitScanNode) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TGroupCommitScanNode")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TGroupCommitScanNode) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TGroupCommitScanNode")
	if p != nil {
		l += p.field1Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TGroupCommitScanNode) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTableId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "table_id", thrift.I64, 1)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.TableId)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TGroupCommitScanNode) field1Length() int {
	l := 0
	if p.IsSetTableId() {
		l += bthrift.Binary.FieldBeginLength("table_id", thrift.I64, 1)
		l += bthrift.Binary.I64Length(*p.TableId)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetNodeId bool = false
	var issetNodeType bool = false
	var issetNumChildren bool = false
	var issetLimit bool = false
	var issetRowTuples bool = false
	var issetNullableTuples bool = false
	var issetCompactData bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetNodeId = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField2(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetNodeType = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField3(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetNumChildren = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 4:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField4(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetLimit = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 5:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField5(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetRowTuples = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 6:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField6(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetNullableTuples = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 7:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField7(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 8:
			if fieldTypeId == thrift.BOOL {
				l, err = p.FastReadField8(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetCompactData = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 11:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField11(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 12:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField12(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 13:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField13(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 14:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField14(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 15:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField15(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 17:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField17(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 18:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField18(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 19:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField19(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 20:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField20(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 21:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField21(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 22:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField22(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 23:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField23(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 24:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField24(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 25:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField25(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 26:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField26(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 28:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField28(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 29:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField29(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 30:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField30(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 31:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField31(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 32:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField32(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 33:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField33(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 34:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField34(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 35:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField35(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 36:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField36(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 37:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField37(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 40:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField40(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 41:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField41(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 42:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField42(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 43:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField43(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 44:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField44(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 45:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField45(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 46:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField46(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 47:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField47(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 48:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField48(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 49:
			if fieldTypeId == thrift.I64 {
				l, err = p.FastReadField49(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 50:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField50(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 101:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField101(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 102:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField102(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 103:
			if fieldTypeId == thrift.STRUCT {
				l, err = p.FastReadField103(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 104:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField104(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 105:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField105(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 106:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField106(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		case 107:
			if fieldTypeId == thrift.I32 {
				l, err = p.FastReadField107(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetNodeId {
		fieldId = 1
		goto RequiredFieldNotSetError
	}

	if !issetNodeType {
		fieldId = 2
		goto RequiredFieldNotSetError
	}

	if !issetNumChildren {
		fieldId = 3
		goto RequiredFieldNotSetError
	}

	if !issetLimit {
		fieldId = 4
		goto RequiredFieldNotSetError
	}

	if !issetRowTuples {
		fieldId = 5
		goto RequiredFieldNotSetError
	}

	if !issetNullableTuples {
		fieldId = 6
		goto RequiredFieldNotSetError
	}

	if !issetCompactData {
		fieldId = 8
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TPlanNode[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TPlanNode[fieldId]))
}

func (p *TPlanNode) FastReadField1(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.NodeId = v

	}
	return offset, nil
}

func (p *TPlanNode) FastReadField2(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.NodeType = TPlanNodeType(v)

	}
	return offset, nil
}

func (p *TPlanNode) FastReadField3(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.NumChildren = v

	}
	return offset, nil
}

func (p *TPlanNode) FastReadField4(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.Limit = v

	}
	return offset, nil
}

func (p *TPlanNode) FastReadField5(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.RowTuples = make([]types.TTupleId, 0, size)
	for i := 0; i < size; i++ {
		var _elem types.TTupleId
		if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.RowTuples = append(p.RowTuples, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TPlanNode) FastReadField6(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.NullableTuples = make([]bool, 0, size)
	for i := 0; i < size; i++ {
		var _elem bool
		if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.NullableTuples = append(p.NullableTuples, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TPlanNode) FastReadField7(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Conjuncts = make([]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_elem := exprs.NewTExpr()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.Conjuncts = append(p.Conjuncts, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TPlanNode) FastReadField8(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadBool(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		p.CompactData = v

	}
	return offset, nil
}

func (p *TPlanNode) FastReadField11(buf []byte) (int, error) {
	offset := 0

	tmp := NewTHashJoinNode()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.HashJoinNode = tmp
	return offset, nil
}

func (p *TPlanNode) FastReadField12(buf []byte) (int, error) {
	offset := 0

	tmp := NewTAggregationNode()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.AggNode = tmp
	return offset, nil
}

func (p *TPlanNode) FastReadField13(buf []byte) (int, error) {
	offset := 0

	tmp := NewTSortNode()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.SortNode = tmp
	return offset, nil
}

func (p *TPlanNode) FastReadField14(buf []byte) (int, error) {
	offset := 0

	tmp := NewTMergeNode()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.MergeNode = tmp
	return offset, nil
}

func (p *TPlanNode) FastReadField15(buf []byte) (int, error) {
	offset := 0

	tmp := NewTExchangeNode()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.ExchangeNode = tmp
	return offset, nil
}

func (p *TPlanNode) FastReadField17(buf []byte) (int, error) {
	offset := 0

	tmp := NewTMySQLScanNode()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.MysqlScanNode = tmp
	return offset, nil
}

func (p *TPlanNode) FastReadField18(buf []byte) (int, error) {
	offset := 0

	tmp := NewTOlapScanNode()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.OlapScanNode = tmp
	return offset, nil
}

func (p *TPlanNode) FastReadField19(buf []byte) (int, error) {
	offset := 0

	tmp := NewTCsvScanNode()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.CsvScanNode = tmp
	return offset, nil
}

func (p *TPlanNode) FastReadField20(buf []byte) (int, error) {
	offset := 0

	tmp := NewTBrokerScanNode()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.BrokerScanNode = tmp
	return offset, nil
}

func (p *TPlanNode) FastReadField21(buf []byte) (int, error) {
	offset := 0

	tmp := NewTPreAggregationNode()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.PreAggNode = tmp
	return offset, nil
}

func (p *TPlanNode) FastReadField22(buf []byte) (int, error) {
	offset := 0

	tmp := NewTSchemaScanNode()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.SchemaScanNode = tmp
	return offset, nil
}

func (p *TPlanNode) FastReadField23(buf []byte) (int, error) {
	offset := 0

	tmp := NewTMergeJoinNode()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.MergeJoinNode = tmp
	return offset, nil
}

func (p *TPlanNode) FastReadField24(buf []byte) (int, error) {
	offset := 0

	tmp := NewTMetaScanNode()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.MetaScanNode = tmp
	return offset, nil
}

func (p *TPlanNode) FastReadField25(buf []byte) (int, error) {
	offset := 0

	tmp := NewTAnalyticNode()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.AnalyticNode = tmp
	return offset, nil
}

func (p *TPlanNode) FastReadField26(buf []byte) (int, error) {
	offset := 0

	tmp := NewTOlapRewriteNode()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.OlapRewriteNode = tmp
	return offset, nil
}

func (p *TPlanNode) FastReadField28(buf []byte) (int, error) {
	offset := 0

	tmp := NewTUnionNode()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.UnionNode = tmp
	return offset, nil
}

func (p *TPlanNode) FastReadField29(buf []byte) (int, error) {
	offset := 0

	tmp := NewTBackendResourceProfile()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.ResourceProfile = tmp
	return offset, nil
}

func (p *TPlanNode) FastReadField30(buf []byte) (int, error) {
	offset := 0

	tmp := NewTEsScanNode()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.EsScanNode = tmp
	return offset, nil
}

func (p *TPlanNode) FastReadField31(buf []byte) (int, error) {
	offset := 0

	tmp := NewTRepeatNode()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.RepeatNode = tmp
	return offset, nil
}

func (p *TPlanNode) FastReadField32(buf []byte) (int, error) {
	offset := 0

	tmp := NewTAssertNumRowsNode()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.AssertNumRowsNode = tmp
	return offset, nil
}

func (p *TPlanNode) FastReadField33(buf []byte) (int, error) {
	offset := 0

	tmp := NewTIntersectNode()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.IntersectNode = tmp
	return offset, nil
}

func (p *TPlanNode) FastReadField34(buf []byte) (int, error) {
	offset := 0

	tmp := NewTExceptNode()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.ExceptNode = tmp
	return offset, nil
}

func (p *TPlanNode) FastReadField35(buf []byte) (int, error) {
	offset := 0

	tmp := NewTOdbcScanNode()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.OdbcScanNode = tmp
	return offset, nil
}

func (p *TPlanNode) FastReadField36(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.RuntimeFilters = make([]*TRuntimeFilterDesc, 0, size)
	for i := 0; i < size; i++ {
		_elem := NewTRuntimeFilterDesc()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.RuntimeFilters = append(p.RuntimeFilters, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TPlanNode) FastReadField37(buf []byte) (int, error) {
	offset := 0

	tmp := NewTGroupCommitScanNode()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.GroupCommitScanNode = tmp
	return offset, nil
}

func (p *TPlanNode) FastReadField40(buf []byte) (int, error) {
	offset := 0

	tmp := exprs.NewTExpr()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.Vconjunct = tmp
	return offset, nil
}

func (p *TPlanNode) FastReadField41(buf []byte) (int, error) {
	offset := 0

	tmp := NewTTableFunctionNode()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.TableFunctionNode = tmp
	return offset, nil
}

func (p *TPlanNode) FastReadField42(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.OutputSlotIds = make([]types.TSlotId, 0, size)
	for i := 0; i < size; i++ {
		var _elem types.TSlotId
		if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.OutputSlotIds = append(p.OutputSlotIds, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TPlanNode) FastReadField43(buf []byte) (int, error) {
	offset := 0

	tmp := NewTDataGenScanNode()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.DataGenScanNode = tmp
	return offset, nil
}

func (p *TPlanNode) FastReadField44(buf []byte) (int, error) {
	offset := 0

	tmp := NewTFileScanNode()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.FileScanNode = tmp
	return offset, nil
}

func (p *TPlanNode) FastReadField45(buf []byte) (int, error) {
	offset := 0

	tmp := NewTJdbcScanNode()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.JdbcScanNode = tmp
	return offset, nil
}

func (p *TPlanNode) FastReadField46(buf []byte) (int, error) {
	offset := 0

	tmp := NewTNestedLoopJoinNode()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.NestedLoopJoinNode = tmp
	return offset, nil
}

func (p *TPlanNode) FastReadField47(buf []byte) (int, error) {
	offset := 0

	tmp := NewTTestExternalScanNode()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.TestExternalScanNode = tmp
	return offset, nil
}

func (p *TPlanNode) FastReadField48(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l

		tmp := TPushAggOp(v)
		p.PushDownAggTypeOpt = &tmp

	}
	return offset, nil
}

func (p *TPlanNode) FastReadField49(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI64(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.PushDownCount = &v

	}
	return offset, nil
}

func (p *TPlanNode) FastReadField50(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.DistributeExprLists = make([][]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
		offset += l
		if err != nil {
			return offset, err
		}
		_elem := make([]*exprs.TExpr, 0, size)
		for i := 0; i < size; i++ {
			_elem1 := exprs.NewTExpr()
			if l, err := _elem1.FastRead(buf[offset:]); err != nil {
				return offset, err
			} else {
				offset += l
			}

			_elem = append(_elem, _elem1)
		}
		if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.DistributeExprLists = append(p.DistributeExprLists, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TPlanNode) FastReadField101(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Projections = make([]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_elem := exprs.NewTExpr()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.Projections = append(p.Projections, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TPlanNode) FastReadField102(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.OutputTupleId = &v

	}
	return offset, nil
}

func (p *TPlanNode) FastReadField103(buf []byte) (int, error) {
	offset := 0

	tmp := NewTPartitionSortNode()
	if l, err := tmp.FastRead(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	p.PartitionSortNode = tmp
	return offset, nil
}

func (p *TPlanNode) FastReadField104(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.IntermediateProjectionsList = make([][]*exprs.TExpr, 0, size)
	for i := 0; i < size; i++ {
		_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
		offset += l
		if err != nil {
			return offset, err
		}
		_elem := make([]*exprs.TExpr, 0, size)
		for i := 0; i < size; i++ {
			_elem1 := exprs.NewTExpr()
			if l, err := _elem1.FastRead(buf[offset:]); err != nil {
				return offset, err
			} else {
				offset += l
			}

			_elem = append(_elem, _elem1)
		}
		if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.IntermediateProjectionsList = append(p.IntermediateProjectionsList, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TPlanNode) FastReadField105(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.IntermediateOutputTupleIdList = make([]types.TTupleId, 0, size)
	for i := 0; i < size; i++ {
		var _elem types.TTupleId
		if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.IntermediateOutputTupleIdList = append(p.IntermediateOutputTupleIdList, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TPlanNode) FastReadField106(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.TopnFilterSourceNodeIds = make([]int32, 0, size)
	for i := 0; i < size; i++ {
		var _elem int32
		if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l

			_elem = v

		}

		p.TopnFilterSourceNodeIds = append(p.TopnFilterSourceNodeIds, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

func (p *TPlanNode) FastReadField107(buf []byte) (int, error) {
	offset := 0

	if v, l, err := bthrift.Binary.ReadI32(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
		p.NereidsId = &v

	}
	return offset, nil
}

// for compatibility
func (p *TPlanNode) FastWrite(buf []byte) int {
	return 0
}

func (p *TPlanNode) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TPlanNode")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
		offset += p.fastWriteField3(buf[offset:], binaryWriter)
		offset += p.fastWriteField4(buf[offset:], binaryWriter)
		offset += p.fastWriteField8(buf[offset:], binaryWriter)
		offset += p.fastWriteField49(buf[offset:], binaryWriter)
		offset += p.fastWriteField102(buf[offset:], binaryWriter)
		offset += p.fastWriteField107(buf[offset:], binaryWriter)
		offset += p.fastWriteField2(buf[offset:], binaryWriter)
		offset += p.fastWriteField5(buf[offset:], binaryWriter)
		offset += p.fastWriteField6(buf[offset:], binaryWriter)
		offset += p.fastWriteField7(buf[offset:], binaryWriter)
		offset += p.fastWriteField11(buf[offset:], binaryWriter)
		offset += p.fastWriteField12(buf[offset:], binaryWriter)
		offset += p.fastWriteField13(buf[offset:], binaryWriter)
		offset += p.fastWriteField14(buf[offset:], binaryWriter)
		offset += p.fastWriteField15(buf[offset:], binaryWriter)
		offset += p.fastWriteField17(buf[offset:], binaryWriter)
		offset += p.fastWriteField18(buf[offset:], binaryWriter)
		offset += p.fastWriteField19(buf[offset:], binaryWriter)
		offset += p.fastWriteField20(buf[offset:], binaryWriter)
		offset += p.fastWriteField21(buf[offset:], binaryWriter)
		offset += p.fastWriteField22(buf[offset:], binaryWriter)
		offset += p.fastWriteField23(buf[offset:], binaryWriter)
		offset += p.fastWriteField24(buf[offset:], binaryWriter)
		offset += p.fastWriteField25(buf[offset:], binaryWriter)
		offset += p.fastWriteField26(buf[offset:], binaryWriter)
		offset += p.fastWriteField28(buf[offset:], binaryWriter)
		offset += p.fastWriteField29(buf[offset:], binaryWriter)
		offset += p.fastWriteField30(buf[offset:], binaryWriter)
		offset += p.fastWriteField31(buf[offset:], binaryWriter)
		offset += p.fastWriteField32(buf[offset:], binaryWriter)
		offset += p.fastWriteField33(buf[offset:], binaryWriter)
		offset += p.fastWriteField34(buf[offset:], binaryWriter)
		offset += p.fastWriteField35(buf[offset:], binaryWriter)
		offset += p.fastWriteField36(buf[offset:], binaryWriter)
		offset += p.fastWriteField37(buf[offset:], binaryWriter)
		offset += p.fastWriteField40(buf[offset:], binaryWriter)
		offset += p.fastWriteField41(buf[offset:], binaryWriter)
		offset += p.fastWriteField42(buf[offset:], binaryWriter)
		offset += p.fastWriteField43(buf[offset:], binaryWriter)
		offset += p.fastWriteField44(buf[offset:], binaryWriter)
		offset += p.fastWriteField45(buf[offset:], binaryWriter)
		offset += p.fastWriteField46(buf[offset:], binaryWriter)
		offset += p.fastWriteField47(buf[offset:], binaryWriter)
		offset += p.fastWriteField48(buf[offset:], binaryWriter)
		offset += p.fastWriteField50(buf[offset:], binaryWriter)
		offset += p.fastWriteField101(buf[offset:], binaryWriter)
		offset += p.fastWriteField103(buf[offset:], binaryWriter)
		offset += p.fastWriteField104(buf[offset:], binaryWriter)
		offset += p.fastWriteField105(buf[offset:], binaryWriter)
		offset += p.fastWriteField106(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TPlanNode) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TPlanNode")
	if p != nil {
		l += p.field1Length()
		l += p.field2Length()
		l += p.field3Length()
		l += p.field4Length()
		l += p.field5Length()
		l += p.field6Length()
		l += p.field7Length()
		l += p.field8Length()
		l += p.field11Length()
		l += p.field12Length()
		l += p.field13Length()
		l += p.field14Length()
		l += p.field15Length()
		l += p.field17Length()
		l += p.field18Length()
		l += p.field19Length()
		l += p.field20Length()
		l += p.field21Length()
		l += p.field22Length()
		l += p.field23Length()
		l += p.field24Length()
		l += p.field25Length()
		l += p.field26Length()
		l += p.field28Length()
		l += p.field29Length()
		l += p.field30Length()
		l += p.field31Length()
		l += p.field32Length()
		l += p.field33Length()
		l += p.field34Length()
		l += p.field35Length()
		l += p.field36Length()
		l += p.field37Length()
		l += p.field40Length()
		l += p.field41Length()
		l += p.field42Length()
		l += p.field43Length()
		l += p.field44Length()
		l += p.field45Length()
		l += p.field46Length()
		l += p.field47Length()
		l += p.field48Length()
		l += p.field49Length()
		l += p.field50Length()
		l += p.field101Length()
		l += p.field102Length()
		l += p.field103Length()
		l += p.field104Length()
		l += p.field105Length()
		l += p.field106Length()
		l += p.field107Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TPlanNode) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "node_id", thrift.I32, 1)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.NodeId)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TPlanNode) fastWriteField2(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "node_type", thrift.I32, 2)
	offset += bthrift.Binary.WriteI32(buf[offset:], int32(p.NodeType))

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TPlanNode) fastWriteField3(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "num_children", thrift.I32, 3)
	offset += bthrift.Binary.WriteI32(buf[offset:], p.NumChildren)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TPlanNode) fastWriteField4(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "limit", thrift.I64, 4)
	offset += bthrift.Binary.WriteI64(buf[offset:], p.Limit)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TPlanNode) fastWriteField5(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "row_tuples", thrift.LIST, 5)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.I32, 0)
	var length int
	for _, v := range p.RowTuples {
		length++
		offset += bthrift.Binary.WriteI32(buf[offset:], v)

	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.I32, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TPlanNode) fastWriteField6(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "nullable_tuples", thrift.LIST, 6)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.BOOL, 0)
	var length int
	for _, v := range p.NullableTuples {
		length++
		offset += bthrift.Binary.WriteBool(buf[offset:], v)

	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.BOOL, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TPlanNode) fastWriteField7(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetConjuncts() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "conjuncts", thrift.LIST, 7)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.Conjuncts {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField8(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "compact_data", thrift.BOOL, 8)
	offset += bthrift.Binary.WriteBool(buf[offset:], p.CompactData)

	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TPlanNode) fastWriteField11(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetHashJoinNode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "hash_join_node", thrift.STRUCT, 11)
		offset += p.HashJoinNode.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField12(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetAggNode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "agg_node", thrift.STRUCT, 12)
		offset += p.AggNode.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField13(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSortNode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "sort_node", thrift.STRUCT, 13)
		offset += p.SortNode.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField14(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetMergeNode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "merge_node", thrift.STRUCT, 14)
		offset += p.MergeNode.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField15(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetExchangeNode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "exchange_node", thrift.STRUCT, 15)
		offset += p.ExchangeNode.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField17(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetMysqlScanNode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "mysql_scan_node", thrift.STRUCT, 17)
		offset += p.MysqlScanNode.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField18(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetOlapScanNode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "olap_scan_node", thrift.STRUCT, 18)
		offset += p.OlapScanNode.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField19(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetCsvScanNode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "csv_scan_node", thrift.STRUCT, 19)
		offset += p.CsvScanNode.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField20(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetBrokerScanNode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "broker_scan_node", thrift.STRUCT, 20)
		offset += p.BrokerScanNode.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField21(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPreAggNode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "pre_agg_node", thrift.STRUCT, 21)
		offset += p.PreAggNode.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField22(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetSchemaScanNode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "schema_scan_node", thrift.STRUCT, 22)
		offset += p.SchemaScanNode.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField23(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetMergeJoinNode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "merge_join_node", thrift.STRUCT, 23)
		offset += p.MergeJoinNode.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField24(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetMetaScanNode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "meta_scan_node", thrift.STRUCT, 24)
		offset += p.MetaScanNode.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField25(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetAnalyticNode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "analytic_node", thrift.STRUCT, 25)
		offset += p.AnalyticNode.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField26(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetOlapRewriteNode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "olap_rewrite_node", thrift.STRUCT, 26)
		offset += p.OlapRewriteNode.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField28(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetUnionNode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "union_node", thrift.STRUCT, 28)
		offset += p.UnionNode.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField29(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetResourceProfile() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "resource_profile", thrift.STRUCT, 29)
		offset += p.ResourceProfile.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField30(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetEsScanNode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "es_scan_node", thrift.STRUCT, 30)
		offset += p.EsScanNode.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField31(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetRepeatNode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "repeat_node", thrift.STRUCT, 31)
		offset += p.RepeatNode.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField32(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetAssertNumRowsNode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "assert_num_rows_node", thrift.STRUCT, 32)
		offset += p.AssertNumRowsNode.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField33(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIntersectNode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "intersect_node", thrift.STRUCT, 33)
		offset += p.IntersectNode.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField34(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetExceptNode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "except_node", thrift.STRUCT, 34)
		offset += p.ExceptNode.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField35(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetOdbcScanNode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "odbc_scan_node", thrift.STRUCT, 35)
		offset += p.OdbcScanNode.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField36(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetRuntimeFilters() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "runtime_filters", thrift.LIST, 36)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.RuntimeFilters {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField37(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetGroupCommitScanNode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "group_commit_scan_node", thrift.STRUCT, 37)
		offset += p.GroupCommitScanNode.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField40(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetVconjunct() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "vconjunct", thrift.STRUCT, 40)
		offset += p.Vconjunct.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField41(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTableFunctionNode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "table_function_node", thrift.STRUCT, 41)
		offset += p.TableFunctionNode.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField42(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetOutputSlotIds() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "output_slot_ids", thrift.LIST, 42)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.I32, 0)
		var length int
		for _, v := range p.OutputSlotIds {
			length++
			offset += bthrift.Binary.WriteI32(buf[offset:], v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.I32, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField43(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDataGenScanNode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "data_gen_scan_node", thrift.STRUCT, 43)
		offset += p.DataGenScanNode.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField44(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetFileScanNode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "file_scan_node", thrift.STRUCT, 44)
		offset += p.FileScanNode.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField45(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetJdbcScanNode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "jdbc_scan_node", thrift.STRUCT, 45)
		offset += p.JdbcScanNode.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField46(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetNestedLoopJoinNode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "nested_loop_join_node", thrift.STRUCT, 46)
		offset += p.NestedLoopJoinNode.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField47(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTestExternalScanNode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "test_external_scan_node", thrift.STRUCT, 47)
		offset += p.TestExternalScanNode.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField48(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPushDownAggTypeOpt() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "push_down_agg_type_opt", thrift.I32, 48)
		offset += bthrift.Binary.WriteI32(buf[offset:], int32(*p.PushDownAggTypeOpt))

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField49(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPushDownCount() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "push_down_count", thrift.I64, 49)
		offset += bthrift.Binary.WriteI64(buf[offset:], *p.PushDownCount)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField50(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetDistributeExprLists() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "distribute_expr_lists", thrift.LIST, 50)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.LIST, 0)
		var length int
		for _, v := range p.DistributeExprLists {
			length++
			listBeginOffset := offset
			offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
			var length int
			for _, v := range v {
				length++
				offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
			}
			bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
			offset += bthrift.Binary.WriteListEnd(buf[offset:])
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.LIST, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField101(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetProjections() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "projections", thrift.LIST, 101)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
		var length int
		for _, v := range p.Projections {
			length++
			offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField102(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetOutputTupleId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "output_tuple_id", thrift.I32, 102)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.OutputTupleId)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField103(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetPartitionSortNode() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "partition_sort_node", thrift.STRUCT, 103)
		offset += p.PartitionSortNode.FastWriteNocopy(buf[offset:], binaryWriter)
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField104(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIntermediateProjectionsList() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "intermediate_projections_list", thrift.LIST, 104)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.LIST, 0)
		var length int
		for _, v := range p.IntermediateProjectionsList {
			length++
			listBeginOffset := offset
			offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
			var length int
			for _, v := range v {
				length++
				offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
			}
			bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
			offset += bthrift.Binary.WriteListEnd(buf[offset:])
		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.LIST, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField105(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetIntermediateOutputTupleIdList() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "intermediate_output_tuple_id_list", thrift.LIST, 105)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.I32, 0)
		var length int
		for _, v := range p.IntermediateOutputTupleIdList {
			length++
			offset += bthrift.Binary.WriteI32(buf[offset:], v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.I32, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField106(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetTopnFilterSourceNodeIds() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "topn_filter_source_node_ids", thrift.LIST, 106)
		listBeginOffset := offset
		offset += bthrift.Binary.ListBeginLength(thrift.I32, 0)
		var length int
		for _, v := range p.TopnFilterSourceNodeIds {
			length++
			offset += bthrift.Binary.WriteI32(buf[offset:], v)

		}
		bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.I32, length)
		offset += bthrift.Binary.WriteListEnd(buf[offset:])
		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) fastWriteField107(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	if p.IsSetNereidsId() {
		offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "nereids_id", thrift.I32, 107)
		offset += bthrift.Binary.WriteI32(buf[offset:], *p.NereidsId)

		offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	}
	return offset
}

func (p *TPlanNode) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("node_id", thrift.I32, 1)
	l += bthrift.Binary.I32Length(p.NodeId)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TPlanNode) field2Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("node_type", thrift.I32, 2)
	l += bthrift.Binary.I32Length(int32(p.NodeType))

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TPlanNode) field3Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("num_children", thrift.I32, 3)
	l += bthrift.Binary.I32Length(p.NumChildren)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TPlanNode) field4Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("limit", thrift.I64, 4)
	l += bthrift.Binary.I64Length(p.Limit)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TPlanNode) field5Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("row_tuples", thrift.LIST, 5)
	l += bthrift.Binary.ListBeginLength(thrift.I32, len(p.RowTuples))
	var tmpV types.TTupleId
	l += bthrift.Binary.I32Length(int32(tmpV)) * len(p.RowTuples)
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TPlanNode) field6Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("nullable_tuples", thrift.LIST, 6)
	l += bthrift.Binary.ListBeginLength(thrift.BOOL, len(p.NullableTuples))
	var tmpV bool
	l += bthrift.Binary.BoolLength(bool(tmpV)) * len(p.NullableTuples)
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TPlanNode) field7Length() int {
	l := 0
	if p.IsSetConjuncts() {
		l += bthrift.Binary.FieldBeginLength("conjuncts", thrift.LIST, 7)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.Conjuncts))
		for _, v := range p.Conjuncts {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field8Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("compact_data", thrift.BOOL, 8)
	l += bthrift.Binary.BoolLength(p.CompactData)

	l += bthrift.Binary.FieldEndLength()
	return l
}

func (p *TPlanNode) field11Length() int {
	l := 0
	if p.IsSetHashJoinNode() {
		l += bthrift.Binary.FieldBeginLength("hash_join_node", thrift.STRUCT, 11)
		l += p.HashJoinNode.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field12Length() int {
	l := 0
	if p.IsSetAggNode() {
		l += bthrift.Binary.FieldBeginLength("agg_node", thrift.STRUCT, 12)
		l += p.AggNode.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field13Length() int {
	l := 0
	if p.IsSetSortNode() {
		l += bthrift.Binary.FieldBeginLength("sort_node", thrift.STRUCT, 13)
		l += p.SortNode.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field14Length() int {
	l := 0
	if p.IsSetMergeNode() {
		l += bthrift.Binary.FieldBeginLength("merge_node", thrift.STRUCT, 14)
		l += p.MergeNode.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field15Length() int {
	l := 0
	if p.IsSetExchangeNode() {
		l += bthrift.Binary.FieldBeginLength("exchange_node", thrift.STRUCT, 15)
		l += p.ExchangeNode.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field17Length() int {
	l := 0
	if p.IsSetMysqlScanNode() {
		l += bthrift.Binary.FieldBeginLength("mysql_scan_node", thrift.STRUCT, 17)
		l += p.MysqlScanNode.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field18Length() int {
	l := 0
	if p.IsSetOlapScanNode() {
		l += bthrift.Binary.FieldBeginLength("olap_scan_node", thrift.STRUCT, 18)
		l += p.OlapScanNode.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field19Length() int {
	l := 0
	if p.IsSetCsvScanNode() {
		l += bthrift.Binary.FieldBeginLength("csv_scan_node", thrift.STRUCT, 19)
		l += p.CsvScanNode.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field20Length() int {
	l := 0
	if p.IsSetBrokerScanNode() {
		l += bthrift.Binary.FieldBeginLength("broker_scan_node", thrift.STRUCT, 20)
		l += p.BrokerScanNode.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field21Length() int {
	l := 0
	if p.IsSetPreAggNode() {
		l += bthrift.Binary.FieldBeginLength("pre_agg_node", thrift.STRUCT, 21)
		l += p.PreAggNode.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field22Length() int {
	l := 0
	if p.IsSetSchemaScanNode() {
		l += bthrift.Binary.FieldBeginLength("schema_scan_node", thrift.STRUCT, 22)
		l += p.SchemaScanNode.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field23Length() int {
	l := 0
	if p.IsSetMergeJoinNode() {
		l += bthrift.Binary.FieldBeginLength("merge_join_node", thrift.STRUCT, 23)
		l += p.MergeJoinNode.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field24Length() int {
	l := 0
	if p.IsSetMetaScanNode() {
		l += bthrift.Binary.FieldBeginLength("meta_scan_node", thrift.STRUCT, 24)
		l += p.MetaScanNode.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field25Length() int {
	l := 0
	if p.IsSetAnalyticNode() {
		l += bthrift.Binary.FieldBeginLength("analytic_node", thrift.STRUCT, 25)
		l += p.AnalyticNode.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field26Length() int {
	l := 0
	if p.IsSetOlapRewriteNode() {
		l += bthrift.Binary.FieldBeginLength("olap_rewrite_node", thrift.STRUCT, 26)
		l += p.OlapRewriteNode.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field28Length() int {
	l := 0
	if p.IsSetUnionNode() {
		l += bthrift.Binary.FieldBeginLength("union_node", thrift.STRUCT, 28)
		l += p.UnionNode.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field29Length() int {
	l := 0
	if p.IsSetResourceProfile() {
		l += bthrift.Binary.FieldBeginLength("resource_profile", thrift.STRUCT, 29)
		l += p.ResourceProfile.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field30Length() int {
	l := 0
	if p.IsSetEsScanNode() {
		l += bthrift.Binary.FieldBeginLength("es_scan_node", thrift.STRUCT, 30)
		l += p.EsScanNode.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field31Length() int {
	l := 0
	if p.IsSetRepeatNode() {
		l += bthrift.Binary.FieldBeginLength("repeat_node", thrift.STRUCT, 31)
		l += p.RepeatNode.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field32Length() int {
	l := 0
	if p.IsSetAssertNumRowsNode() {
		l += bthrift.Binary.FieldBeginLength("assert_num_rows_node", thrift.STRUCT, 32)
		l += p.AssertNumRowsNode.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field33Length() int {
	l := 0
	if p.IsSetIntersectNode() {
		l += bthrift.Binary.FieldBeginLength("intersect_node", thrift.STRUCT, 33)
		l += p.IntersectNode.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field34Length() int {
	l := 0
	if p.IsSetExceptNode() {
		l += bthrift.Binary.FieldBeginLength("except_node", thrift.STRUCT, 34)
		l += p.ExceptNode.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field35Length() int {
	l := 0
	if p.IsSetOdbcScanNode() {
		l += bthrift.Binary.FieldBeginLength("odbc_scan_node", thrift.STRUCT, 35)
		l += p.OdbcScanNode.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field36Length() int {
	l := 0
	if p.IsSetRuntimeFilters() {
		l += bthrift.Binary.FieldBeginLength("runtime_filters", thrift.LIST, 36)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.RuntimeFilters))
		for _, v := range p.RuntimeFilters {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field37Length() int {
	l := 0
	if p.IsSetGroupCommitScanNode() {
		l += bthrift.Binary.FieldBeginLength("group_commit_scan_node", thrift.STRUCT, 37)
		l += p.GroupCommitScanNode.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field40Length() int {
	l := 0
	if p.IsSetVconjunct() {
		l += bthrift.Binary.FieldBeginLength("vconjunct", thrift.STRUCT, 40)
		l += p.Vconjunct.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field41Length() int {
	l := 0
	if p.IsSetTableFunctionNode() {
		l += bthrift.Binary.FieldBeginLength("table_function_node", thrift.STRUCT, 41)
		l += p.TableFunctionNode.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field42Length() int {
	l := 0
	if p.IsSetOutputSlotIds() {
		l += bthrift.Binary.FieldBeginLength("output_slot_ids", thrift.LIST, 42)
		l += bthrift.Binary.ListBeginLength(thrift.I32, len(p.OutputSlotIds))
		var tmpV types.TSlotId
		l += bthrift.Binary.I32Length(int32(tmpV)) * len(p.OutputSlotIds)
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field43Length() int {
	l := 0
	if p.IsSetDataGenScanNode() {
		l += bthrift.Binary.FieldBeginLength("data_gen_scan_node", thrift.STRUCT, 43)
		l += p.DataGenScanNode.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field44Length() int {
	l := 0
	if p.IsSetFileScanNode() {
		l += bthrift.Binary.FieldBeginLength("file_scan_node", thrift.STRUCT, 44)
		l += p.FileScanNode.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field45Length() int {
	l := 0
	if p.IsSetJdbcScanNode() {
		l += bthrift.Binary.FieldBeginLength("jdbc_scan_node", thrift.STRUCT, 45)
		l += p.JdbcScanNode.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field46Length() int {
	l := 0
	if p.IsSetNestedLoopJoinNode() {
		l += bthrift.Binary.FieldBeginLength("nested_loop_join_node", thrift.STRUCT, 46)
		l += p.NestedLoopJoinNode.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field47Length() int {
	l := 0
	if p.IsSetTestExternalScanNode() {
		l += bthrift.Binary.FieldBeginLength("test_external_scan_node", thrift.STRUCT, 47)
		l += p.TestExternalScanNode.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field48Length() int {
	l := 0
	if p.IsSetPushDownAggTypeOpt() {
		l += bthrift.Binary.FieldBeginLength("push_down_agg_type_opt", thrift.I32, 48)
		l += bthrift.Binary.I32Length(int32(*p.PushDownAggTypeOpt))

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field49Length() int {
	l := 0
	if p.IsSetPushDownCount() {
		l += bthrift.Binary.FieldBeginLength("push_down_count", thrift.I64, 49)
		l += bthrift.Binary.I64Length(*p.PushDownCount)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field50Length() int {
	l := 0
	if p.IsSetDistributeExprLists() {
		l += bthrift.Binary.FieldBeginLength("distribute_expr_lists", thrift.LIST, 50)
		l += bthrift.Binary.ListBeginLength(thrift.LIST, len(p.DistributeExprLists))
		for _, v := range p.DistributeExprLists {
			l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(v))
			for _, v := range v {
				l += v.BLength()
			}
			l += bthrift.Binary.ListEndLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field101Length() int {
	l := 0
	if p.IsSetProjections() {
		l += bthrift.Binary.FieldBeginLength("projections", thrift.LIST, 101)
		l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.Projections))
		for _, v := range p.Projections {
			l += v.BLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field102Length() int {
	l := 0
	if p.IsSetOutputTupleId() {
		l += bthrift.Binary.FieldBeginLength("output_tuple_id", thrift.I32, 102)
		l += bthrift.Binary.I32Length(*p.OutputTupleId)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field103Length() int {
	l := 0
	if p.IsSetPartitionSortNode() {
		l += bthrift.Binary.FieldBeginLength("partition_sort_node", thrift.STRUCT, 103)
		l += p.PartitionSortNode.BLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field104Length() int {
	l := 0
	if p.IsSetIntermediateProjectionsList() {
		l += bthrift.Binary.FieldBeginLength("intermediate_projections_list", thrift.LIST, 104)
		l += bthrift.Binary.ListBeginLength(thrift.LIST, len(p.IntermediateProjectionsList))
		for _, v := range p.IntermediateProjectionsList {
			l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(v))
			for _, v := range v {
				l += v.BLength()
			}
			l += bthrift.Binary.ListEndLength()
		}
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field105Length() int {
	l := 0
	if p.IsSetIntermediateOutputTupleIdList() {
		l += bthrift.Binary.FieldBeginLength("intermediate_output_tuple_id_list", thrift.LIST, 105)
		l += bthrift.Binary.ListBeginLength(thrift.I32, len(p.IntermediateOutputTupleIdList))
		var tmpV types.TTupleId
		l += bthrift.Binary.I32Length(int32(tmpV)) * len(p.IntermediateOutputTupleIdList)
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field106Length() int {
	l := 0
	if p.IsSetTopnFilterSourceNodeIds() {
		l += bthrift.Binary.FieldBeginLength("topn_filter_source_node_ids", thrift.LIST, 106)
		l += bthrift.Binary.ListBeginLength(thrift.I32, len(p.TopnFilterSourceNodeIds))
		var tmpV int32
		l += bthrift.Binary.I32Length(int32(tmpV)) * len(p.TopnFilterSourceNodeIds)
		l += bthrift.Binary.ListEndLength()
		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlanNode) field107Length() int {
	l := 0
	if p.IsSetNereidsId() {
		l += bthrift.Binary.FieldBeginLength("nereids_id", thrift.I32, 107)
		l += bthrift.Binary.I32Length(*p.NereidsId)

		l += bthrift.Binary.FieldEndLength()
	}
	return l
}

func (p *TPlan) FastRead(buf []byte) (int, error) {
	var err error
	var offset int
	var l int
	var fieldTypeId thrift.TType
	var fieldId int16
	var issetNodes bool = false
	_, l, err = bthrift.Binary.ReadStructBegin(buf)
	offset += l
	if err != nil {
		goto ReadStructBeginError
	}

	for {
		_, fieldTypeId, fieldId, l, err = bthrift.Binary.ReadFieldBegin(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				l, err = p.FastReadField1(buf[offset:])
				offset += l
				if err != nil {
					goto ReadFieldError
				}
				issetNodes = true
			} else {
				l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
				offset += l
				if err != nil {
					goto SkipFieldError
				}
			}
		default:
			l, err = bthrift.Binary.Skip(buf[offset:], fieldTypeId)
			offset += l
			if err != nil {
				goto SkipFieldError
			}
		}

		l, err = bthrift.Binary.ReadFieldEnd(buf[offset:])
		offset += l
		if err != nil {
			goto ReadFieldEndError
		}
	}
	l, err = bthrift.Binary.ReadStructEnd(buf[offset:])
	offset += l
	if err != nil {
		goto ReadStructEndError
	}

	if !issetNodes {
		fieldId = 1
		goto RequiredFieldNotSetError
	}
	return offset, nil
ReadStructBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct begin error: ", p), err)
ReadFieldBeginError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d begin error: ", p, fieldId), err)
ReadFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field %d '%s' error: ", p, fieldId, fieldIDToName_TPlan[fieldId]), err)
SkipFieldError:
	return offset, thrift.PrependError(fmt.Sprintf("%T field %d skip type %d error: ", p, fieldId, fieldTypeId), err)
ReadFieldEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read field end error", p), err)
ReadStructEndError:
	return offset, thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
RequiredFieldNotSetError:
	return offset, thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("required field %s is not set", fieldIDToName_TPlan[fieldId]))
}

func (p *TPlan) FastReadField1(buf []byte) (int, error) {
	offset := 0

	_, size, l, err := bthrift.Binary.ReadListBegin(buf[offset:])
	offset += l
	if err != nil {
		return offset, err
	}
	p.Nodes = make([]*TPlanNode, 0, size)
	for i := 0; i < size; i++ {
		_elem := NewTPlanNode()
		if l, err := _elem.FastRead(buf[offset:]); err != nil {
			return offset, err
		} else {
			offset += l
		}

		p.Nodes = append(p.Nodes, _elem)
	}
	if l, err := bthrift.Binary.ReadListEnd(buf[offset:]); err != nil {
		return offset, err
	} else {
		offset += l
	}
	return offset, nil
}

// for compatibility
func (p *TPlan) FastWrite(buf []byte) int {
	return 0
}

func (p *TPlan) FastWriteNocopy(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteStructBegin(buf[offset:], "TPlan")
	if p != nil {
		offset += p.fastWriteField1(buf[offset:], binaryWriter)
	}
	offset += bthrift.Binary.WriteFieldStop(buf[offset:])
	offset += bthrift.Binary.WriteStructEnd(buf[offset:])
	return offset
}

func (p *TPlan) BLength() int {
	l := 0
	l += bthrift.Binary.StructBeginLength("TPlan")
	if p != nil {
		l += p.field1Length()
	}
	l += bthrift.Binary.FieldStopLength()
	l += bthrift.Binary.StructEndLength()
	return l
}

func (p *TPlan) fastWriteField1(buf []byte, binaryWriter bthrift.BinaryWriter) int {
	offset := 0
	offset += bthrift.Binary.WriteFieldBegin(buf[offset:], "nodes", thrift.LIST, 1)
	listBeginOffset := offset
	offset += bthrift.Binary.ListBeginLength(thrift.STRUCT, 0)
	var length int
	for _, v := range p.Nodes {
		length++
		offset += v.FastWriteNocopy(buf[offset:], binaryWriter)
	}
	bthrift.Binary.WriteListBegin(buf[listBeginOffset:], thrift.STRUCT, length)
	offset += bthrift.Binary.WriteListEnd(buf[offset:])
	offset += bthrift.Binary.WriteFieldEnd(buf[offset:])
	return offset
}

func (p *TPlan) field1Length() int {
	l := 0
	l += bthrift.Binary.FieldBeginLength("nodes", thrift.LIST, 1)
	l += bthrift.Binary.ListBeginLength(thrift.STRUCT, len(p.Nodes))
	for _, v := range p.Nodes {
		l += v.BLength()
	}
	l += bthrift.Binary.ListEndLength()
	l += bthrift.Binary.FieldEndLength()
	return l
}
